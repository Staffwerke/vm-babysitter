#!/bin/bash

# -----------------------------------------------------------------------------
# This scipt holds all the functions and global variables used by other scripts.
# -----------------------------------------------------------------------------


# Base MAC address used on the qemu/kvm implementation:
base_mac_addr="52:54:00"

# Guess OS name by kernel and returns a string with '1' if OS is Unraid, nothing otherwise:
# -----------------------------------------------------------------------------
is_unraid()
{
    local is_unraid_status=1
    [[ ! -z $(uname  -r | grep -e "-Unraid$") ]] && echo "1"
}

# Returns a string value with the state reported by libvirt (e.g. "running", "shut off", etc.)
# -----------------------------------------------------------------------------
domain_state()
{
    echo $(virsh domstate $1)
}

# Returns a string value with the UUID of the given domain:
# -----------------------------------------------------------------------------
domain_id()
{
    echo $(virsh dominfo $1 | grep -w "UUID:" | rev | cut -d' ' -f1 | rev)
}

# For a given VM name, returns a string value with absoulte path to its image disks (e.g. "/path-to/hdc.img /path-to/hdd.img")
# -----------------------------------------------------------------------------
list_vm_img_paths()
{
    echo $(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/ file //g' -e 's/ disk //g' | rev | cut -d' ' -f1 | rev )
}

# Sorts unordered items lexicographically. This is used for user input not in order:
# -----------------------------------------------------------------------------
sort_items()
{
    echo $@ | xargs -n1 | sort | xargs
}

# Sends shutdown signal and awaits until domain has been shutted down to return success:
# -----------------------------------------------------------------------------
shutdown_vm()
{
local shutdown_vm_status=1
local vm_needed_state="shut off"

if [[ $(domain_state $1) == $vm_needed_state ]]; then

    echo "INFO: VM '$1' is already $vm_needed_state"
    shutdown_vm_status=0
else

    local wait_time=15
    local max_attempts=10
    local attempt=1

    while (( $attempt < $max_attempts )); do

        virsh shutdown $1

        sleep $wait_time

        [[ $(domain_state $1) == $vm_needed_state ]] && { shutdown_vm_status=0; break; } || ((attempt++))
    done

    local message=""
    [[ $shutdown_vm_status -eq 0 ]] && message="INFO: VM '$1' powered off successfully" || message="WARNING: Gave up after $(( $wait_time * $max_attempts )) secs. waiting for VM '$1' to power off"
fi

    echo $message
    return $shutdown_vm_status
}

# Returns a random, uppercase, MAC address, based upon (optional) base pattern 'XX:XX:XX'
# -----------------------------------------------------------------------------
gen_random_macaddr()
{
    local seed=$1

    # If no base pattern is provided, will use a fixed parameter
    [[ -z $seed ]] && seed=$base_mac_addr

    printf '%s:%02X:%02X:%02X\n' ${seed^^} $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))
}

# Returns a string that is a space separated list of mac addresses of a given VM:
# -----------------------------------------------------------------------------
get_vm_macaddr()
{
    echo $(virsh domiflist --inactive $1 | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}')
}

# For a given VM name, returns a string value with (restorable) virtual drives (separated by spaces) (e.g. "hdc hdd")
# -----------------------------------------------------------------------------
list_vm_drives()
{
    echo $(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/file//g' -e 's/disk//g' -e 's/ //g' | cut -d'/' -f1)
}

# Determines if a domain is patched for incremental backups, returning the string 'true' if patched, and 'false' if not:
# -----------------------------------------------------------------------------
vm_is_patched()
{

    # Expected match on non-patched VMs:
    local original_pattern="<domain type='kvm'>"

    # Expected match on manually modified VMs (e.g. with 'virsh edit $target_domain')
    local modified_pattern="<domain type='kvm' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'>"

    local match=$(virsh dumpxml --inactive --security-info $1 | grep -e "$original_pattern" -e "$modified_pattern")

    [[ $match == $modified_pattern ]] && echo "true" || echo "false"
}

# Patches a given xml file to provide incremental backups capability, returning sed status
# (Assumes the xml file has no patch):
# -----------------------------------------------------------------------------
patch_xml()
{
    # Modifies the XML file with sed, adding parameters as of virtnbdbackup documentation:
    sed -i -e "s|<domain type='kvm'>|<domain type='kvm' id='1' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'>|" -e "/<\/domain>/i \ \ <qemu:capabilities>\n      <qemu:add capability='incremental-backup'\/>\n  <\/qemu:capabilities>" $1

    return $?
}
