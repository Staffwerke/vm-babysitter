#!/bin/bash

# -----------------------------------------------------------------------------
# This scipt holds all the functions and global variables used by other scripts.
# -----------------------------------------------------------------------------

# Base MAC address used on the qemu/kvm implementation:
base_mac_addr="52:54:00"

# Maximum time to await for a response in certain functions:
wait_time=15

# SSH port can be omitted if 22. Otherwise, '-p <port_number>' :
ssh_port=""

# Guess OS name by kernel and returns a string with 'yes' if OS is Unraid, and otherwise 'no':
# -----------------------------------------------------------------------------
is_unraid()
{
    local is_unraid_status=1
    [[ ! -z $(uname  -r | grep -e "-Unraid$") ]] && echo "yes" || echo "no"
}

# Returns a string value with the state reported by libvirt (e.g. "running", "shut off", etc.)
# -----------------------------------------------------------------------------
domain_state()
{
    echo $(virsh domstate $1)
}

# Returns a string value with the UUID of the given domain:
# -----------------------------------------------------------------------------
domain_id()
{
    echo $(virsh dominfo $1 | grep -w "UUID:" | rev | cut -d' ' -f1 | rev)
}

# For a given VM name, returns a string value with absoulte path to its image disks (e.g. "/path-to/hdc.img /path-to/hdd.img")
# -----------------------------------------------------------------------------
list_vm_img_paths()
{
    echo $(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/ file //g' -e 's/ disk //g' | rev | cut -d' ' -f1 | rev )
}

# Sorts unordered items lexicographically. This is used for user input not in order:
# -----------------------------------------------------------------------------
sort_items()
{
    echo $@ | xargs -n1 | sort | xargs
}

# Sends shutdown signal and awaits until domain has been shutted down to return success:
# -----------------------------------------------------------------------------
shutdown_vm()
{
local shutdown_vm_status=1
local vm_needed_state="shut off"

if [[ $(domain_state $1) == $vm_needed_state ]]; then

    echo "INFO: VM '$1' is already $vm_needed_state"
    shutdown_vm_status=0
else

    #local wait_time=15
    local max_attempts=10
    local attempt=1

    while (( $attempt < $max_attempts )); do

        virsh shutdown $1

        sleep $wait_time

        [[ $(domain_state $1) == $vm_needed_state ]] && { shutdown_vm_status=0; break; } || ((attempt++))
    done

    local message=""
    [[ $shutdown_vm_status -eq 0 ]] && message="INFO: VM '$1' powered off successfully" || message="WARNING: Gave up after $(( $wait_time * $max_attempts )) secs. awaiting for VM '$1' to power off"
fi

    echo $message
    return $shutdown_vm_status
}

# Returns a random, uppercase, MAC address, based upon (optional) base pattern 'XX:XX:XX'
# -----------------------------------------------------------------------------
gen_random_macaddr()
{
    local seed=$1

    # If no base pattern is provided, will use a fixed parameter
    [[ -z $seed ]] && seed=$base_mac_addr

    printf '%s:%02X:%02X:%02X\n' ${seed^^} $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))
}

# Returns a string that is a space separated list of mac addresses of a given VM:
# -----------------------------------------------------------------------------
get_vm_macaddr()
{
    echo $(virsh domiflist --inactive $1 | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}')
}

# For a given VM name, returns a string value with (restorable) virtual drives (separated by spaces) (e.g. "hdc hdd")
# -----------------------------------------------------------------------------
list_vm_drives()
{
    echo $(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/file//g' -e 's/disk//g' -e 's/ //g' | cut -d'/' -f1)
}

# Determines if a domain is patched for incremental backups, returning the string 'true' if patched, and 'false' if not:
# -----------------------------------------------------------------------------
vm_is_patched()
{

    # Expected match on non-patched VMs:
    local original_pattern="<domain type='kvm'>"

    # Expected match on manually modified VMs (e.g. with 'virsh edit $target_domain')
    local modified_pattern="<domain type='kvm' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'>"

    local match=$(virsh dumpxml --inactive --security-info $1 | grep -e "$original_pattern" -e "$modified_pattern")

    [[ $match == $modified_pattern ]] && echo "true" || echo "false"
}

# Patches a given xml file to provide incremental backups capability, returning sed status
# (Assumes the xml file has no patch):
# -----------------------------------------------------------------------------
patch_xml()
{
    # Modifies the XML file with sed, adding parameters as of virtnbdbackup documentation:
    sed -i -e "s|<domain type='kvm'>|<domain type='kvm' id='1' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'>|" -e "/<\/domain>/i \ \ <qemu:capabilities>\n      <qemu:add capability='incremental-backup'\/>\n  <\/qemu:capabilities>" $1

    return $?
}

# Prompts a given question to the user, and returns either 'yes' or 'no':
# -----------------------------------------------------------------------------
yes_no()
{
    local question=$1
    local default_choice=$2
    local trailing_string="[yes/no]"
    local choice

    while true; do

        # Prompts and in case $default_choice was provided, it's displayed with upper caps:
        read -p "$question ${trailing_string/$default_choice/${default_choice^^}}: " choice

        case $choice in

            yes|YES|no|NO)

                echo ${choice,,}
                break
            ;;
            "")
                if [ ! -z $default_choice ]; then

                    echo $default_choice
                    break
                fi
            ;;
        esac

    done
}

# Prompts a given question to the user amd returns a number if is within (also given) parameters:
# -----------------------------------------------------------------------------
choose_number()
{
        local question=$1
        local min_choice=$2
        local max_choice=$3
        if [ ! -z $4 ] || [[ $min_choice -eq $max_choice ]]; then
            local default_choice=" (defaults to '$4')"
        fi
        local choice

    while true; do

        read -p "$question [$min_choice-$max_choice]$default_choice: " choice

        case $choice in

            [0-9])
                if [[ $choice -ge $min_choice ]] && [[ $choice -le $max_choice ]]; then

                    echo $choice
                    break
                fi
            ;;

            "")
                if [ ! -z $4 ]; then

                    echo $4
                    break
                fi
        esac
    done
}

# Sends a command string $2 via ssh to the server $1, returning the status of the operation:
#------------------------------------------------------------------------------
ssh_command()
{
    ssh $ssh_port -q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=$wait_time $1 $2
    return $?

}

# Sends a file $2 with scp to the server $1 at path $3, returning the status of the operation:
#------------------------------------------------------------------------------
scp_command()
{
    scp $ssh_port -q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=$wait_time $2 $1:$3
}

# Onto a local folder $3, mounts a remote folder located at $1:$2 via ssh, returning the status of the operation:
# To close the connection, only needs to 'umount $3'
#------------------------------------------------------------------------------
sshfs_command()
{
    sshfs $ssh_port -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=$wait_time  $1:$2 $3
}
