#!/bin/bash

# Variables:
# -----------------------------------------------------------------------------
# Temporal path to store files (as .xml):
working_path="/tmp/.$(basename $0).tmp"

show_info()
{
cat << end_of_info

 $(basename $0) -- Replicates a given virtual machine onto a local or remote endpoint

 REQUIREMENTS:
    - libvirt service running (in all involved hosts)
    - qemu-img (this host)
    - ssh, scp and sshfs (this host)
    - ssh server (remote host)
    - Both hosts must be set with proper SSH keys based authentication, in ways this host can connect with the other directly.

 INSTRUCTIONS:
    - A series of options and questions will be presented, and must be answered
    - You will be asked for confirmation before to start the process
    - Once completed, it will display the final result about the operation.

(Maintainer: AdriÃ¡n Parilli <adrian.parilli@staffwerke.de>)
end_of_info
}

# -----------------------------------------------------------------------------
# Main execution:
# -----------------------------------------------------------------------------

# Load functions:
source /usr/local/bin/vm-functions

status=1
if [[ -z $@ ]]; then

    # -----------------------------------------------------------------------------
    # Beginning of interactive part:
    # -----------------------------------------------------------------------------

    #show_info

    echo -e "Scanning for Virtual Machines...\n"
    vms_list=($(domains_list))

    if [[ $? -eq 0 && ${#vms_list[@]} -gt 0 ]]; then

        # Proceeds if libvirt doesn't report an error, and if there is, at least, one non-trasient domain:
        echo "Total domains found in this host: ${#vms_list[@]}:"
        echo '-------------------------------------------------------------------------------'
        printf "%3s %-31s %6s %-19s %s \n" "#" "Domain" "MB RAM" "Drives" "MAC Addresses"
        echo '-------------------------------------------------------------------------------'

        i=0
        for vm in "${vms_list[@]}"; do

            # Get lists with drives and MAC addresses in each VM that can be restored:
            vm_drives_list+=("$(domain_drives_list $vm)")
            vm_ram_list+=("$(domain_getmem $vm --max)")
            src_macaddr_list+=("$(domain_macaddr_list $vm)")

            # Shows each VM found, including the restorable drives and MACs:
            printf "%3s %-31s %6s %-19s %s \n" "$(($i+1))" "$vm" "$((${vm_ram_list[$i]} / 1024))" "${vm_drives_list[$i]:-"None"}" "${src_macaddr_list[$i]:-"None"}"
            ((i++))
        done

        # Asks the user to choose a VM to clone:
        # -----------------------------------------------------------------------------
        echo ""
        choice=$(choose_number "Choose a domain to be replicated" "1" "${#vms_list[@]}")

        # Saves VM specs that will be used for restoration:
        src_vm="${vms_list[(( $choice - 1 ))]}"                     # Domain name
        vm_ram_list=(${vm_ram_list[(( $choice - 1 ))]})             # Max RAM (in KiB)
        vm_drives_list=(${vm_drives_list[(( $choice - 1 ))]})       # List of drives (targets)
        src_macaddr_list=(${src_macaddr_list[(( $choice - 1 ))]})           # List of NIC's MAC address(es)

        src_vm_img_paths_list=($(domain_img_paths_list $src_vm))    # Path(s) to disk image file(s)

        echo "Domain '$src_vm' selected for replication"

        # Asks the user to replicate onto local, or remote VM:
        # -----------------------------------------------------------------------------
        echo ""
        echo '-------------------------------------------------------------------------------'
        echo "Select the endpoint where to replicate domain '$src_vm'"
        echo '-------------------------------------------------------------------------------'
        echo "1. This host (local)"
        echo "2. Another host (via SSH)"
        echo ""
        choice=$(choose_number "Choose an endpoint option" "1" "2" "1")

        case $choice in

            1)
                endpoint="local"
                echo "Destination endpoint will be this same host"
                break
            ;;

            2)
                endpoint="remote"

                # Ask for SSH login:
                while true; do

                    read -p "Provide a valid SSH login (and optionally, port) where domain '$src_vm' will be replicated (e.g. '-p2222 user@hostname'): " remote_server

                    if [[ $remote_server == *@* ]]; then

                        # Grabs server separately:
                        remote_server_name=$(echo $remote_server | cut -d'@' -f2)

                        # Test remote host connectivity and libvirt:
                        ssh $SSH_OPTIONS $remote_server "exit 0"
                        remote_server_status=$?

                        if [[ $remote_server_status -eq 0 ]]; then

                            # Server returns the command status sent. Looks up for libvirt API:
                            remote_api_version=$(ssh $SSH_OPTIONS $remote_server 'echo $(virsh --version)')
                            remote_api_status=$?

                            if [[ $remote_api_status -eq 0 ]]; then

                                echo ""
                                echo "Host $remote_server_name contacted successfully (Libvirt version: $remote_api_version)"

                                # Gets the list of VMs from $remote_server to discard duplicates on the remote endpoint:
                                vms_list=($(ssh $SSH_OPTIONS $remote_server "virsh list --all --persistent --name"))

                                # Breaks the loop:
                                break

                            else
                                echo "ERROR: Cannot connect with remote Libvirt service located at $remote_server_name (Libvirt exit code: $remote_api_status)"
                            fi

                        else
                            echo "ERROR: Cannot connect with host '$remote_server_name' (SSH exit code: $remote_server_status)"
                        fi

                    else
                        echo "ERROR: Incorrect syntax for endpoint '$remote_server'. It must be an SSH valid login"
                    fi
                done
            ;;
        esac

        # Asks the user for a name to be used for the New VM:
        # -----------------------------------------------------------------------------
        echo ""
        read -p "Choose a name for the domain that will be replicated: " dest_vm

        while [[ $dest_vm == $(grep -o -e "$dest_vm" <<< "${vms_list[@]}") ]]; do

            # Ask for a different name if the domain already exists on the list
            # (fetched at the beginning or when a remote endpoint was chosen):
            read -p "Domain '$dest_vm' already exists at the chosen endpoint. Choose a different name: " dest_vm
        done

        if [[ -n ${vm_drives_list[@]} ]]; then

            # Asks the user for copying disks from $src_vm for $dest_vm
            # -----------------------------------------------------------------------------
            copy_disks=$(yes_no "Replicate the disk image(s): [${vm_drives_list[@]// /,}] from '$src_vm' into '$dest_vm'?" "yes")

            case $copy_disks in

                yes)

                    # Looks for the VM state and notifies about a sudden shutdown (necessary to perform disk replication):
                    src_vm_state=$(domain_state $src_vm)

                    [[  $src_vm_state != "shut off" ]] \
                        && copy_disks=$(yes_no "NOTICE: Domain '$src_vm' is currently $src_vm_state. It will be temporarily SHUT DOWN until the process had finished. ARE YOU SURE YOU WANT TO PROCEED? ('yes' to confirm)" "no")

                    [[ $copy_disks == yes ]] \
                        && echo "Disk images will be provisioned" \
                        || { echo -e "\nReplication cancelled by user\n"; exit; }
                ;;

                no)
                    echo "No disk image(s) will be provisioned. It must be provided manually"

                    # Asks the user for checking / modifying paths:
                    # -----------------------------------------------------------------------------
                    check_paths=$(yes_no "Check anyway, and possibly redefine image disk path(s) for domain '$dest_vm'?" "yes")
            esac

            if [[ $copy_disks == yes ]] || [[ $check_paths == yes ]]; then

                # When disk images are to be copied, or the user wants to check / redefine new paths for $dest_vm

                # Shows the possible options and ways to modify them:
                # -----------------------------------------------------------------------------
                i=0
                for path in ${src_vm_img_paths_list[@]}; do

                    proposed_path=""

                    # Number of options present in the below dialog:
                    menu_option=1

                    echo ""
                    echo '-------------------------------------------------------------------------------'
                    echo "Options for disk ${vm_drives_list[$i]} (source: $path)"
                    echo '-------------------------------------------------------------------------------'
                    echo ""
                    echo "$menu_option. Set the disk image path to a custom location and name"


                    # Attempts to find a NEW path matching by VM name:
                    if [[ $path != ${path//$src_vm/$dest_vm} ]]; then

                        # If this action is possible, proposes it as an option:
                        proposed_path=${path//$src_vm/$dest_vm}

                        ((menu_option++))
                        echo "$menu_option. Set the disk image path automatically to: $proposed_path"
                    fi

                    if [[ $copy_disks == no ]] || [[ $endpoint == remote ]]; then

                        # Only when user has chosen to not copy disks or the VM will be replicated on another host, it shows the 3rd option:
                        ((menu_option++))
                        echo "$menu_option. Keep the disk image path unchanged: $path"
                    fi

                    echo ""
                    choice=$(choose_number "Choose the desired action to perform" "1" "$menu_option")

                    case $choice in

                        1)  # User has chosen to set path manually:

                            echo ""
                            read -p "Insert the absolute path to the destination disk image: " manual_path

                            while [[ $manual_path != /* ]]; do

                                read -p "Invalid path '$manual_path'. It must be an absolute path: " manual_path
                            done

                            dest_vm_img_paths_list+=($manual_path)
                        ;;

                        2)
                            if [[ -n $proposed_path ]]; then

                                # proposed_path is plausible and has been chosen:
                                dest_vm_img_paths_list+=($proposed_path)

                            elif [[ $copy_disks == yes ]] || [[ $endpoint == remote ]]; then

                                # proposed_path IS NOT plausible. copy_disks was set to 'no' or endpoint set to 'remote'
                                # User has set to keep path:
                                dest_vm_img_paths_list+=($path)
                            fi
                        ;;

                        3)
                                # proposed_path IT IS plausible. copy_disks was set to 'no' or endpoint set to 'remote'
                                # User has set to keep path:
                                dest_vm_img_paths_list+=($path)
                        ;;
                    esac

                    echo "Disk image path for ${vm_drives_list[$i]} set to ${dest_vm_img_paths_list[$i]}"
                done
            fi
        fi

        # Additional options to set CPU, RAM, MAC addresses, etc. can be added here:
        # -----------------------------------------------------------------------------

        if [[ -n ${src_macaddr_list[@]} ]]; then

            i=0
            for nic in ${src_macaddr_list[@]}; do

                echo ""
                echo '-------------------------------------------------------------------------------'
                echo "Options for NIC #${#src_macaddr_list[$i]} (MAC Address: ${src_macaddr_list[$i]}):"
                echo '-------------------------------------------------------------------------------'
                echo -e "1. Assign a random MAC address"
                echo -e "2. Set a custom MAC address"
                echo -e "3. Keep the same MAC address as in '$src_vm' (choose at your own risk)\n"

                choice=$(choose_number "Choose the desired action to perform" "1" "3")

                case $choice in

                    1)
                        dest_macaddr_list+=($(gen_random_macaddr))
                        echo "NIC #${#src_macaddr_list[@]} set to '${dest_macaddr_list[@]}'"
                    ;;

                    2)
                        read -p "Insert the 3 last values for the custom MAC address, separated by colons (e.g. 0f:1e:2d): " custom_mac

                        while [[ -z $(grep -E "^([0-9A-Fa-f]{2}[:]){3}$)" <<< $custom_mac) ]]; do
                            read -p "Invalid values or syntax. Insert the 3 last values for the custom MAC address: " custom_mac
                        done

                        dest_macaddr_list+=("52:54:00:${custom_mac}")
                    ;;

                    3)
                        dest_macaddr_list+=(${src_macaddr_list[$i]})
                        echo "NIC #${#src_macaddr_list[@]} will keep same address as in '$src_vm'"
                    ;;

                esac

                ((i++))
            done
        fi
        # -----------------------------------------------------------------------------
        # End of interactive part
        # -----------------------------------------------------------------------------
        # Beginning of modification on $vm_definitions_file
        # -----------------------------------------------------------------------------

        read -n1 -s -r -p $'Press any key to continue, or Ctrl+C to Cancel...\n' key

        echo -e "Processing parameters for VM '$dest_vm'..."

        # Dumps $src_vm definitions apart, and apply changes:
        # -----------------------------------------------------------------------------

        # Create the temporary folder to be used:
        mkdir -p $working_path

        # Path to xml definitions file to be processed:
        vm_definitions_file=$working_path/$dest_vm.xml

        # Dumps current VMs XML file to a temporal location:
        virsh dumpxml --inactive --security-info $src_vm > $vm_definitions_file

        # Replaces VM name ($src_vm by $dest_vm):
        # -----------------------------------------------------------------------------
        sed -i -e "s|<name>$src_vm</name>|<name>$dest_vm</name>|" $vm_definitions_file

        # Replaces VM UUID (randomized):
        # -----------------------------------------------------------------------------

        # UUID of $src_vm:
        src_uuid=$(domain_id $src_vm)

        # Random UUID to replace the original one:
        dest_uuid=$(uuidgen)

        # Replaces all matches of $src_uuid for $dest_uuid.
        # On Unraid and possibly other OSes, changes the path of persistent Nvram file, if exists:
        sed -i -e "s|$src_uuid|$dest_uuid|g" $vm_definitions_file

        # Replaces MAC addresses for (qemu/kvm) randomized ones:
        # -----------------------------------------------------------------------------

        i=0
        for mac in ${src_macaddr_list[@]}; do

            # Creates a random MAC addr for the given $src_vm MAC
            dest_macaddr_list+=($(gen_random_macaddr))

            # Replaces matching listed mac for a random one:
            sed -i -e "s|<mac address='$mac'/>|<mac address='${dest_macaddr_list[$i]}'/>|" $vm_definitions_file
            ((i++))
        done

        # When defined by the user, Replaces disk image paths:
        # -----------------------------------------------------------------------------
        i=0
        for path in ${dest_vm_img_paths_list[@]}; do

            # Replaces $src_vm paths for a $dest_vm paths:
            sed -i -e "s|<source file='${src_vm_img_paths_list[$i]}'/>|<source file='$path'/>|" $vm_definitions_file
            ((i++))
        done

        # -----------------------------------------------------------------------------
        # End of modifications on $vm_definitions_file.
        # -----------------------------------------------------------------------------
        # Beginning of file copy:
        # -----------------------------------------------------------------------------

        # When defined by the user, replicates disk images:
        # -----------------------------------------------------------------------------

        if [[ $copy_disks == yes ]]; then

            if [[ $(domain_state $src_vm) != "shut off" ]]; then

                # Mark $src_vm  to be turned on after the copy:
                src_vm_was_on=1

                # Shuts down $src_vm
                domain_shutdown $src_vm

                # Gets the status of the operation:
                shutdown_status=$?
            else
                shutdown_status=0
            fi

            if [[ $shutdown_status -eq 0 ]]; then

                i=0
                for image_path in ${dest_vm_img_paths_list[@]}; do

                    # Copies the image disk only when conditions apply:
                    echo "Replicating '${src_vm_img_paths_list[$i]}' as '$image_path' on $endpoint endpoint..."

                    if [[ $endpoint == local ]]; then

                        # Creates folder and dumps a copy of the disk image with qemu-img convert:
                        mkdir -p $(dirname $image_path)
                        qemu-img convert -p -O qcow2 ${src_vm_img_paths_list[$i]} $image_path
                        image_path_status=$?

                    elif [[ $endpoint == remote ]]; then

                        # Creates remote folder and creates local mountpoint:
                        mkdir -p $working_path/remote
                        ssh $SSH_OPTIONS $remote_server "mkdir -p $(dirname $image_path)"

                        # And mounts the remote folder and dumps with qemu-img convert directly.
                        # (sshfs is not compatible with option '-q', so must be filtered from SSH_OPTIONS):
                        sshfs $remote_server:$(dirname $image_path) $working_path/remote ${SSH_OPTIONS/-q /}

                        if [[ $? -eq 0 ]]; then

                            # Will only replicate the disk if mount of remote endpoint is successful:
                            qemu-img convert -p -O qcow2 ${src_vm_img_paths_list[$i]} $working_path/remote/$(basename $image_path)
                            image_path_status=$?

                            # Unmounts the remote folder after completion:
                            umount $working_path/remote
                        else
                            echo "ERROR: Cannot mount the remote folder on host '$remote_server_name' to replicate '$(basename $image_path)'. Skipped"
                        fi
                    fi

                    # Notifies about success or fail of each disk image provisioning for $dest_vm:
                    [[ $image_path_status -eq 0 ]] && echo "$image_path provisioned successfully" || echo "ERROR: Failed provisioning $image_path."

                    ((i++))
                done
            else
                echo "ERROR: VM '$src_vm' could not be properly powered off. Aborting disk image provisioning"
            fi

            if [ ! -z $src_vm_was_on ]; then

                # Starts $src_vm if it was previously running before the copy:
                echo "Powering on $src_vm..."
                domain_start $src_vm --nowait
            fi
        fi

        # Tries to get an nvram file path of the VM that will be replicated:
        src_vm_nvram_path=$(domain_nvram_path $src_vm)

        if [ ! -z $src_vm_nvram_path ]; then

            # Source VM requires nvram file to work, therefore it has to be provisioned:
            echo "Persistent Nvram file detected. Attempting provisioning..."

            # Get nvram file path of the VM that will be replicated (from its xml definition file)
            # On Unraid, file name will change with uuid replacement on new XML definitions file made in previous step
            # (Other OSes might behave in similar way, but this has not been tested):
            dest_vm_nvram_path=$(domain_nvram_path $vm_definitions_file)

            if [[ $endpoint == local ]]; then

                if [[ $src_vm_nvram_path != $dest_vm_nvram_path ]]; then

                    # When endpoint is local and both nvram file paths differ, copy the source nvram file with the new destination name:
                    cp -f $src_vm_nvram_path $dest_vm_nvram_path
                    nvram_copy_status=$?
                fi

            elif [[ $endpoint == remote ]]; then

                    # Create directory (in case also doesn't exists) and if success, copy source nvram as dest nvram:
                    ssh $SSH_OPTIONS $remote_server "mkdir -p $(dirname $dest_vm_nvram_path)" && \
                    scp $SSH_OPTIONS $src_vm_nvram_path $remote_server:$dest_vm_nvram_path
                    nvram_copy_status=$?
            fi

            case $nvram_copy_status in

                # As no status is given, logic assumes files are identical and no copy was made:
                '') echo "Source and destination Nvram file paths are identical in $endpoint endpoint ($src_vm_nvram_path) so nothing was copied"
                ;;

                # Local or remote copy was successful:
                0) echo "Persistent Nvram file successfully provisioned to $endpoint endpoint as $dest_vm_nvram_path"
                ;;

                # There were errors copying nvram file:
                *) echo "WARNING: Nvram file provisioning failed! You need to source this file manually (and possibly edit $dest_vm config) in order to make it run (status: $nvram_copy_status)"
                ;;
            esac
        fi

        # Finally, defines the VM in QEMU/KVM and cleanses temporal files:
        # -----------------------------------------------------------------------------

         if [[ $endpoint == local ]]; then

            # When local, defines VM directly:
            &> /dev/null virsh define $vm_definitions_file
            vm_define_status=$?

         elif [[ $endpoint == remote ]]; then

            # When remote, transfers $vm_definitions_file to the host, defines it and fetches the state of the operation:
            remote_vm_definitions_file="/tmp/$(basename $vm_definitions_file)"
            scp $SSH_OPTIONS $vm_definitions_file $remote_server:$remote_vm_definitions_file
            ssh $SSH_OPTIONS $remote_server "&> /dev/null virsh define $remote_vm_definitions_file"
            vm_define_status=$?

            # And then deletes the transferred file:
            ssh $SSH_OPTIONS $remote_server "rm -f $remote_vm_definitions_file"
        fi

        if [[ $vm_define_status -eq 0 ]]; then

            echo ""
            echo "VM $dest_vm replicated at $endpoint endpoint successfully!"
            rm -rf $working_path
            status=0
        else
            echo "ERROR: Could not define VM $dest_vm to QEMU/KVM. Check $working_path in order to see what could be wrong"
        fi

    else
        echo "ERROR: No persistent Virtual Machines detected! (is libvirt service running?)"
    fi
else

    # Argument(s) detected. By now, only shows the help and exits:
    show_info

    echo "Run this script without arguments to start the interactive mode. Exited."
    status=0
fi

exit $status
