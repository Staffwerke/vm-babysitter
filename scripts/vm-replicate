#!/bin/bash

# Variables:
# -----------------------------------------------------------------------------
# Temporal path to store files (as .xml):
working_path="/tmp/.$(basename $0).tmp"

# Location of the script where all functions and global variables to be used are declared:
# (Here, on the same dir
functions_path="/usr/local/bin/vm-functions"

# Name of the local host:
localhost=$(cat /etc/hostname)
show_info()
{
cat << end_of_info

 $(basename $0) -- Replicates a given virtual machine onto a local or remote endpoint

 REQUIREMENTS:
    - libvirt service running (in all involved hosts)
    - qemu-img (this host)
    - ssh, scp and sshfs (this host)
    - ssh server (remote host)
    - Both hosts must be set with proper RSA/DSA keys authentication, in ways this host can connect with the other directly.

 INSTRUCTIONS:
    - A series of options and questions will be presented, and must be answered
    - You will be asked for confirmation before to start the process
    - Once completed, it will display the final result about the operation.

(Maintainer: AdriÃ¡n Parilli <a.parilli@staffwerke.de>)
end_of_info
}

# -----------------------------------------------------------------------------
# Main execution:
# -----------------------------------------------------------------------------

# Load functions:
source $functions_path

status=1
if [ -z $@ ]; then

    # -----------------------------------------------------------------------------
    # Beginning of interactive part:
    # -----------------------------------------------------------------------------

    # No input parameters enables the interctive mode:
    show_info
    read -n1 -s -r -p $'Press any key to continue, or Ctrl+C to Cancel...\n' key

    vms_list=($(domains_list))

    if [ $? == 0 ] && [[ ${#vms_list[@]} -ge 1 ]]; then

        # Only proceeds either if libvirt doesn't report an error, and if there are non-trasient VMs:
        echo ""
        echo "Scanning for Virtual Machines..."
        echo ""
        echo "${#vms_list[@]} VMs found in host '$localhost':"
        echo '-------------------------------------------------------------------------------'
        printf " %s \t %-15s \t %s \n" "#" "VM Name" "Drives"
        echo '-------------------------------------------------------------------------------'

        i=0
        for vm in "${vms_list[@]}"; do

            # Gets a list with drives in each VM that can b e restored:
            vm_drives_list+=("$(domain_drives_list $vm)")

            # Shows each VM found, including the restorable drives:
            printf " %s \t %-15s \t %s \n" "$(( $i + 1))" "$vm" "${vm_drives_list[$i]}"
            ((i++))
        done

        # Asks the user to choose a VM to clone:
        # -----------------------------------------------------------------------------
        echo ""
        choice=$(choose_number "Choose the Virtual Machine to be replicated" "1" "${#vms_list[@]}")

        # Saves VM specs that will be used for restoration:
        src_vm="${vms_list[(( $choice - 1 ))]}"
        src_vm_img_paths_list=($(domain_img_paths_list $src_vm))
        vm_drives_list=(${vm_drives_list[(( $choice - 1 ))]})

        echo "VM '$src_vm' selected for being replicated"

        # Asks the user to replicate onto local, or remote VM:
        # -----------------------------------------------------------------------------
        while true; do

            echo ""
            echo '-------------------------------------------------------------------------------'
            echo "Endpoint selection to replicate '$src_vm'"
            echo '-------------------------------------------------------------------------------'
            echo "1. At localhost ($localhost)"
            echo "2. At a remote host (via SSH)"
            echo ""
            choice=$(choose_number "Choose an option number for endpoint" "1" "2" "1")

            case $choice in

                1)
                    endpoint="local"
                    echo "Destination endpoint set to '$localhost'"
                    break
                ;;
                2)
                    endpoint="remote"
                    while true; do

                        read -p "Insert user name and server's FQDN/IP where $src_vm will be replicated (e.g. user@hostname): " remote_server

                        if [[ $remote_server == *@* ]]; then

                            # Grabs remote user and server separately:
                            remote_server_name=$(echo $remote_server | cut -d'@' -f2)

                            # Test remote host connectivity and libvirt:
                            ssh $SSH_OPTIONS $remote_server "exit 0"
                            remote_server_status=$?

                            if [ $remote_server_status == 0 ]; then

                                # Server returns the command status sent. Looks up for libvirt API:
                                remote_api_version=$(ssh $SSH_OPTIONS $remote_server 'echo $(virsh --version)')
                                remote_api_status=$?

                                if [ $remote_api_status == 0 ]; then

                                    echo ""
                                    echo "Destination endpoint set to '$remote_server_name' (libvirt $remote_api_version)"

                                    # Gets the list of VMs from $remote_server to discard duplicates on the remote endpoint:
                                    vms_list=($(ssh $SSH_OPTIONS $remote_server "virsh list --all --persistent --name"))

                                    # Breaks both loops:
                                    break 2
                                else
                                    echo "ERROR: Cannot connect with libvirt service at endpoint '$remote_server_name' (failed with status $remote_api_status)"
                                fi
                            else
                                echo "ERROR: Cannot connect with endpoint '$remote_server_name' port $remote_port (failed with status $remote_server_status)"
                            fi
                        else
                            echo "ERROR: '$remote_server' has a bad syntax"
                        fi
                    done
                ;;
            esac
        done

        # Asks the user for a name to be used for the New VM:
        # -----------------------------------------------------------------------------
        echo ""
        read -p "Choose a name for the new VM: " dest_vm

        while true; do

            vm_already_exists=""
            for vm in ${vms_list[@]}; do

                [[ $dest_vm == $vm ]] && { vm_already_exists=1; break; }
            done

            [ ! -z $vm_already_exists ] && read -p "VM '$dest_vm' already exists on $endpoint endpoint. You must choose a different name: " dest_vm || break
        done

        if [ ! -z ${vm_drives_list[@]} ]; then

            # Asks the user for copying disks from $src_vm for $dest_vm
            # -----------------------------------------------------------------------------
            copy_disks=$(yes_no "Do you also want to replicate the following disk image(s): [${vm_drives_list[@]// /,}] from '$src_vm' into '$dest_vm'?" "yes")
            case $copy_disks in

                yes)
                    echo "Disk images will be provisioned"

                    # Looks for the VM state and notifies about a sudden shutdown (necessary to perform disk clonning:
                    src_vm_state=$(domain_state $src_vm)
                    [[  $src_vm_state != "shut off" ]] && echo "WARNING: VM '$src_vm' is currently $src_vm_state. It will be temporarily SHUT DOWN during the process."
                ;;

                no)
                    echo "No disk images will be provisioned (you must provide them manually)"

                    # Asks the user for checking / modifying paths:
                    # -----------------------------------------------------------------------------
                    check_paths=$(yes_no "Do you still want to check (and possibly redefine) image disk paths for VM '$dest_vm'?" "yes")
            esac

            if [[ $copy_disks == yes ]] || [[ $check_paths == yes ]]; then

                # When disk images are to be copied, or the user wants to check / redefine new paths for $dest_vm

                # Shows the possible options and ways to modify them:
                # -----------------------------------------------------------------------------
                i=0
                for path in ${src_vm_img_paths_list[@]}; do

                    auto_path=""
                    # Number of options present in the below dialog:
                    menu_option=1
                    echo ""
                    echo '-------------------------------------------------------------------------------'
                    echo "Options for disk ${vm_drives_list[$i]} (source: $path) "
                    echo '-------------------------------------------------------------------------------'
                    echo ""
                    echo "$menu_option. Set the disk image path to a custom location and name"

                    # Attempts to find a NEW path matching by VM name:
                    proposed_path=${path//$src_vm/$dest_vm}

                    if [[ $path != $proposed_path ]]; then

                        # If this action is possible, proposes it as an option:
                        auto_path=1
                        ((menu_option++))
                        echo "$menu_option. Set the disk image path automatically to: $proposed_path"
                    fi

                    if [[ $copy_disks == no ]] || [[ $endpoint == remote ]]; then

                        # Only when user has chosen to not copy disks or the VM will be replicated on another host, it shows the 3rd option:
                        ((menu_option++))
                        echo "$menu_option. Keep the disk image path unchanged: $path"
                    fi

                    echo ""
                    choice=$(choose_number "Choose the action you want to perform" "1" "$menu_option")

                    case $choice in

                        1)
                            # User has chosen to set path manually:
                            echo ""
                            while true; do

                                read -p "Insert the full path to the disk image (e.g. /full/path/to/$dest_vm.img): " manual_path

                                for path in ${dest_vm_img_paths_list[@]}; do

                                    path_already_exists=""
                                    # Checks if path was already defined for another disk (in the same VM):
                                    [[ $manual_path == $path ]] && { path_already_exists=1; break; }
                                done

                                message=""
                                if [ ! -z $path_already_exists ]; then

                                    message="'$manual_path' was already defined for VM '$dest_vm' and cannot be used twice"
                                elif [[ $manual_path != /* ]]; then

                                    message="'$manual_path' is not an absolute path"
                                else

                                    dest_vm_img_paths_list+=($manual_path)
                                    break
                                fi
                            done
                        ;;
                        2)
                            if [ ! -z $auto_path ]; then

                                # $proposed_path is plausible and has been chosen:
                                dest_vm_img_paths_list+=($proposed_path)

                            elif [[ $copy_disks == yes ]] || [[ $endpoint == remote ]]; then

                                # $proposed_path IS NOT plausible. $copy_disks was set to 'no' or $endpoint set to 'remote'
                                # User has set to keep path:
                                dest_vm_img_paths_list+=($path)
                            fi
                        ;;
                        3)
                                # $proposed_path IT IS plausible. $copy_disks was set to 'no' or $endpoint set to 'remote'
                                # User has set to keep path:
                                dest_vm_img_paths_list+=($path)
                        ;;
                    esac

                    echo "Disk image path for ${vm_drives_list[$i]} set to ${dest_vm_img_paths_list[$i]}"
                done
            fi
        else
            echo "VM '$src_vm' has no writable disks that can be replicated"
        fi

# ADD MEMORY/MAC ADDR CHANGES HERE:

# -----------------------------------------------------------------------------
        # End of interactive part
        # -----------------------------------------------------------------------------
        # Beginning of modification on $vm_definitions_file
        # -----------------------------------------------------------------------------

        echo "Processing parameters for VM '$dest_vm'..."

        # Dumps $src_vm definitions apart, and apply changes:
        # -----------------------------------------------------------------------------

        # Create the temporary folder to be used:
        mkdir -p $working_path

        # Path to xml definitions file to be processed:
        vm_definitions_file=$working_path/$dest_vm.xml

        # Dumps current VMs XML file to a temporal location:
        virsh dumpxml --inactive --security-info $src_vm > $vm_definitions_file

        # Replaces VM name ($src_vm by $dest_vm):
        # -----------------------------------------------------------------------------
        sed -i -e "s|<name>$src_vm</name>|<name>$dest_vm</name>|" $vm_definitions_file

        # Replaces VM UUID (randomized):
        # -----------------------------------------------------------------------------

        # UUID of $src_vm:
        src_uuid=$(domain_id $src_vm)

        # Random UUID to replace the original one:
        dest_uuid=$(uuidgen)

        # Replaces all matches of $src_uuid for $dest_uuid.
        # On Unraid and possibly other OSes, changes the path of persistent Nvram file, if exists:
        sed -i -e "s|$src_uuid|$dest_uuid|g" $vm_definitions_file

        # Replaces MAC addresses for (qemu/kvm) randomized ones:
        # -----------------------------------------------------------------------------

        # Gets the original list of MAC addresses from $src_vm:
        src_macaddr_list=($(domain_macaddr_list $src_vm))

        i=0
        for mac in ${src_macaddr_list[@]}; do

            # Creates a random MAC addr for the given $src_vm MAC
            dest_macaddr_list+=($(gen_random_macaddr))

            # Replaces matching listed mac for a random one:
            sed -i -e "s|<mac address='$mac'/>|<mac address='${dest_macaddr_list[$i]}'/>|" $vm_definitions_file
            ((i++))
        done

        # When defined by the user, Replaces disk image paths:
        # -----------------------------------------------------------------------------
        i=0
        for path in ${dest_vm_img_paths_list[@]}; do

            # Replaces $src_vm paths for a $dest_vm paths:
            sed -i -e "s|<source file='${src_vm_img_paths_list[$i]}'/>|<source file='$path'/>|" $vm_definitions_file
            ((i++))
        done

        # -----------------------------------------------------------------------------
        # End of modifications on $vm_definitions_file.
        # -----------------------------------------------------------------------------
        # Beginning of file copy:
        # -----------------------------------------------------------------------------

        # When defined by the user, replicates disk images:
        # -----------------------------------------------------------------------------

        if [[ $copy_disks == yes ]]; then

            if [[ $(domain_state $src_vm) != "shut off" ]]; then

                # Mark $src_vm  to be turned on after the copy:
                src_vm_was_on=1

                # Shuts down $src_vm
                domain_shutdown $src_vm

                # Gets the status of the operation:
                shutdown_status=$?
            else
                shutdown_status=0
            fi

            if [[ $shutdown_status -eq 0 ]]; then

                i=0
                for image_path in ${dest_vm_img_paths_list[@]}; do

                    # Copies the image disk only when conditions apply:
                    echo "Replicating '${src_vm_img_paths_list[$i]}' as '$image_path' on $endpoint endpoint..."

                    if [[ $endpoint == local ]]; then

                        # Creates folder and dumps a copy of the disk image with qemu-img convert:
                        mkdir -p $(dirname $image_path)
                        qemu-img convert -p -O qcow2 ${src_vm_img_paths_list[$i]} $image_path
                        image_path_status=$?

                    elif [[ $endpoint == remote ]]; then

                        # Creates remote folder and creates local mountpoint:
                        mkdir -p $working_path/remote
                        ssh $SSH_OPTIONS $remote_server "mkdir -p $(dirname $image_path)"

                        # And mounts the remote folder and dumps with qemu-img convert directly.
                        # (sshfs is not compatible with option '-q', so must be filtered from SSH_OPTIONS):
                        sshfs $remote_server:$(dirname $image_path) $working_path/remote ${SSH_OPTIONS/-q /}

                        if [[ $? -eq 0 ]]; then

                            # Will only replicate the disk if mount of remote endpoint is successful:
                            qemu-img convert -p -O qcow2 ${src_vm_img_paths_list[$i]} $working_path/remote/$(basename $image_path)
                            image_path_status=$?

                            # Unmounts the remote folder after completion:
                            umount $working_path/remote
                        else
                            echo "ERROR: Cannot mount the remote folder on host '$remote_server_name' to replicate '$(basename $image_path)'. Skipped"
                        fi
                    fi

                    # Notifies about success or fail of each disk image provisioning for $dest_vm:
                    [[ $image_path_status -eq 0 ]] && echo "$image_path provisioned successfully" || echo "ERROR: Failed provisioning $image_path."

                    ((i++))
                done
            else
                echo "ERROR: VM '$src_vm' could not be properly powered off. Aborting disk image provisioning"
            fi

            if [ ! -z $src_vm_was_on ]; then

                # Starts $src_vm if it was previously running before the copy:
                echo "Powering on $src_vm..."
                domain_start $src_vm --nowait
            fi
        fi

        # Tries to get an nvram file path of the VM that will be replicated:
        src_vm_nvram_path=$(domain_nvram_path $src_vm)

        if [ ! -z $src_vm_nvram_path ]; then

            # Source VM requires nvram file to work, therefore it has to be provisioned:
            echo "Persistent Nvram file detected. Attempting provisioning..."

            # Get nvram file path of the VM that will be replicated (from its xml definition file)
            # On Unraid, file name will change with uuid replacement on new XML definitions file made in previous step
            # (Other OSes might behave in similar way, but this has not been tested):
            dest_vm_nvram_path=$(domain_nvram_path $vm_definitions_file)

            if [[ $endpoint == local ]]; then

                if [[ $src_vm_nvram_path != $dest_vm_nvram_path ]]; then

                    # When endpoint is local and both nvram file paths differ, copy the source nvram file with the new destination name:
                    cp -f $src_vm_nvram_path $dest_vm_nvram_path
                    nvram_copy_status=$?
                fi

            elif [[ $endpoint == remote ]]; then

                # Checks if nvram device, as currently defined in dest VM, exists in remote endpoint, returning an answer:
                remote_nvram_exists=$(ssh $SSH_OPTIONS $remote_server "[[ -f $dest_vm_nvram_path ]] && echo yes || echo no")

                if [[ $remote_nvram_exists == no ]]; then

                    # Remote nvram device doesn't exist in remote endpoint.
                    # Create directory (in case also doesn't exists) and copy source nvram as dest nvram:
                    ssh $SSH_OPTIONS $remote_server "mkdir -p $(dirname $dest_vm_nvram_path)" && \
                    scp $SSH_OPTIONS $src_vm_nvram_path $remote_server:$dest_vm_nvram_path
                    nvram_copy_status=$?
                fi
            fi

            case $nvram_copy_status in

                # As no status is given, logic assumes files are identical and no copy was made:
                '') echo "Source and destination Nvram file paths are identical in $endpoint endpoint ($src_vm_nvram_path) so nothing was copied"
                ;;

                # Local or remote copy was successful:
                0) echo "Persistent Nvram file successfully provisioned to $endpoint endpoint as $dest_vm_nvram_path"
                ;;

                # There were errors copying nvram file:
                *) echo "WARNING: Nvram file provisioning failed! You need to source this file manually (and possibly edit $dest_vm config) in order to make it run (status: $nvram_copy_status)"
                ;;
            esac
        fi

        # Finally, defines the VM in QEMU/KVM and cleanses temporal files:
        # -----------------------------------------------------------------------------

         if [[ $endpoint == local ]]; then

            # When local, defines VM directly:
            &> /dev/null virsh define $vm_definitions_file
            vm_define_status=$?

         elif [[ $endpoint == remote ]]; then

            # When remote, transfers $vm_definitions_file to the host, defines it and fetches the state of the operation:
            remote_vm_definitions_file="/tmp/$(basename $vm_definitions_file)"
            scp $SSH_OPTIONS $vm_definitions_file $remote_server:$remote_vm_definitions_file
            ssh $SSH_OPTIONS $remote_server "&> /dev/null virsh define $remote_vm_definitions_file"
            vm_define_status=$?

            # And then deletes the transferred file:
            ssh $SSH_OPTIONS $remote_server "rm -f $remote_vm_definitions_file"
        fi

        if [[ $vm_define_status -eq 0 ]]; then

            echo ""
            echo "VM $dest_vm replicated at $endpoint endpoint successfully!"
            rm -rf $working_path
            status=0
        else
            echo "ERROR: Could not define VM $dest_vm to QEMU/KVM. Check $working_path in order to see what could be wrong"
        fi

    else
        echo "ERROR: No persistent Virtual Machines detected! (is libvirt service running?)"
    fi
else

    # Argument(s) detected. By now, only shows the help and exits:
    show_info

    echo "Run this script without arguments to start the interactive mode. Exited."
    status=0
fi

exit $status
