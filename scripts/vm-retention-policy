#!/bin/bash

# Usage: vm-retention-policy [--force] [domain1 domain2...]
# - Checks backups lifecyle based on MAX_BACKUPS_PER_CHAIN, triggering its archiving when reaches that number of checkpoints
# - Applies retention policy, based on LOCAL|RSYNC_BACKUP_CHAINS_TO_KEEP, keeping as many (and most recent) backup chains on each endpoint, deleting the older ones.
# - When '--force'is passed as the first argument, overrides MAX_BACKUPS_PER_CHAIN and triggers its immediate archiving.

# Load common functions:
source $functions_path

if [[ $1 == "--force" ]]; then

    # Force the end of lifecycle:
    retention_mode="Forced"
    shift

elif [[ -n $MAX_BACKUPS_PER_CHAIN && $MAX_BACKUPS_PER_CHAIN -gt 0 ]]; then

    # Run normal checks and apply retention policy:
    retention_mode="Normal"
fi

# Processes initial backups list from VMs (passed as arguments):
retention_list=($@)

if [[ -n ${retention_list[@]} ]]; then

    for domain in ${retention_list[@]}; do

        # (Re)Initialize used variables:
        local_backup_not_found=""
        end_of_lifecycle=""

        # Display screen divider when processing several backup chains:
        [[ ${#retention_list[@]} -gt 1 ]] \
            && echo "____________________________________________________________________________________________________________"

        echo "$domain: Checking/applying data retention policy..."

        if [[ -d $LOCAL_BACKUP_PATH/$domain && -n $(ls -A $LOCAL_BACKUP_PATH/$domain) ]]; then

            # Backup path exists and is not empty. Proceed with check:
            # Retention policy is set (at least, partially) by the user. Retrieve the number of existing checkpoints in the backup chain:
            num_of_backup_checkpoints=$(backup_checkpoint_list $LOCAL_BACKUP_PATH/$domain --num)

            case $retention_mode in

                Normal)

                    case $num_of_backup_checkpoints in

                        0)  # '0' checkpoints means it's a 'copy' backup:

                            end_of_lifecycle=1
                            echo "$domain: Current backup was made in 'copy' mode and cannot be used for incremental backups"
                        ;;

                        *)  # Any other positive integer number it's the current number of checkpoints present into the backup chain.

                            # Check if it has reached the maximum allowed:
                            if [[ $num_of_backup_checkpoints -ge $MAX_BACKUPS_PER_CHAIN ]]; then

                                # Backup has reached the max allowed checkpoints and must be archived:
                                end_of_lifecycle=1
                            fi

                            echo "$domain: Detected $num_of_backup_checkpoints of max allowed $MAX_BACKUPS_PER_CHAIN checkpoints"
                        ;;
                    esac
                ;;

                Forced) # No checks will be performed:

                    echo "$domain: Current backup chain will be forcibly archived ($num_of_backup_checkpoints of max allowed $MAX_BACKUPS_PER_CHAIN checkpoints)"
                    end_of_lifecycle=1
                ;;

                *)  # MAX_BACKUPS_PER_CHAIN is not set, or value is 0:

                    echo "$domain: Data retention policy is currently disabled by user ($num_of_backup_checkpoints checkpoints)"
                ;;
            esac

            if [[ $end_of_lifecycle ]]; then

                # Process local backup chain if it has reached its lifecycle (for whatever reason)
                archive_backup $LOCAL_BACKUP_PATH/$domain $LOCAL_BACKUP_CHAINS_TO_KEEP
            fi

        else
            echo "$domain: There is no current backup at $LOCAL_BACKUP_PATH in order to check/apply data retention policy"

            # Mark local backup as 'not found' (to perform tasks below):
            local_backup_not_found=1
        fi

        if [[ -n $RSYNC_BACKUP_PATH ]] && [[ $end_of_lifecycle || $local_backup_not_found ]]; then

            # Process rsync mirror, discerning if located at local or remote (SSH) path:
            [[ $RSYNC_BACKUP_PATH == *@*:/* ]] && archive_command="archive_remote_backup" || archive_command="archive_backup"

            # Also discerning if local backup was not found in first instance,
            # in which case any remote mirror that exists will be archived, but no retention policy applied with old backup chains:
            [[ $local_backup_not_found ]] && rsync_retention=$RSYNC_BACKUP_CHAINS_TO_KEEP || rsync_retention=""

            # In order to archive and apply (or not) retention policy on the mirror:
            $archive_command $RSYNC_BACKUP_PATH/$domain $rsync_retention
        fi
    done

    # When multiple backups chains were processed, display that the script has finished:
    [[ ${#retention_list[@]} -gt 1 ]] \
        && echo "$(basename $0): Finished"

else
    echo "At least one Virtual machine needs to be passed as argument in order to check/apply data retention policy (exited)"
fi
