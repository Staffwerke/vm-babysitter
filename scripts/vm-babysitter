#!/bin/bash

###############################################################################
# Main variables:
###############################################################################

# Internal mount point for main backups folder:
BACKUPS_MAIN_PATH=${BACKUPS_MAIN_PATH:-"/backups"}

# Temporal crontab file (to be loaded for cron)
crontab_file="/tmp/crontab"

# Storing file for bash like lists shared between this script and the scheduler:
external_vars="/tmp/vm-babysit-vars"

# Main library where common functions and some variables are loaded:
functions_path="/usr/local/bin/vm-functions"

# Log file path for this script:
MAIN_LOGPATH=${MAIN_LOGPATH:-"/logs/vm-babysitter.log"}

# Path of the scheduler script (run by cron):
scheduled_backup_script="/usr/local/bin/update_backup_chain"

# Log file path for the scheduler script:
SCHEDULED_LOGPATH=${SCHEDULED_LOGPATH:-"/logs/scheduled-backups.log"}

# Location of current Time Zone (if defined in ENV TZ):
[[ -f /usr/share/zoneinfo/$TZ ]] && local_timezone_file="/usr/share/zoneinfo/$TZ"

###############################################################################
# Specific procedures:
###############################################################################

#------------------------------------------------------------------------------
# Attempts to stop the container gracefully in case of receive SIGTERM signal from Docker:
#------------------------------------------------------------------------------
stop_container()
{
    echo "############################################################################################################"
    echo "SIGTERM signal received at: $(date "+%Y-%m-%d %H:%M:%S")"
    # To DO: Terminate or kill background processes before to exit.
    echo "Container Stopped."
    echo ""
    exit 0
}

#------------------------------------------------------------------------------
# Check if VMs in CHECK_PATCH_LIST are patched for incremental backups (and applies it when possible):
#------------------------------------------------------------------------------
check_patch()
{
    # Lists to add VMs (and summarize at the end):
    local domain_shutdown_success
    local domain_shutdown_failed
    local vm_patch_success
    local vm_patch_failed

    echo ""
    echo "____________________________________________________________________________________________________________"
    echo "Checking for incremental backup patch on Virtual machines: ${CHECK_PATCH_LIST[@]}"

    local i=0
    for domain in ${CHECK_PATCH_LIST[@]}; do

        # For each VM, the loop repeats itself as needed until a VM has been successfully patched, or not:
        echo ""

        while true; do

            if [[ -z ${domain_shutdown_failed[$i]} ]] && [[ -z ${vm_patch_failed[$i]} ]]; then

                if [[ $(domain_is_patched $domain ) == yes ]]; then

                    echo "$domain: Incremental backup patch is OK"
                    vm_patch_success[$i]+=$domain
                    break

                elif [[ $(domain_is_patched $domain --inactive) == yes ]]; then

                    # VM is (presumably) running and was patched before (e.g. in past iteration inside this loop)
                    echo "$domain: Incremental backup patch is present, but a power cycle is required to apply changes"

                    if [[ ! -z $RESTART_VMS_IF_REQUIRED ]]; then

                        # When permission is granted, and past iteration over the VM haven't triggered errors, attempts shuts down the VM temporarily:
                        domain_shutdown $domain --wait $WAIT_TIME

                        if [[ $? -eq 0 ]]; then

                            # Adds VM to shutdown success local list:
                            domain_shutdown_success[$i]+=$domain
                        else

                            # Adds VM to failed to shutdown local list
                            # (This VM might shutdown eventually):
                            domain_shutdown_failed[$i]=$domain
                        fi
                    else

                        # Adds VM to failed to shutdown local list
                        # (User must shutdown the VM manually):
                        domain_shutdown_failed[$i]=$domain
                    fi

                    # Restarts the loop (checks VM again under changed conditions):
                    continue

                else

                    echo "$domain: Incremental backup patch not found. Attempting to patch..."

                    vm-patch $domain --quiet

                    # IF fails, add VM to failed to patch local list:
                    [[ $? -eq 0 ]] && echo "$domain: Successfully patched!" ||  { vm_patch_failed[$i]=$domain; echo "$domain: Failed!"; }

                    # Restarts the loop (checks VM again under changed condition):
                    continue
                fi
            else

                # Failed either shutting down or applying the patch
                # Nothing else possible to do:
                break
            fi
        done

        # Removes VM from CHECK_PATCH_LIST:
        unset CHECK_PATCH_LIST[$i]

        # Increases the index to check the next VM:
        ((i++))
    done

    # Writes updated CHECK_PATCH_LIST value (actually, should be empty)
    # as a string, since sed can't expand arrays correctly:
    CHECK_PATCH_LIST="${CHECK_PATCH_LIST[@]}"

    # And updates it externally:
    sed -i \
    -e "s/CHECK_PATCH_LIST=.*/CHECK_PATCH_LIST=($CHECK_PATCH_LIST)/" \
    $external_vars

    # Turn again stringified variables back into lists:
    CHECK_PATCH_LIST=($CHECK_PATCH_LIST)

    # Appends sub-list of (successfully) patched VMs to global CHECK_BACKUPS_LIST:
    CHECK_BACKUPS_LIST+=(${vm_patch_success[@]})

    # Appends sub-list to the global list of powered OFF VMs:
    POWEREDOFF_VMS_LIST+=(${domain_shutdown_success[@]})

    # Appends sub list of VMs that failed to shutdoen to global SHUTDOWN_REQUIRED_VMS_LIST:
    SHUTDOWN_REQUIRED_VMS_LIST+=(${domain_shutdown_failed[@]})

    # Appends sub list of failed VMs:
    FAILED_VMS_LIST+=(${domain_shutdown_failed[@]})

    echo ""
    echo "Incremental Backup Patch Summary:"
    echo ""
    echo "Patched for backups:          ${vm_patch_success[@]:-"None"}"
    [[ ! -z $RESTART_VMS_IF_REQUIRED ]] && \
    echo "Into automatic power cycle:   ${domain_shutdown_success[@]:-"None"}" || \
    echo "Manual shut down is required: ${domain_shutdown_failed[@]:-"None"}"
    echo "Could not apply patch:        ${vm_patch_failed[@]:-"None"}"

    if [[ -z ${domain_shutdown_failed[@]} ]] && [[ -z ${vm_patch_failed[@]} ]]; then

        echo ""
        echo "All VMs patched successfuly!"
    fi
}

#------------------------------------------------------------------------------
# Checks VMs in CHECK_BACKUPS_LIST for backup chain integrity (and puts VMs at point of create new backup chains, if possible):
#------------------------------------------------------------------------------
check_backups()
{
    # Local variables used for flow control:
    local backup_check_failed
    local backup_folder_integrity
    local bitmaps_list
    local checkpoint_list
    local recoverable_backup_chain

    # Lists to add VMs (and summarize at the end):
    local broken_backup_chain
    local domain_shutdown_failed
    local domain_shutdown_success
    local preserved_backup_chain

    echo ""
    echo "____________________________________________________________________________________________________________"
    echo "Checking backup chain ingtegrity on Virtual machines: ${CHECK_BACKUPS_LIST[@]}"

    local i=0
    for domain in ${CHECK_BACKUPS_LIST[@]}; do

        backup_check_failed=""
        backup_folder_integrity=""
        checkpoint_list=()
        recoverable_backup_chain=""

        echo ""

        while true; do

            # Checks once for non existing, corrupted or dummy backup folders and partial checkpoints:
            #------------------------------------------------------------------------------
            if [[ -z $backup_folder_integrity ]] || [[ -z $recoverable_backup_chain ]]; then

                if [[ ! -d $BACKUPS_MAIN_PATH/$domain ]] \
                || [[ ! -f $BACKUPS_MAIN_PATH/$domain/$domain.cpt ]] \
                || [[ ! -d $BACKUPS_MAIN_PATH/$domain/checkpoints ]]; then

                    backup_folder_integrity="false"
                    echo "$domain: No backup chain folder detected, or internal structure is inconsistent"

                elif [[ ! -z $(find $BACKUPS_MAIN_PATH/$domain -type f -name "*.partial") ]]; then

                    local damaged_backup_checkpoint_list=($(backup_checkpoint_list $BACKUPS_MAIN_PATH/$domain))

                    if [[ ${#damaged_backup_checkpoint_list[@]} -eq 1 ]]; then

                        backup_folder_integrity="false"
                        echo "$domain: A full backup operation was previously cancelled. This backup chain is unrecoverable, therefore will be removed"

                    elif [[ $RESTARTED_SERVER == true ]]; then

                        recoverable_backup_chain="false"
                        echo "$domain: An incremental backup operation was previously cancelled and RESTARTED_SERVER mode is active, not leaving chances to repair it. A new backup chain will be created"

                    elif [[ -z $RESTART_VMS_IF_REQUIRED ]]; then

                        recoverable_backup_chain="false"
                        echo "$domain: An incremental backup operation was previously cancelled and environment variable RESTART_VMS_IF_REQUIRED is not set (cannot attempt to repair). A new backup chain will be created"

                    else

                        recoverable_backup_chain="true"
                        echo "$domain: An incremental backup operation was previously cancelled. It will attempt to fix the current backup chain by deleting the (now useless) data that was being saved right before the cancellation, and deleting the checkpoint from this VM (a full Power Cycle will be performed after repair to apply all the changes)"
                    fi

                else

                    # Everything looks OK:
                    backup_folder_integrity="true"
                fi
            fi

            # Checks once if RESTARTED_SERVER is true, VM is running and RESTART_VMS_IF_REQUIRED is set
            # (Will fail if can't shut down the VM):
            #------------------------------------------------------------------------------
            if [[ $RESTARTED_SERVER == true ]] && [[ $(domain_state $domain) == running ]]; then

                if [[ ! -z $RESTART_VMS_IF_REQUIRED ]]; then

                    # Attempts to shut down the VM temporarily:
                        domain_shutdown $domain --wait $WAIT_TIME

                        if [[ $? -eq 0 ]]; then

                            # Adds VM to shutdown success local list:
                            domain_shutdown_success[$i]=$domain

                            # Restarts the loop (checks backup again under changed condition):
                            continue
                        else

                            # Adds VM to failed to shutdown local list
                            # (This VM might shutdown eventually):
                            domain_shutdown_failed[$i]=$domain

                            # Exits the loop (nothing else can be done):
                            break
                        fi
                else
                    # (User must shutdown the VM manually):
                    echo "$domain: Cannot check backup chain integrity while VM is running (RESTARTED_SERVER mode is enabled)"

                    # Adds VM to failed to shutdown local list:
                    domain_shutdown_failed[$i]=$domain

                    # Exits the loop (nothing else can be done):
                    break
                fi
            fi

            # Performs a deep check when VM is shut down:
            #------------------------------------------------------------------------------
            if [[ $(domain_state $domain) == "shut off" ]]; then


                # Backup chain is worth of being checked:
                #------------------------------------------------------------------------------
                if [[ $backup_folder_integrity == true ]] || [[ $recoverable_backup_chain == true ]]; then

                echo "$domain: Is shut down, performing a full check into its backup chain..."

                    if [[ $RESTARTED_SERVER == true ]] ; then

                        # No QEMU checkpoints are found in this specific state. Falls back to checkpoints in backup:

                        echo "$domain: Reading checkpoints list from backup"
                        checkpoint_list=($(backup_checkpoint_list $BACKUPS_MAIN_PATH/$domain))
                    else

                        echo "$domain: Reading checkpoints list from QEMU"
                        checkpoint_list=($(domain_checkpoint_list $domain))
                    fi

                    # Perform a full check of checkpoints vs bitmaps:
                    for image in $(domain_img_paths_list $domain); do

                        bitmaps_list=($(disk_image_bitmap_list $image))

                        if [[ ${bitmaps_list[@]} != ${checkpoint_list[@]} ]]; then

                            backup_check_failed="yes"
                            echo "$domain: Checkpoints and bitmaps lists on disk $image MISMATCH"

                            # Nothing else can be done
                            break

                        elif [[ ! -z ${bitmaps_list[@]} ]]; then

                            # It is assumed bitmaps = checkpoints, and none is a empty list:
                            echo "$domain: Checkpoints and bitmaps lists on disk $image MATCH"
                        else

                            backup_check_failed="yes"
                            echo "$domain: ${#checkpoint_list[@]} checkpoints found, and ${#bitmaps_list[@]} bitmaps found on disk $image (backup chain is broken)"

                            # Nothing else can be done
                            break
                        fi
                    done
                fi

                # When above check failed or something was wrong from the very beginning, cleanses disk images,
                # checkpoints metadata (if any), and archives or deletes the existing backup chain, according the case:
                #------------------------------------------------------------------------------
                if [[ $backup_check_failed == yes ]] \
                || [[ $recoverable_backup_chain == false ]] \
                || [[ $backup_folder_integrity == false ]]; then

                    if [[ $RESTARTED_SERVER != true ]]; then

                        # Deletes checkpoints metadata if any detected:
                        echo "$domain: Pruning existing checkpoints in QEMU..."
                        domain_delete_checkpoint_metadata $domain --all
                    fi

                    for image in $(domain_img_paths_list $domain); do

                        # Then deletes all bitmaps, in all image disks:
                        echo "$domain: Deleting bitmaps on disk image $image..."

                        for bitmap in $(disk_image_bitmap_list $image); do

                            disk_image_delete_bitmap $image $bitmap
                        done
                    done

                # Mark the backup chain status as broken:
                broken_backup_chain[$i]=$domain

                # If backup check was successful:
                #------------------------------------------------------------------------------
                else

                    # If backup chain is recoverable, cleanses the VM with the failed checkpoint:
                    #------------------------------------------------------------------------------
                    if [[ $recoverable_backup_chain == true ]]; then

                        # Checks used RAM
                        local ram_size=$(domain_getmem $domain --max)
                        local memlimit_active=""
                        if [[ ! -z $RAM_LIMIT_PER_SCHED_BACKUP ]] && [[ $ram_size -gt $RAM_LIMIT_PER_SCHED_BACKUP ]]; then

                            # Sets temporal limits of RAM before to perform the operation:
                            memlimit_active="yes"
                            domain_setmem $domain $RAM_LIMIT_PER_SCHED_BACKUP
                        fi

                        domain_start $domain --nowait

                        echo "$domain: Removing damaged checkpoint: ${checkpoint_list[-1]} ..."
                        domain_delete_checkpoint $domain ${checkpoint_list[-1]}

                        domain_shutdown $domain --nowait

                        # Reverts RAM limits when these was previously changed:
                        [[ ! -z $memlimit_active ]] && domain_setmem $domain $original_ram_size
                    fi

                    # Backup chain will be treated as preserved:
                    preserved_backup_chain+=($domain)
                fi

            # When VM is running, performs a simpler checkpoint check in case is worth to proceed.
            #------------------------------------------------------------------------------
            else

                if [[ $backup_folder_integrity == true ]] || [[ $recoverable_backup_chain == true ]]; then

                    echo "$domain: VM appears to be running, comparing QEMU and Backup's checkpoint lists..."

                    # Gets both qemu and backup checkpoint lists:
                    checkpoint_list=($(domain_checkpoint_list $domain))

                    local backup_chain_checkpoint_list=($(backup_checkpoint_list $BACKUPS_MAIN_PATH/$domain))

                    if [[ ${checkpoint_list[@]} == ${backup_chain_checkpoint_list[@]} ]]; then

                        echo "$domain: QEMU and Backup's checkpoint lists MATCH"

                        if [[ $recoverable_backup_chain == true ]]; then

                            echo "$domain: Removing damaged checkpoint: ${checkpoint_list[-1]} ..."
                            domain_delete_checkpoint $domain ${checkpoint_list[-1]}

                            echo "$domain: Power cycling VM to apply changes..."
                            domain_powercycle $domain $WAIT_TIME
                        fi

                        # Backup chain is OK, mark as preserved:
                        preserved_backup_chain+=($domain)

                    else

                        echo "$domain: QEMU and Backup's checkpoint lists MISMATCH"

                        # Mark the backup chain status as broken:
                        broken_backup_chain[$i]=$domain

                        # Additionally, mark it as non recoverable (to be archived):
                        recoverable_backup_chain="false"

                    fi

                # Virtnbdbackup can take care of checkpoints/bitmaps in this scenario:
                #------------------------------------------------------------------------------
                else

                    # Mark the backup chain status as broken:
                    broken_backup_chain[$i]=$domain
                fi
            fi

            # Final step is to process backup chain files according the results:
            #------------------------------------------------------------------------------

            if [[ $backup_folder_integrity == false ]]; then

                # Unrecoverable or unexistent backup chain folder. Delete it:
                rm -rf $BACKUPS_MAIN_PATH/$domain

            elif [[ $recoverable_backup_chain == false ]]; then

                # Backup chain is total or partially recoverable.

                # Generate an updated time stamp to rename archived backups:
                timestamp=$(date '+%Y-%m-%d.%H:%M:%S')

                # Processes backup for being archived locally:
                archive_backup $BACKUPS_MAIN_PATH/$domain $MAX_BACKUP_CHAINS_PER_VM $timestamp

                # When remote endpoint is set, process remote backup copy to be archived:
                [[ ! -z $REMOTE_BACKUPS_MAIN_PATH ]] && archive_remote_backup $REMOTE_BACKUPS_MAIN_PATH/$domain $REMOTE_MAX_BACKUP_CHAINS_PER_VM $timestamp

            elif [[ $recoverable_backup_chain == true ]]; then

                # Recoverable backup chain passed the test. Delete the demaged checkppoint and keep the backup chain:

                echo "$domain: Fixing backup chain data in $BACKUPS_MAIN_PATH/$domain ..."

                # Deletes any related file with the damaged checkpoint:
                find $BACKUPS_MAIN_PATH/$domain -name \*${checkpoint_list[-1]}* -type f -delete

                # Deletes the last checkpoint from the list:
                unset checkpoint_list[-1]

                # Create a stringified variable to export updated list
                local new_checkpoint_list="${checkpoint_list[@]}"

                # Rebuilds the cpt file with the parsed new list of checkpoints:
                echo "[\"${new_checkpoint_list// /\", \"}\"]" > $BACKUPS_MAIN_PATH/$domain/$domain.cpt

            fi

            # Exits the loop:
            break

        done

        # VM is unlisted from CHECK_BACKUPS_LIST:
         unset CHECK_BACKUPS_LIST[$i]

        # Increases the index to check the next VM:
        ((i++))
    done

    # Writes updated SCHEDULED_BACKUPS_LIST value:
    # as a string, since sed can't expand arrays correctly:
    SCHEDULED_BACKUPS_LIST+=(${preserved_backup_chain[@]})
    SCHEDULED_BACKUPS_LIST="${SCHEDULED_BACKUPS_LIST[@]}"

    # And updates it externally:
    sed -i \
    -e "s/SCHEDULED_BACKUPS_LIST=.*/SCHEDULED_BACKUPS_LIST=($SCHEDULED_BACKUPS_LIST)/" \
    $external_vars

    # Turn again stringified variables back into lists:
    SCHEDULED_BACKUPS_LIST=($SCHEDULED_BACKUPS_LIST)

    # Appends sub-list to global list of VMs in need of a new backup chain:
    CREATE_BACKUP_CHAIN_LIST+=(${broken_backup_chain[@]})

    # Appends sub-list to the global list of powered OFF VMs:
    POWEREDOFF_VMS_LIST+=(${domain_shutdown_success[@]})

    # Appends sub-list of failed to shutdown VMs to global list of VMs with issues
    SHUTDOWN_REQUIRED_VMS_LIST+=(${domain_shutdown_failed[@]})

    echo ""
    echo "Backup Chain Integrity Summary:"
    echo ""
    echo "Added to Scheduled Backups:   ${preserved_backup_chain[@]:-"None"}"
    echo "In need of new backup chain:  ${broken_backup_chain[@]:-"None"}"
    [[ ! -z $RESTART_VMS_IF_REQUIRED ]] && \
    echo "Into automatic power cycle:   ${domain_shutdown_success[@]:-"None"}" || \
    echo "Manual shut down is required: ${domain_shutdown_failed[@]:-"None"}"

    if [[ -z ${domain_shutdown_failed[@]} ]]; then

        echo ""
        echo "All Backup Chains Checked!"
    fi
}

#------------------------------------------------------------------------------
# Creates backup chains for VMs in CREATE_BACKUP_CHAIN_LIST, managing temporal RAM limits (when set) and powering on/off as necessary:
#------------------------------------------------------------------------------
create_backup_chain()
{
    # Local variables used for flow control:
    local original_ram_size
    local memlimit_active

    # Lists to add VMs (and summarize at the end):
    local backup_chain_failed
    local backup_chain_success
    local domain_poweron_failed
    local domain_poweron_success
    local remote_sync_failed
    local remote_sync_success

    echo ""
    echo "___________________________________________________________________________________________________"
    echo "Creating Backup chains for Virtual machines: ${CREATE_BACKUP_CHAIN_LIST[@]}"

    [[ $(os_is_unraid) == yes ]] && unraid_notify "info" "VM-Babysitter" "Virtnbdbackup" "New backup chain(s) creation is in progress (avoid to stop/restart this container until completed)"

    local i=0
    for domain in ${CREATE_BACKUP_CHAIN_LIST[@]}; do

        original_ram_size=""
        memlimit_active="no"

        echo ""

        while true; do

            if [[ $(domain_state $domain) == running ]]; then

                # Only when VM is running, attempts to create a new backup chain:
                do_backup_chain $domain "full" $BACKUPS_MAIN_PATH $VIRTNBDBACKUP_ARGS

                if [[ $? -eq 0 ]]; then

                    # Backup chain creation was successful!
                    backup_chain_success[$i]=$domain
                else

                    # Failed to create a new backup chain:
                    backup_chain_failed[$i]=$domain

                    # Delete partial files (unusable garbage):
                    rm -rf $BACKUPS_MAIN_PATH/$domain
                fi

                if [[ ${domain_poweron_success[$i]} == $domain ]]; then

                    # VM was previously shut off, revert to its previous state:
                    domain_shutdown $domain --nowait

                    if [[ $memlimit_active == yes ]]; then

                        # RAM was previously throttled. Reverting to its original values:
                        domain_setmem $domain $original_ram_size
                        echo "$domain: Reverted RAM size to its original setting of $original_ram_size KiB"
                    fi
                fi

                if [[ ${backup_chain_success[$i]} == $domain ]] && [[ ! -z $REMOTE_BACKUPS_MAIN_PATH ]]; then

                    # Backup chain creation was successful and remote endpoint is (correctly) set,
                    # attempts to transfer changes via rsync:

                    echo "$domain: Copying new backup chain to configured remote mirror..."

                    # Transfer backup using SSH_OPTS and RSYNC_ARGS:
                    rsync -a $RSYNC_ARGS -e "ssh $SSH_OPTS" $BACKUPS_MAIN_PATH/$domain/ $REMOTE_BACKUPS_MAIN_PATH/$domain/

                    local rsync_status=$?

                    # Depending on success with rsync, will add the VM to $remote_success or $remote_fail
                    if [[ $rsync_status -eq 0 ]]; then

                        # When rsync exited normally, adds the VM to $remote_sync_success:
                        remote_sync_success[$i]+=$domain
                        echo "$domain: New backup chain was copied successfuly to configured remote mirror"
                    else

                        # Otherwise, adds the VM to $remote_sync_failed list:
                        remote_sync_failed[$i]+=$domain
                        echo "$domain: Failed to copy new backup chain to configured remote mirror with status $rsync_status"
                    fi
                fi

                # Exits the loop:
                break

            else

                # VM is presumably shut off. Will attempts to start it:

                if [[ ! -z $RAM_LIMIT_PER_SCHED_BACKUP ]]; then

                    # And needs to check how much memory uses by default, throttling it if limits are established:

                    # Gets the original RAM size
                    original_ram_size=$(domain_getmem $domain --max)

                    # If the above value is greater than the established limit, sets the VM RAM temporarily to such limit:
                    if [[ $original_ram_size -gt $RAM_LIMIT_PER_SCHED_BACKUP ]]; then

                        memlimit_active="yes"
                        domain_setmem $domain $RAM_LIMIT_PER_SCHED_BACKUP

                        echo "$domain: RAM size temporarily throttled from $original_ram_size KiB to $RAM_LIMIT_PER_SCHED_BACKUP KiB for this task"
                    fi
                fi

                # Attempts to start the VM (awaits for VM's QEMU agent):
                domain_start $domain --wait $WAIT_TIME
                if [[ $? -eq 0 ]]; then

                    domain_poweron_success[$i]=$domain

                    # Restarts the loop to chech VM under changed conditions:
                    continue
                else

                    # VM failed to power on. This is an abnormal situation:
                    echo "$domain: Failed to proceed (no backup chain could be created)"
                    domain_poweron_failed[$i]=$domain

                    # Breaks the loop:
                    break
                fi
            fi
        done

        # Unlist VM from CREATE_BACKUP_CHAIN_LIST:
         unset CREATE_BACKUP_CHAIN_LIST[$i]

        # Increases the index to check the next VM:
        ((i++))
    done

    # Appends updated values:
    # (as a string, since sed can't expand arrays correctly):
    SCHEDULED_BACKUPS_LIST+=(${backup_chain_success[@]})
    SCHEDULED_BACKUPS_LIST="${SCHEDULED_BACKUPS_LIST[@]}"

    CHECK_PATCH_LIST+=(${backup_chain_failed[@]})
    CHECK_PATCH_LIST="${CHECK_PATCH_LIST[@]}"

    FAILED_VMS_LIST+=(${domain_poweron_failed[@]})
    FAILED_VMS_LIST="${FAILED_VMS_LIST[@]}"

    # And updates them all at once:
    sed -i \
    -e "s/SCHEDULED_BACKUPS_LIST=.*/SCHEDULED_BACKUPS_LIST=($SCHEDULED_BACKUPS_LIST)/" \
    -e "s/CHECK_PATCH_LIST=.*/CHECK_PATCH_LIST=($CHECK_PATCH_LIST)/" \
    -e "s/FAILED_VMS_LIST=.*/FAILED_VMS_LIST=($FAILED_VMS_LIST)/" \
    $external_vars

    # Turn again stringified variables back into lists:
    CHECK_PATCH_LIST=($CHECK_PATCH_LIST)
    SCHEDULED_BACKUPS_LIST=($SCHEDULED_BACKUPS_LIST)
    FAILED_VMS_LIST=($FAILED_VMS_LIST)

    # And shows the summary at the very end:

    echo ""
    echo "Backup Chain Creation Summary:"
    echo ""
    echo "Added to Scheduled Backups:        ${backup_chain_success[@]:-"None"}"
    echo "Could not create new backup chain: ${backup_chain_failed[@]:-"None"}"
    echo "Could not power on:                ${domain_poweron_failed[@]:-"None"}"

    if [[ ! -z $REMOTE_BACKUPS_MAIN_PATH ]]; then

        # Only show remote stats when remote endppoint is set:
        echo ""
        echo "Success copying to remote mirror: ${remote_sync_success[@]:-"None"}"
        echo "Could not copy to remote mirror:  ${remote_sync_failed[@]:-"None"}"
    fi

    if [[ -z ${backup_chain_failed[@]} ]] && [[ -z ${domain_poweron_failed[@]} ]]; then

        echo ""
        echo "All Backup Chains Created!"
    fi

    if [[ $(os_is_unraid) == yes ]]; then

        # On Unraid, notifies about failed operations exclusively related with virtnbdbackup and rsync (others are done from vm-babysitter monitoring):

        unraid_notify "info" "VM-Babysitter" "Virtnbdbackup" "Backup chain(s) creation completed"

        [[ ! -z ${remote_sync_failed[@]} ]] && unraid_notify "warning" "Rsync" "${remote_sync_failed[@]}" "Could not sync to remote endpoint, it will be attempted again on first schedule (last status: $rsync_status)"

        [[ ! -z ${backup_chain_failed[@]} ]] && unraid_notify "warning" "Virtnbdbackup" "${backup_chain_failed[@]}" "Could not create new backup chain(s). Check $(basename $MAIN_LOGPATH) for detailed info"
    fi
}

###############################################################################
# Main execution:
###############################################################################

#------------------------------------------------------------------------------
# Internal global variables and common functions are managed via this script:
source $functions_path
#------------------------------------------------------------------------------
# 1. Check input parameters (exits on error)
#------------------------------------------------------------------------------

# Creates internal folders in case don't exist:
[[ ! -d $( dirname $MAIN_LOGPATH) ]] && mkdir -p $(dirname $MAIN_LOGPATH)

# Copies stdout and stderr to $MAIN_LOGPATH:
exec > >(tee -a $MAIN_LOGPATH) 2> >(tee -a $MAIN_LOGPATH >&2)

# Sets the local timezone (if ENV TZ was set):
if [[ ! -z $local_timezone_file ]]; then

    ln -fs $local_timezone_file /etc/localtime
    &> /dev/null dpkg-reconfigure -f noninteractive tzdata
fi


# Catches the signal sent from docker to stop execution:
# The most gracefully way to stop this container is with:
# 'docker kill --signal=SIGTERM <docker-name-or-id>'
trap 'stop_container' SIGTERM

echo "############################################################################################################"
echo "Container started at: $(date "+%Y-%m-%d %H:%M:%S") ($(cat /etc/timezone))"
echo "############################################################################################################"

# 1.1 Check DOMAINS_LIST:
#------------------------------------------------------------------------------
echo ""
echo "Querying for persistent Virtual machines from libvirt..."

# The initial list of VMs to work:
DOMAINS_LIST=($(domains_list))

if [[ ! -z ${DOMAINS_LIST[@]} ]]; then

    # 1.1.1 Check IGNORED_VMS_LIST:
    #------------------------------------------------------------------------------
    if [[ ! -z $IGNORED_VMS_LIST ]]; then

    echo ""

        i=0
        for domain in $IGNORED_VMS_LIST; do

            if [[ $(domain_exists $domain) == yes ]]; then

                # Remove the VM from DOMAINS_LIST
                unset DOMAINS_LIST[$(item_position $domain "DOMAINS_LIST")]
                echo "$domain: Into IGNORED_VMS_LIST, therefore ignored"
            else

                #unset IGNORED_VMS_LIST[$i]
                echo "WARNING: VM '$domain' in IGNORED_VMS_LIST not found!"
            fi
            ((i++))
        done
    fi

    # 1.1.2 Check AUTOSTART_VMS_LIST:
    #------------------------------------------------------------------------------
    if [[ ! -z $AUTOSTART_VMS_LIST ]]; then

    echo ""

    i=0
        for domain in $AUTOSTART_VMS_LIST; do

            if [[ $(domain_exists $domain) == yes ]]; then

                # Add VM to the list of VMs to be powered on when monitor starts:
                POWEREDOFF_VMS_LIST+=($domain)
                echo "$domain: Into AUTOSTART_VMS_LIST, therefore will be started (after initial check)"
            else

                echo "WARNING: VM $domain in AUTOSTART_VMS_LIST not found!"
            fi
            ((i++))
        done
    fi

    # 1.1.3 Check DOMAINS_LIST VM's disk images:
    #------------------------------------------------------------------------------

    echo ""

    i=0
    for domain in ${DOMAINS_LIST[@]}; do

        drives_list=($(domain_drives_list $domain))
        if [[ ! -z ${drives_list[@]} ]]; then

            # Does have drives able to be backed up. Checks if such disk images are reachable inside the container:
            images_list=($(domain_img_paths_list $domain))
            for image in ${images_list[@]}; do

                if [[ ! -f $image ]]; then

                    FAILED_VMS_LIST+=($domain)
                    echo "ERROR: $domain's disk image: $image not found. Ensure you mount -and mirror- this correctly inside the container (e.g. '-v /common/path/to/vms/disks:/common/path/to/vms/disks')"

                elif [[ ! -r $image ]] && [[ ! -w $image ]]; then

                    FAILED_VMS_LIST+=($domain)
                    echo "ERROR: $domain's disk image: $image has permission issues (cannot be read or written)"
                fi
            done
        else

            # Exclude VMs without disks images that can be backed up:
            unset DOMAINS_LIST[$i]
            echo "WARNING: VM $domain has no drives that can be backed up, therefore will be ignored"
        fi
        ((i++))
    done


    if [[ ! -z ${FAILED_VMS_LIST[@]} ]]; then

        echo "ERROR: Issues detected with '${FAILED_VMS_LIST[@]}' that need to be solved before to run this container again"

    else
        # When no VM failed the test AND remained VMs to check (not ignored), then domain_list check is successful:
        domains_list_status="OK"
        echo "Persistent Virtual machine(s) able to be backed up: ${DOMAINS_LIST[@]}"
    fi
else
    echo "ERROR: No persistent Virtual machines found!"
fi

# 1.2 Check BACKUPS_MAIN_PATH
#------------------------------------------------------------------------------

#if [[ ! -z $BACKUPS_MAIN_PATH ]]; then

    echo ""

    if  [[ -d $BACKUPS_MAIN_PATH ]]; then

        # $BACKUPS_MAIN_PATH found
        if  [[ -r $BACKUPS_MAIN_PATH ]] && [[ -w $BACKUPS_MAIN_PATH ]]; then

            # $BACKUPS_MAIN_PATH has read/write permissions.
            backups_main_path_status="OK"
            echo "Backups main path internally set to: $BACKUPS_MAIN_PATH"

            # Check for MAX_BACKUP_CHAINS_PER_VM:
            if [[ $MAX_BACKUP_CHAINS_PER_VM =~ [0-9] ]]; then

                # Is an integer number:
                echo "Max backup chains per VM to keep locally: $MAX_BACKUP_CHAINS_PER_VM"

            elif [[ -z $MAX_BACKUP_CHAINS_PER_VM ]]; then

                # Was not set:
                echo "Environment variable MAX_BACKUP_CHAINS_PER_VM not set. ALL recoverable backup chains will be archived locally"

            else
                # Invalid value (unsets the 'OK' status):
                unset backups_main_path_status
                echo "ERROR: Incorrect value for environment variable MAX_BACKUP_CHAINS_PER_VM: '$MAX_BACKUP_CHAINS_PER_VM' <- It must be a natural integer"
            fi
        else

            echo "ERROR: Backups main path: $BACKUPS_MAIN_PATH <- Permission issues (cannot be read or written)"
        fi
    else

        echo "ERROR: Backups main path: $BACKUPS_MAIN_PATH  <- Not found inside the container. Ensure you mount this correctly (e.g. '-v /path/to/backups-main-path:/$BACKUPS_MAIN_PATH')"
    fi
#else

    #echo "ERROR: Environment variable BACKUPS_MAIN_PATH is not set!"
#fi

# 1.3 Check REMOTE_BACKUPS_MAIN_PATH
#------------------------------------------------------------------------------

if [[ -z $REMOTE_BACKUPS_MAIN_PATH ]]; then

    remote_backups_main_path_status="UNUSED"
    echo ""
    echo "Environment variable REMOTE_BACKUPS_MAIN_PATH not set. No remote backup endpoint will be used"

elif [[ $REMOTE_BACKUPS_MAIN_PATH == *@*:/* ]]; then

    echo ""

    # Apparently includes correct remote login and path. Separates ssh login from remote path:
    remote_server=$(echo $REMOTE_BACKUPS_MAIN_PATH | cut -d':' -f1)
    remote_backups_main_path=$(echo $REMOTE_BACKUPS_MAIN_PATH | cut -d':' -f2)

    # Attempts to comunicate with the remote host:
    #ssh_command $remote_server "exit 0"
    ssh $SSH_OPTS $remote_server "exit 0"
    remote_server_status=$?

    if [[ $remote_server_status == 0 ]]; then

        # Attempts to perform similar checks as with $BACKUPS_MAIN_PATH, except it only returns "OK" if there was success:
        remote_backups_main_path_status=$(ssh $SSH_OPTS $remote_server "[[ -d $remote_backups_main_path ]] && [[ -r $remote_backups_main_path ]] && [[ -w $remote_backups_main_path ]] && echo 'OK' || { mkdir -p $remote_backups_main_path; [[ -d $remote_backups_main_path ]] && echo 'CREATED' || echo 'FAILED'; }")

        echo "$remote_server: $remote_backups_main_path status is $remote_backups_main_path_status"

        if [[ $remote_backups_main_path_status != FAILED ]]; then

            if [[ $REMOTE_MAX_BACKUP_CHAINS_PER_VM =~ [0-9] ]]; then

                # Is an integer number:
                echo "Max backup chains per VM to keep remotely: $REMOTE_MAX_BACKUP_CHAINS_PER_VM"
            elif [[ -z $REMOTE_MAX_BACKUP_CHAINS_PER_VM ]]; then

                # Was not set:
                echo "Environment variable REMOTE_MAX_BACKUP_CHAINS_PER_VM not set. ALL recoverable backup chains will be archived remotely"
            else

                # Unset status variable to prevent keep running:
                unset remote_backups_main_path_status
                echo "ERROR: Incorrect value for environment variable REMOTE_MAX_BACKUP_CHAINS_PER_VM: '$REMOTE_MAX_BACKUP_CHAINS_PER_VM' <- It must be a natural integer"
            fi
        else

            unset remote_backups_main_path_status
            echo "ERROR: Remote mirror: $REMOTE_BACKUPS_MAIN_PATH <- Permission issues (cannot be read or written) or is not a directory"
        fi
    else

        echo "ERROR: Connection with $remote_server failed with status $remote_server_status"
    fi
else

    echo "ERROR: Incorrect syntax for $REMOTE_BACKUPS_MAIN_PATH <- It must be an SSH-like absolute path (e.g. user@host:/absolute/path/to/mirror)"
fi

# 1.4 TO DO: Check other ENV variables, and SSH key:
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# 2. Only when input parameters doesn't require to restart the container, it continues the rest of the checks:
#------------------------------------------------------------------------------

if [[ $domains_list_status == OK ]] && [[ $backups_main_path_status == OK ]] && [[ ! -z $remote_backups_main_path_status ]]; then

    # 2.1 Create/update Cron task for VMs to be (progressively) included in $scheduled_backups_list:
    #------------------------------------------------------------------------------

    echo ""
    echo "Deploying Cron task..."

    [[ -z $CRON_SCHEDULE ]] && { CRON_SCHEDULE="@daily"; echo "Environment variable 'CRON_SCHEDULE' is not set. Using default scheduling '$CRON_SCHEDULE'"; }

    # Silently deletes any previous cron task:
    &> /dev/null crontab -r

    # Parses the actual cron task needed to run to $crontab_file
    # (Including ENV vars not being read from cron's environment):
    cat << end_of_crontab > $crontab_file
# Values below are refreshed upon container (re)start:

# Main environment is bash:
SHELL=/bin/bash

# Search paths for binaries and scripts:
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# Environment variables passed through Docker:
BACKUPS_MAIN_PATH="$BACKUPS_MAIN_PATH"
RAM_LIMIT_PER_SCHED_BACKUP="$RAM_LIMIT_PER_SCHED_BACKUP"
REMOTE_BACKUPS_MAIN_PATH="$REMOTE_BACKUPS_MAIN_PATH"
RSYNC_ARGS="$RSYNC_ARGS"
SCHEDULED_LOGPATH="$SCHEDULED_LOGPATH"
SSH_OPTS="$SSH_OPTS"
VIRTNBDBACKUP_ARGS="$VIRTNBDBACKUP_ARGS"

# Paths for functions and (shared) dynamic variables:
functions_path="$functions_path"
external_vars="$external_vars"

$CRON_SCHEDULE $scheduled_backup_script
end_of_crontab

    # Sets the cron task:
    crontab $crontab_file

    if [[ ! -f $SCHEDULED_LOGPATH ]]; then

        # Creates folders in case doesn't exist:
        mkdir -p $(dirname $SCHEDULED_LOGPATH)

        # Initializes the log file (in case doesn't exist):
        touch -a $SCHEDULED_LOGPATH
    fi

    # Finally, runs cron and sends to background:
    cron -f -l -L2 &

    # 2.2 Check if OS is Unraid and it has just been restarted (checking backups under this scenario assumes missing checkpoints / broken backup chains:
    #------------------------------------------------------------------------------

    echo ""

    if [[ $(os_is_unraid) == yes ]]; then

        echo "OS Unraid detected"

        for domain in ${DOMAINS_LIST[@]}; do

            # Looks for checkpoints in all VMs, only stopping if it finds something
            # (does not rely on expose checkpoints dir inside the container):
            [[ ! -z $(domain_checkpoint_list $domain) ]] && { checkpoints_found="yes"; break; }

        done

        if [[ -z $checkpoints_found ]]; then

            # RESTARTED_SERVER mode detected:
            RESTARTED_SERVER="true"
            echo "____________________________________________________________________________________________________________"
            echo "WARNING: No checkpoints were found by libvirt at all. RESTARTED_SERVER mode enabled!"
            echo "Unraid server appears to have been restarted recently or this is the very first usage"
            echo "Virtual machines shown in the above list are in need to be Shut Down in order to check backup chain's integrity more comprehensively, attempting to fixup or (re)creating as needed"
            echo "(This mode will be disabled after first scheduled backup has been performed)"

            for domain in ${DOMAINS_LIST[@]}; do

                if [[ $(domain_state $domain) != "shut off" ]]; then

                    if [[ ! -z $RESTART_VMS_IF_REQUIRED ]]; then

                        domain_shutdown $domain --wait $WAIT_TIME
                        if [[ $? -eq 0 ]]; then

                            # And into this list to be started as checks has been completed:
                            POWEREDOFF_VMS_LIST+=($domain)

                            # Adds successfully shut off VMs to the initial queue:
                            CHECK_PATCH_LIST+=($domain)

                        else

                            # VM Delayed too much without being shutdown. Added to this queue to be checked up periodically:
                            SHUTDOWN_REQUIRED_VMS_LIST+=($domain)
                        fi
                    else

                        # User needs to shutdown this VM before to perform any further checks:
                        SHUTDOWN_REQUIRED_VMS_LIST+=($domain)
                    fi
                else

                    # Adds already shut down VMs to the initial queue:
                    CHECK_PATCH_LIST+=($domain)
                fi
            done

            echo "RESTARTED_SERVER mode Summary:"
            echo "Ready for further checks:     ${CHECK_PATCH_LIST[@]:-"None"}"
            [[ ! -z $RESTART_VMS_IF_REQUIRED ]] && \
            echo "Into automatic power cycle:   ${POWEREDOFF_VMS_LIST[@]:-"None"}" || \
            echo "Manual shut down is required: ${SHUTDOWN_REQUIRED_VMS_LIST[@]:-"None"}"
        else

            # Fortunately there's not a 'RESTARTED_SERVER' scenario.
            # Add all remaining VMs in DOMAINS_LIST to the first queue:
            CHECK_PATCH_LIST=(${DOMAINS_LIST[@]})

            # Exports the variable, since it's modified by the scheduled script:
            RESTARTED_SERVER="false"
        fi
    else

        # OS is not Unraid.
        # Add all remaining VMs in DOMAINS_LIST to this queue:
        CHECK_PATCH_LIST=(${DOMAINS_LIST[@]})
    fi

    # 2.3 Initializes a file with variables externally stored, to be shared with the scheduler:
    #------------------------------------------------------------------------------
    cat << end_of_external_variables > $external_vars
# Shared values between $(basename %0) and $scheduled_backup_script. DO NOT EDIT!:

# Dynamic arrays:
SCHEDULED_BACKUPS_LIST=()
CHECK_PATCH_LIST=(${CHECK_PATCH_LIST[@]})
FAILED_VMS_LIST=()

# Dynamic strings:
ONGOING_CHECK="false"
ONGOING_BACKUP="false"
RESTARTED_SERVER=$RESTARTED_SERVER
end_of_external_variables

    # 3. Begin monitorization for VMs in lists, performing operations as required:
    #------------------------------------------------------------------------------

    echo ""
    echo "############################################################################################################"
    echo "Monitoring mode started"

    while true; do

        # Maximum standby period for monitoring should not exceed 10 seconds in any case,
        # because it could ignore SIGTERM from Docker, thus being killed with SIGKILL:
        sleep 1

        # 3.1 (Re)reads all external variables:
        #------------------------------------------------------------------------------
        source $external_vars

        if [[ $ONGOING_BACKUP == false ]]; then

            if [[ ! -z ${SHUTDOWN_REQUIRED_VMS_LIST[@]} ]]; then

                # 3.2 Check for VMs which are in need of shutdown first.
                # (This normally happens when the user took the action, or when a VM took long time to shutdown):
                #------------------------------------------------------------------------------
                i=0
                for domain in ${SHUTDOWN_REQUIRED_VMS_LIST[@]}; do

                    if [[ $(domain_state $domain) == "shut off" ]]; then

                        # Move to main queue for check:
                        CHECK_PATCH_LIST+=($domain)
                        unset SHUTDOWN_REQUIRED_VMS_LIST[$i]

                        [[ $(os_is_unraid) == yes ]] && unraid_notify "normal" "VM-Babysitter" "$domain" "Required shut down was detected (resuming checks/backups)"
                    fi
                done
            fi

            if [[ ! -z ${CHECK_PATCH_LIST[@]} ]]; then

                # 3.3 Status of at least on VM has changed, and sent to one queue:
                #------------------------------------------------------------------------------

                # Marks an ongoing check starting:
                ONGOING_CHECK="true"
                sed -i \
                -e "s/ONGOING_CHECK=.*/ONGOING_CHECK=\"$ONGOING_CHECK\"/" $external_vars

                echo ""
                echo "____________________________________________________________________________________________________________"
                echo "Status change detected at $(date "+%Y-%m-%d %H:%M:%S")"
                echo "Automatic check for VM(s) ${CHECK_PATCH_LIST[@]} in progress..."

                check_patch
            fi

            # 3.4 Backups of VMs that passed check_patch successfuly will be checked for integrity (and fixed, when possible):
            #------------------------------------------------------------------------------
            [[ ! -z ${CHECK_BACKUPS_LIST[@]} ]] && check_backups

            if [[ ! -z ${POWEREDOFF_VMS_LIST[@]} ]]; then

                # 3.5 Turns on all VMs that was previously shutdown for checks:
                #------------------------------------------------------------------------------
                echo ""
                i=0
                for domain in ${POWEREDOFF_VMS_LIST[@]}; do

                    if [[ $(domain_state $domain) != running ]]; then

                        # Turn on the VM. Do not wait for Guest's QEMU agent:
                        domain_start $domain --nowait
                    fi

                    # Remove the VM from the list is being read:
                    unset POWEREDOFF_VMS_LIST[$i]

                    # Increases the counter:
                    ((i++))
                done
            fi

            # 3.6 Those VMs in need of a full backup chain, will run this process:
            #------------------------------------------------------------------------------
            [[ ! -z ${CREATE_BACKUP_CHAIN_LIST[@]} ]] && create_backup_chain

            if [[ $ONGOING_CHECK == true ]]; then

                # Only checked when status changes were initially detected:
                if [[ -z ${CHECK_PATCH_LIST[@]} ]]; then

                    # No VMs in CHECK_PATCH_LIST (string or array, as comes up)
                    # It means that all checks finished successfully, entering in 'silent' mode:
                    ONGOING_CHECK="false"
                    sed -i \
                    -e "s/ONGOING_CHECK=.*/ONGOING_CHECK=\"$ONGOING_CHECK\"/" $external_vars

                    echo ""
                    echo "############################################################################################################"
                    echo "All VMs with status changed finished to be processed at $(date "+%Y-%m-%d %H:%M:%S")"
                    echo ""
                    echo "VM-Babysitter Global Summary:"
                    echo ""
                    echo "Current Scheduled Backups:    ${SCHEDULED_BACKUPS_LIST[@]:-"None"}"
                    echo "Manual Shut Down Required:    ${SHUTDOWN_REQUIRED_VMS_LIST[@]:-"None"}"
                    echo "Misbehaving Virtual Machines: ${FAILED_VMS_LIST[@]:-"None"}"

                    if [[ ! -z ${SCHEDULED_BACKUPS_LIST[@]} ]] && \
                    [[ -z ${SHUTDOWN_REQUIRED_VMS_LIST[@]} ]] && \
                    [[ -z ${FAILED_VMS_LIST[@]} ]]; then

                        echo ""
                        echo "All Virtual Machines Running Under Incremental Backups!"

                    elif [[ ! -z ${SHUTDOWN_REQUIRED_VMS_LIST[@]} ]] || [[ ! -z ${FAILED_VMS_LIST[@]} ]]; then

                        user_action_message="WARNING: USER ACTION IS REQUIRED!"

                        echo ""
                        echo $user_action_message

                        if [[ ! -z ${SHUTDOWN_REQUIRED_VMS_LIST[@]} ]]; then

                            shutdown_required_message="Perform a MANUAL SHUT DOWN of the following VM(s):'${SHUTDOWN_REQUIRED_VMS_LIST[@]}' to allow being checked automatically (meanwhile, checks/backups will be skipped)"

                            echo $shutdown_required_message
                            [[ $(os_is_unraid) == yes ]] && unraid_notify "warning" "VM-Babysitter" "$user_action_message" "$shutdown_required_message"
                        fi

                        if [[ ! -z ${FAILED_VMS_LIST[@]} ]]; then

                            failed_vms_message="VM(s): '${FAILED_VMS_LIST[@]}' Failed to power on/off properly, or could not apply incremental backup patch during last check. Do a MANUAL REVISION of failing VMs IMMEDIATELY, and restart the container (meanwhile, will be ignored)"

                            echo  $failed_vms_message
                            [[ $(os_is_unraid) == yes ]] && unraid_notify "alert" "VM-Babysitter/Libvirt" "$user_action_message" "$failed_vms_message"
                        fi
                    fi

                    if [[ -z ${SCHEDULED_BACKUPS_LIST[@]} ]]; then

                        no_schedules_message="At the moment, NO Virtual Machine is on schedule for incremental backup"

                        echo ""
                        echo $no_schedules_message
                        #[[ $(os_is_unraid) == yes ]] && unraid_notify "normal" "VM-Babysitter" "No schedules" "$no_schedules_message"
                    fi
                fi
            fi
        fi
        # 3.7 Restarts the loop from 3.1, until receives SIGTERM or SIGKILL from Docker
        #------------------------------------------------------------------------------
    done

else

    # Initial checks have proven non-recoverable errors:
    failed_initialize_message="ERROR: Could not initialize due to errors in one or more input parameters!"

    echo $message
    [[ $(os_is_unraid) == yes ]] && unraid_notify "warning" "VM-Babysitter" "Failed to start container" "$failed_initialize_message. Check $(basename $MAIN_LOGPATH) for detailed info"

    stop_container
fi
