#!/bin/bash

###############################################################################
# Main variables:
###############################################################################

# Temporal crontab file (to be loaded for cron)
crontab_file="/tmp/crontab"

# Storing file for bash like lists shared between this script and the scheduler:
external_vars="/tmp/vm-babysit-vars"

# Main library where common functions and some variables are loaded:
functions_path="functions"

# Log file path for this script:
logpath=${MONITOR_LOGPATH:-"/logs/vm-babysitter.log"}

# Path of the scheduler script (run by cron):
scheduled_backup_script="/usr/local/bin/update_backup_chain"

# Log file path for the scheduler script:
scheuled_logpath=${SCHEDULED_LOGPATH:-"/logs/scheduled-backups.log"}

# Location of current Time Zone (if defined in ENV TZ):
[[ -f /usr/share/zoneinfo/$TZ ]] && local_timezone_file="/usr/share/zoneinfo/$TZ"

###############################################################################
# Specific procedures:
###############################################################################

#------------------------------------------------------------------------------
# Attempts to stop the container gracefully in case of receive SIGTERM signal from Docker:
#------------------------------------------------------------------------------
stop_container()
{
    echo "############################################################################################################"
    echo ""
    echo "SIGTERM signal received at: $(date "+%Y-%m-%d %H:%M:%S")"
    # To DO: Terminate or kill background processes before to exit.
    echo "Container Stopped."
    exit 0
}

#------------------------------------------------------------------------------
# Check if VMs in CHECK_PATCH_LIST are patched for incremental backups (and applies it when possible):
#------------------------------------------------------------------------------
check_patch()
{
    # Lists to add VMs (and summarize at the end):
    local domain_shutdown_success
    local domain_shutdown_failed
    local vm_patch_success
    local vm_patch_failed

    echo "___________________________________________________________________________________________________"
    echo ""
    echo "Checking / Patching for incremental backups Virtual machines: ${CHECK_PATCH_LIST[@]}"

    local i=0
    for domain in ${CHECK_PATCH_LIST[@]}; do

        # For each VM, the loop repeats itself as needed until a VM has been successfully patched, or not:
        while true; do

            if [[ -z ${domain_shutdown_failed[$i]} ]] && [[ -z ${vm_patch_failed[$i]} ]]; then

                if [[ $(domain_is_patched $domain ) == yes ]]; then

                    echo "$domain: Patch for incremental backup is OK"
                    vm_patch_success[$i]+=$domain
                    break

                elif [[ $(domain_is_patched $domain --inactive) == yes ]]; then

                    # VM is (presumably) running and was patched before (e.g. in past iteration inside this loop)
                    echo "$domain: Patch for incremental backups was performed, but a power cycle is required to apply changes"

                    if [[ ! -z $RESTART_VMS_IF_REQUIRED ]]; then

                        # When permission is granted, and past iteration over the VM haven't triggered errors, attempts shuts down the VM temporarily:
                        domain_shutdown $domain --wait $WAIT_TIME

                        if [[ $? -eq 0 ]]; then

                            # Adds VM to shutdown success local list:
                            domain_shutdown_success[$i]+=$domain
                        else

                            # Adds VM to failed to shutdown local list
                            # (This VM might shutdown eventually):
                            domain_shutdown_failed[$i]=$domain
                        fi
                    else

                        # Adds VM to failed to shutdown local list
                        # (User must shutdown the VM manually):
                        domain_shutdown_failed[$i]=$domain
                    fi

                    # Restarts the loop (checks VM again under changed conditions):
                    continue

                else

                    echo "$domain: Patch for incremental backups was not found. Attempting to patch now..."

                    vm-patch $domain --quiet

                    # Adds VM to failed to patch local list:
                    [[ $? -ne 0 ]] && vm_patch_failed[$i]=$domain

                    # Restarts the loop (checks VM again under changed condition):
                    continue
                fi
            else

                # Failed either shutting down or applying the patch
                # Nothing else possible to do:
                break
            fi
        done

        # Removes VM from CHECK_PATCH_LIST:
        unset CHECK_PATCH_LIST[$i]

        # Increases the index to check the next VM:
        ((i++))
    done

    # Writes updated CHECK_PATCH_LIST value (actually, should be empty)
    # as a string, since sed can't expand arrays correctly:
    CHECK_PATCH_LIST="${CHECK_PATCH_LIST[@]}"

    # And updates it externally:
    sed -i \
    -e "s/CHECK_PATCH_LIST=.*/CHECK_PATCH_LIST=($CHECK_PATCH_LIST)/" \
    $external_vars

    # Turn again stringified variables back into lists:
    CHECK_PATCH_LIST=($CHECK_PATCH_LIST)

    # Appends sub-list of (successfully) patched VMs to global CHECK_BACKUPS_LIST:
    CHECK_BACKUPS_LIST+=(${vm_patch_success[@]})

    # Appends sub-list to the global list of powered OFF VMs:
    POWEREDOFF_VMS_LIST+=(${domain_shutdown_success[@]})

    # Appends sub list of VMs that failed to shutdoen to global SHUTDOWN_REQUIRED_VMS_LIST:
    SHUTDOWN_REQUIRED_VMS_LIST+=(${domain_shutdown_failed[@]})

    # Appends sub list of failed VMs:
    FAILED_VMS_LIST+=(${domain_shutdown_failed[@]})

    echo ""
    echo "VM Patch Summary:"
    echo ""
    echo "Ready for incremental backups: ${vm_patch_success[@]:-"None"}"
    [[ ! -z $RESTART_VMS_IF_REQUIRED ]] && \
    echo "Into automatic power cycle: ${domain_shutdown_success[@]:-"None"}"
    echo "Manual shut down is required: ${domain_shutdown_failed[@]:-"None"}"
    echo "Failed to apply patch: ${vm_patch_failed[@]:-"None"}"

    if [[ -z ${domain_shutdown_failed[@]} ]] && [[ -z ${vm_patch_failed[@]} ]]; then

        echo ""
        echo "All VMs Patched!"
    fi
}

#------------------------------------------------------------------------------
# Checks VMs in CHECK_BACKUPS_LIST for backup chain integrity (and puts VMs at point of create new backup chains, if possible):
#------------------------------------------------------------------------------
check_backups()
{
    # Local variables used for flow control:
    local backup_check_failed
    local backup_folder_integrity
    local bitmaps_list
    local checkpoint_list
    local recoverable_backup_chain

    # Lists to add VMs (and summarize at the end):
    local broken_backup_chain
    local domain_shutdown_failed
    local domain_shutdown_success
    local preserved_backup_chain

    echo "___________________________________________________________________________________________________"
    echo ""
    echo "Checking backup chain ingtegrity for Virtual machines: ${CHECK_BACKUPS_LIST[@]}"

    local i=0
    for domain in ${CHECK_BACKUPS_LIST[@]}; do

        backup_check_failed=""
        backup_folder_integrity=""
        checkpoint_list=()
        recoverable_backup_chain=""

        while true; do

            # Checks once for non existing, corrupted or dummy backup folders and partial checkpoints:
            #------------------------------------------------------------------------------
            if [[ -z $backup_folder_integrity ]] || [[ -z $recoverable_backup_chain ]]; then

                if [[ ! -d $BACKUPS_MAIN_PATH/$domain ]] \
                || [[ ! -f $BACKUPS_MAIN_PATH/$domain/$domain.cpt ]] \
                || [[ ! -d $BACKUPS_MAIN_PATH/$domain/checkpoints ]]; then

                    backup_folder_integrity="false"
                    echo "$domain: No backup chain folder detected, or internal structure is damaged!"

                elif [[ ! -z $(find $BACKUPS_MAIN_PATH/$domain -type f -name "*.partial") ]]; then

                    local damaged_backup_checkpoint_list=($(backup_checkpoint_list $BACKUPS_MAIN_PATH/$domain))

                    if [[ ${#damaged_backup_checkpoint_list[@]} -eq 1 ]]; then

                        backup_folder_integrity="false"
                        echo "$domain: A full backup operation was previously cancelled. This backup chain is unrecoverable, therefore will be removed"

                    elif [[ $RESTARTED_SERVER == true ]]; then

                        recoverable_backup_chain="false"
                        echo "$domain: An incremental backup operation was previously cancelled and RESTARTED_SERVER mode is active, not leaving chances to repair it. A new backup chain will be created"

                    elif [[ -z $RESTART_VMS_IF_REQUIRED ]]; then

                        recoverable_backup_chain="false"
                        echo "$domain: An incremental backup operation was previously cancelled. Cannot proceed to attempt to repair since environment variable RESTART_VMS_IF_REQUIRED is not set. A new backup chain will be created"

                    else

                        recoverable_backup_chain="true"
                        echo "$domain: An incremental backup operation was previously cancelled. It will attempt to fix the current backup chain by deleting the (now useless) data that was being saved right before the cancellation, and deleting the checkpoint from this VM. This implies a full Power Cycle in order to apply all changes."
                    fi

                else

                    # Everything looks OK:
                    backup_folder_integrity="true"
                fi
            fi

            # Checks once if RESTARTED_SERVER is true, VM is running and RESTART_VMS_IF_REQUIRED is set
            # (Will fail if can't shut down the VM):
            #------------------------------------------------------------------------------
            if [[ $RESTARTED_SERVER == true ]] && [[ $(domain_state $domain) == running ]]; then

                if [[ ! -z $RESTART_VMS_IF_REQUIRED ]]; then

                    # Attempts to shut down the VM temporarily:
                        domain_shutdown $domain --wait $WAIT_TIME

                        if [[ $? -eq 0 ]]; then

                            # Adds VM to shutdown success local list:
                            domain_shutdown_success[$i]=$domain

                            # Restarts the loop (checks backup again under changed condition):
                            continue
                        else

                            # Adds VM to failed to shutdown local list
                            # (This VM might shutdown eventually):
                            domain_shutdown_failed[$i]=$domain

                            # Exits the loop (nothing else can be done):
                            break
                        fi
                else
                    # (User must shutdown the VM manually):
                    echo "$domain: Cannot check backup chain integrity while VM is running (RESTARTED_SERVER mode)"

                    # Adds VM to failed to shutdown local list:
                    domain_shutdown_failed[$i]=$domain

                    # Exits the loop (nothing else can be done):
                    break
                fi
            fi

            # Performs a deep check when VM is shut down:
            #------------------------------------------------------------------------------
            if [[ $(domain_state $domain) == "shut off" ]]; then


                # Backup chain is worth of being checked:
                #------------------------------------------------------------------------------
                if [[ $backup_folder_integrity == true ]] || [[ $recoverable_backup_chain == true ]]; then

                echo "$domain: Is shut down, performing a full check into its backup chain..."

                    if [[ $RESTARTED_SERVER == true ]] ; then

                        # No QEMU checkpoints are found in this specific state. Falls back to checkpoints in backup:

                        echo "$domain: Reading checkpoints list from backup (RESTARTED_SERVER mode)"
                        checkpoint_list=($(backup_checkpoint_list $BACKUPS_MAIN_PATH/$domain))
                    else

                        echo "$domain: Reading checkpoints list from QEMU"
                        checkpoint_list=($(domain_checkpoint_list $domain))
                    fi

                    # Perform a full check of checkpoints vs bitmaps:
                    for image in $(domain_img_paths_list $domain); do

                        bitmaps_list=($(disk_image_bitmap_list $image))
                        if [[ ${bitmaps_list[@]} != ${checkpoint_list[@]} ]]; then

                            backup_check_failed="yes"
                            echo "$domain: Checkpoints and bitmaps lists on disk $image MISMATCH"
                            break

                        else

                            echo "$domain: Checkpoints and bitmaps lists on disk $image MATCH"
                        fi
                    done
                fi

                # When above check failed or something was wrong from the very beginning, cleanses disk images,
                # checkpoints metadata (if any), and archives or deletes the existing backup chain, according the case:
                #------------------------------------------------------------------------------
                if [[ $backup_check_failed == yes ]] \
                || [[ $recoverable_backup_chain == false ]] \
                || [[ $backup_folder_integrity == false ]]; then


                    if [[ $RESTARTED_SERVER != true ]]; then

                        echo "$domain: Pruning existing checkpoints in QEMU..."
                        domain_delete_checkpoint_metadata $domain --all
                    fi

                    for image in $(domain_img_paths_list $domain); do

                        # Then deletes all bitmaps, in all image disks:
                        echo "$domain's disk $image: Deleting bitmaps..."

                        for bitmap in $(disk_image_bitmap_list $image); do

                            disk_image_delete_bitmap $image $bitmap
                        done
                    done

                # Mark the backup chain status as broken:
                broken_backup_chain[$i]=$domain

                # If backup check was successful:
                #------------------------------------------------------------------------------
                else

                    # If backup chain is recoverable, cleanses the VM with the failed checkpoint:
                    #------------------------------------------------------------------------------
                    if [[ $recoverable_backup_chain == true ]]; then

                        echo "$domain: Starting VM..."
                        domain_start $domain --nowait

                        echo "$domain: Removing damaged checkpoint: ${checkpoint_list[-1]} ..."
                        domain_delete_checkpoint $domain ${checkpoint_list[-1]}

                        echo "$domain: Shutting down VM to apply changes..."
                        domain_shutdown $domain --nowait
                    fi

                    # Backup chain will be treated as preserved:
                    preserved_backup_chain+=($domain)
                fi

            # When VM is running, performs a simpler checkpoint check in case is worth to proceed.
            #------------------------------------------------------------------------------
            else

                if [[ $backup_folder_integrity == true ]] || [[ $recoverable_backup_chain == true ]]; then

                    echo "$domain: VM is (presumably) running, comparing checkpoint lists in both QEMU and backup chain..."

                    # Gets both qemu and backup checkpoint lists:
                    checkpoint_list=($(domain_checkpoint_list $domain))

                    local backup_chain_checkpoint_list=($(backup_checkpoint_list $BACKUPS_MAIN_PATH/$domain))

                    if [[ ${checkpoint_list[@]} == ${backup_chain_checkpoint_list[@]} ]]; then

                        echo "$domain: QEMU and Backup's checkpoint lists MATCH"

                        if [[ $recoverable_backup_chain == true ]]; then

                            echo "$domain: Removing damaged checkpoint: ${checkpoint_list[-1]} ..."
                            domain_delete_checkpoint $domain ${checkpoint_list[-1]}

                            echo "$domain: Power cycling VM to apply changes..."
                            domain_powercycle $domain $WAIT_TIME
                        fi

                        # Backup chain is OK, mark as preserved:
                        preserved_backup_chain+=($domain)

                    else

                        echo "$domain: QEMU and Backup's checkpoint lists MISMATCH"

                        # Mark the backup chain status as broken:
                        broken_backup_chain[$i]=$domain

                        # Additionally, mark it as non recoverable (to be archived):
                        recoverable_backup_chain="false"

                    fi

                # Virtnbdbackup can take care of checkpoints/bitmaps in this scenario:
                #------------------------------------------------------------------------------
                else

                    # Mark the backup chain status as broken:
                    broken_backup_chain[$i]=$domain
                fi
            fi

            # Final step is to process backup chain files according the results:
            #------------------------------------------------------------------------------

            if [[ $backup_folder_integrity == false ]]; then

                # Unrecoverable or unexistent backup chain folder. Delete it:
                rm -rf $BACKUPS_MAIN_PATH/$domain

            elif [[ $recoverable_backup_chain == false ]]; then

                # Backup chain is total or partially recoverable.

                # Generate an updated time stamp to rename archived backups:
                timestamp=$(date '+%Y-%m-%d.%H:%M:%S')

                # Processes backup for being archived locally:
                archive_backup $BACKUPS_MAIN_PATH/$domain $MAX_BACKUP_CHAINS_PER_VM $timestamp

                # When remote endpoint is set, process remote backup copy to be archived:
                [[ ! -z $REMOTE_BACKUPS_MAIN_PATH ]] && archive_remote_backup $REMOTE_BACKUPS_MAIN_PATH/$domain $REMOTE_MAX_BACKUP_CHAINS_PER_VM $timestamp

            elif [[ $recoverable_backup_chain == true ]]; then

                # Recoverable backup chain passed the test. Delete the demaged checkppoint and keep the backup chain:

                echo "$domain: Fixing backup chain data in $BACKUPS_MAIN_PATH/$domain ..."

                # Deletes any related file with the damaged checkpoint:
                find $BACKUPS_MAIN_PATH/$domain -name \*${checkpoint_list[-1]}* -type f -delete

                # Deletes the last checkpoint from the list:
                unset checkpoint_list[-1]

                # Create a stringified variable to export updated list
                local new_checkpoint_list="${checkpoint_list[@]}"

                # Rebuilds the cpt file with the parsed new list of checkpoints:
                echo "[\"${new_checkpoint_list// /\", \"}\"]" > $BACKUPS_MAIN_PATH/$domain/$domain.cpt

            fi

            # Exits the loop:
            break

        done

        # VM is unlisted from CHECK_BACKUPS_LIST:
         unset CHECK_BACKUPS_LIST[$i]

        # Increases the index to check the next VM:
        ((i++))
    done

    # Writes updated SCHEDULED_BACKUPS_LIST value:
    # as a string, since sed can't expand arrays correctly:
    SCHEDULED_BACKUPS_LIST+=(${preserved_backup_chain[@]})
    SCHEDULED_BACKUPS_LIST="${SCHEDULED_BACKUPS_LIST[@]}"

    # And updates it externally:
    sed -i \
    -e "s/SCHEDULED_BACKUPS_LIST=.*/SCHEDULED_BACKUPS_LIST=($SCHEDULED_BACKUPS_LIST)/" \
    $external_vars

    # Turn again stringified variables back into lists:
    SCHEDULED_BACKUPS_LIST=($SCHEDULED_BACKUPS_LIST)

    # Appends sub-list to global list of VMs in need of a new backup chain:
    CREATE_BACKUP_CHAIN_LIST+=(${broken_backup_chain[@]})

    # Appends sub-list to the global list of powered OFF VMs:
    POWEREDOFF_VMS_LIST+=(${domain_shutdown_success[@]})

    # Appends sub-list of failed to shutdown VMs to global list of VMs with issues
    SHUTDOWN_REQUIRED_VMS_LIST+=(${domain_shutdown_failed[@]})


    echo ""
    echo "Backup Chain Integrity Summary:"
    echo ""
    echo "On schedule for incremental backups: ${preserved_backup_chain[@]:-"None"}"
    echo "In need of new backup chain: ${broken_backup_chain[@]:-"None"}"
    [[ ! -z $RESTART_VMS_IF_REQUIRED ]] && \
    echo "Into automatic power cycle: ${domain_shutdown_success[@]:-"None"}"
    echo "Manual shut down is required: ${domain_shutdown_failed[@]:-"None"}"

    if [[ -z ${domain_shutdown_failed[@]} ]]; then

        echo ""
        echo "All Backup Chains Checked!"
    fi
}

#------------------------------------------------------------------------------
# Creates backup chains for VMs in CREATE_BACKUP_CHAIN_LIST, managing temporal RAM limits (when set) and powering on/off as necessary:
#------------------------------------------------------------------------------
create_backup_chain()
{
    # Local variables used for flow control:
    local original_ram_size
    local memlimit_active

    # Lists to add VMs (and summarize at the end):
    local backup_chain_failed
    local backup_chain_success
    local domain_poweron_failed
    local domain_poweron_success
    local remote_sync_failed
    local remote_sync_success

    echo "___________________________________________________________________________________________________"
    echo ""
    echo "Creating new Backup chains for Virtual machines: ${CREATE_BACKUP_CHAIN_LIST[@]}"

    local i=0
    for domain in ${CREATE_BACKUP_CHAIN_LIST[@]}; do

        original_ram_size=""
        memlimit_active="no"

        while true; do

            if [[ $(domain_state $domain) == running ]]; then

                # Only when VM is running, attempts to create a new backup chain:
                do_backup_chain $domain "full" $BACKUPS_MAIN_PATH $VIRTNBDBACKUP_ARGS

                if [[ $? -eq 0 ]]; then

                    # Backup chain creation was successful!
                    backup_chain_success[$i]=$domain
                else

                    # Failed to create a new backup chain:
                    backup_chain_failed[$i]=$domain

                    # Delete partial files (unusable garbage):
                    rm -rf $BACKUPS_MAIN_PATH/$domain
                fi

                if [[ ${domain_poweron_success[$i]} == $domain ]]; then

                    # VM was previously shut off, revert to its previous state:
                    domain_shutdown $domain --nowait

                    if [[ $memlimit_active == yes ]]; then

                        # RAM was previously throttled. Reverting to its original values:
                        domain_setmem $domain $original_ram_size
                        echo "$domain: Reverted RAM size to its original setting of $original_ram_size KiB"
                    fi
                fi

                # To DO: Sync on remote endpoint when REMOTE_BACKUPS_MAIN_PATH is set and bring status.
                if [[ ${backup_chain_success[$i]} == $domain ]] && [[ ! -z $REMOTE_BACKUPS_MAIN_PATH ]]; then

                    # Backup chain creation was successful and remote endpoint is (correctly) set,
                    # attempts to transfer changes via rsync:

                    echo "$domain: Copying new backup chain to configured remote endpoint..."

                    # Transfer backup using SSH_OPTS and RSYNC_ARGS:
                    rsync -a $RSYNC_ARGS -e "ssh $SSH_OPTS" $BACKUPS_MAIN_PATH/$domain/ $REMOTE_BACKUPS_MAIN_PATH/$domain/

                    local rsync_status=$?

                    # Depending on success with rsync, will add the VM to $remote_success or $remote_fail
                    if [[ $rsync_status -eq 0 ]]; then

                        # When rsync exited normally, adds the VM to $remote_sync_success:
                        remote_sync_success[$i]+=$domain
                        echo "$domain: New backup chain was copied successfuly to configured remote endpoint"
                    else

                        # Otherwise, adds the VM to $remote_sync_failed list:
                        remote_sync_failed[$i]+=$domain
                        echo "$domain: Failed to copy new backup chain to configured remote endpoint with status $rsync_status"
                    fi
                fi

                # Exits the loop:
                break

            else

                # VM is presumably shut off. Will attempts to start it:

                if [[ ! -z $RAM_LIMIT_PER_SCHED_BACKUP ]]; then

                    # And needs to check how much memory uses by default, throttling it if limits are established:

                    # Gets the original RAM size
                    original_ram_size=$(domain_getmem $domain --max)

                    # If the above value is greater than the established limit, sets the VM RAM temporarily to such limit:
                    if [[ $original_ram_size -gt $RAM_LIMIT_PER_SCHED_BACKUP ]]; then

                        memlimit_active="yes"
                        domain_setmem $domain $RAM_LIMIT_PER_SCHED_BACKUP

                        echo "$domain: RAM size temporarily throttled from $original_ram_size KiB to $RAM_LIMIT_PER_SCHED_BACKUP KiB for this task"
                    fi
                fi

                # Attempts to start the VM (awaits for VM's QEMU agent):
                domain_start $domain --wait $WAIT_TIME
                if [[ $? -eq 0 ]]; then

                    domain_poweron_success[$i]=$domain

                    # Restarts the loop to chech VM under changed conditions:
                    continue
                else

                    # VM failed to power on. This is an abnormal situation:
                    echo "$domain: Failed to proceed (no backup chain could be created)"
                    domain_poweron_failed[$i]=$domain

                    # Breaks the loop:
                    break
                fi
            fi
        done

        # Unlist VM from CREATE_BACKUP_CHAIN_LIST:
         unset CREATE_BACKUP_CHAIN_LIST[$i]

        # Increases the index to check the next VM:
        ((i++))
    done

    # As scheduled backups could happen during creation / sync of several backup chains
    # (including the VMs sent to schedule in check_backups),
    # results necessary to re-read external variables in case some incremental backup failed,
    source $external_vars

    # Appends updated values:
    # (as a string, since sed can't expand arrays correctly):
    SCHEDULED_BACKUPS_LIST+=(${backup_chain_success[@]})
    SCHEDULED_BACKUPS_LIST="${SCHEDULED_BACKUPS_LIST[@]}"

    CHECK_PATCH_LIST+=(${backup_chain_failed[@]})
    CHECK_PATCH_LIST="${CHECK_PATCH_LIST[@]}"

    FAILED_VMS_LIST+=(${domain_poweron_failed[@]})
    FAILED_VMS_LIST="${FAILED_VMS_LIST[@]}"

    # And updates them all at once:
    sed -i \
    -e "s/SCHEDULED_BACKUPS_LIST=.*/SCHEDULED_BACKUPS_LIST=($SCHEDULED_BACKUPS_LIST)/" \
    -e "s/CHECK_PATCH_LIST=.*/CHECK_PATCH_LIST=($CHECK_PATCH_LIST)/" \
    -e "s/FAILED_VMS_LIST=.*/FAILED_VMS_LIST=($FAILED_VMS_LIST)/" \
    $external_vars

    # Turn again stringified variables back into lists:
    CHECK_PATCH_LIST=($CHECK_PATCH_LIST)
    SCHEDULED_BACKUPS_LIST=($SCHEDULED_BACKUPS_LIST)
    FAILED_VMS_LIST=($FAILED_VMS_LIST)

    # And shows the summary at the very end:

    echo ""
    echo "Backup Chain Creation Summary:"
    echo ""
    echo "On schedule for incremental backups: ${backup_chain_success[@]:-"None"}"
    echo "Failed to create backup chain: ${backup_chain_failed[@]:-"None"}"
    echo "Failed to power on: ${domain_poweron_failed[@]:-"None"}"

    if [[ ! -z $REMOTE_BACKUPS_MAIN_PATH ]]; then

        # Only show remote stats when remote endppoint is set:
        echo "Copied to remote endpoint: ${remote_sync_success[@]:-"None"}"
        echo "Failed copying to remote endpoint: ${remote_sync_failed[@]:-"None"}"
    fi

    if [[ -z ${backup_chain_failed[@]} ]] && [[ -z ${domain_poweron_failed[@]} ]]; then

        echo ""
        echo "All Backup Chains Created!"
    fi
}

###############################################################################
# Main execution:
###############################################################################

#------------------------------------------------------------------------------
# Internal global variables and common functions are managed via this script:
source $functions_path
#------------------------------------------------------------------------------
# 1. Check input parameters (exits on error)
#------------------------------------------------------------------------------

# Redirects all output to a log file:
exec &>> $logpath

# Sets the local timezone (if ENV TZ was set):
if [[ ! -z $local_timezone_file ]]; then

    ln -fs $local_timezone_file /etc/localtime
    dpkg-reconfigure -f noninteractive tzdata
fi


# Catches the signal sent from docker to stop execution:
# The most gracefully way to stop this container is with:
# 'docker kill --signal=SIGTERM <docker-name-or-id>'
trap 'stop_container' SIGTERM
############################################################################################################
echo "############################################################################################################"
echo "Container started at: $(date "+%Y-%m-%d %H:%M:%S") ($(cat /etc/timezone))"
echo "############################################################################################################"

# 1.1 Check DOMAINS_LIST:
#------------------------------------------------------------------------------

# The initial list of VMs to work:
DOMAINS_LIST=($(domains_list))

echo "Initial list of Virtual machines detected: '${DOMAINS_LIST[@]}'"

if [[ ! -z ${DOMAINS_LIST[@]} ]]; then

    # 1.1.1 Check IGNORED_VMS_LIST:
    #------------------------------------------------------------------------------
    # Debugging VMs to be ignored (set into a bash array):
    IGNORED_VMS_LIST=($IGNORED_VMS_LIST)

    i=0
#    if [[ ! -z ${IGNORED_VMS_LIST[@]} ]]; then

        for domain in ${IGNORED_VMS_LIST[@]}; do

            if [[ $(domain_exists $domain) == yes ]]; then

                # Remove the VM from DOMAINS_LIST
                unset DOMAINS_LIST[$(item_position $domain "DOMAINS_LIST")]
                echo "Ignoring VM $domain declared into IGNORED_VMS_LIST"
            else

                unset IGNORED_VMS_LIST[$i]
                echo "WARNING: VM $domain declared into IGNORED_VMS_LIST not found!"
            fi
            ((i++))
        done
#    fi

    # 1.1.2 Check AUTOSTART_VMS_LIST:
    #------------------------------------------------------------------------------
    # Debugging VMs to be powered on on container's start (set into a bash array):
    AUTOSTART_VMS_LIST=($AUTOSTART_VMS_LIST)

    i=0
#    if [[ ! -z ${AUTOSTART_VMS_LIST[@]} ]]; then

        for domain in ${AUTOSTART_VMS_LIST[@]}; do

            if [[ $(domain_exists $domain) == no ]]; then

                unset AUTOSTART_VMS_LIST[$i]
                echo "WARNING: VM $domain declared in AUTOSTART_VMS_LIST not found!"
            fi
            ((i++))
        done
#    fi

    # 1.1.3 Check DOMAINS_LIST VM's disk images:
    #------------------------------------------------------------------------------
    echo "Querying for persistent Virtual machines from libvirt..."
    i=0
    for domain in ${DOMAINS_LIST[@]}; do

        drives_list=($(domain_drives_list $domain))
        if [[ ! -z ${drives_list[@]} ]]; then

            # Does have drives able to be backed up. Checks if such disk images are reachable inside the container:

            images_list=($(domain_img_paths_list $domain))
            for image in ${images_list[@]}; do

                if [[ ! -f $image ]]; then

                    FAILED_VMS_LIST+=($domain)
                    unset DOMAINS_LIST[$i]
                    echo "ERROR: $domain's disk image: $image not found"

                elif [[ ! -r $image ]] && [[ ! -w $image ]]; then

                    FAILED_VMS_LIST+=($domain)
                    unset DOMAINS_LIST[$i]
                    echo "ERROR: $domain's disk image: $image has permission issues (cannot be read or written)"
                fi
            done
        else
            IGNORED_VMS_LIST+=($domain)
            unset DOMAINS_LIST[$i]
            echo "WARNING: VM $domain has no drives that can be backed up (ignored)"
        fi
        ((i++))
    done

    if [[ ! -z ${FAILED_VMS_LIST[@]} ]]; then

        echo "ERROR: Issues were detected with VM(s) '${FAILED_VMS_LIST[@]}' that need to be solved before to run this container again."

    else
        # When no VM failed the test AND remained VMs to check (not ignored), then domain_list check is successful:
        domains_list_status="OK"
    fi
else
    echo "ERROR: No persistent Virtual machines found!"
fi

# 1.2 Check BACKUPS_MAIN_PATH
#------------------------------------------------------------------------------

if [[ ! -z $BACKUPS_MAIN_PATH ]]; then

    if  [[ -d $BACKUPS_MAIN_PATH ]]; then

        # $BACKUPS_MAIN_PATH found
        if  [[ -r $BACKUPS_MAIN_PATH ]] && [[ -w $BACKUPS_MAIN_PATH ]]; then

            # $BACKUPS_MAIN_PATH has read/write permissions.
            backups_main_path_status="OK"
            echo "Backups main path set to: $BACKUPS_MAIN_PATH"
            # Check for MAX_BACKUP_CHAINS_PER_VM:

            if [[ $MAX_BACKUP_CHAINS_PER_VM =~ [0-9] ]]; then

                # Is an integer number:
                echo "Max # of backup chains per VM to keep locally: $MAX_BACKUP_CHAINS_PER_VM"

            elif [[ -z $MAX_BACKUP_CHAINS_PER_VM ]]; then

                # Was not set:
                echo "Environment variable MAX_BACKUP_CHAINS_PER_VM not set. ALL backup chains that are recoverable will be kept locally"

            else

                # Invalid value (unsets the 'OK' status):
                unset backups_main_path_status
                echo "ERROR: Incorrect syntax for environment variable MAX_BACKUP_CHAINS_PER_VM (must be a natural integer)"
            fi
        else
            echo "ERROR: Backups main path: $BACKUPS_MAIN_PATH has permission issues (cannot be read or written)"
        fi
    else
        echo "ERROR: Backups main path: $BACKUPS_MAIN_PATH  not found or not a directory (must be an absolute path)"
    fi
else
    echo "ERROR: Environment variable BACKUPS_MAIN_PATH is not set"
fi

# 1.3 Check REMOTE_BACKUPS_MAIN_PATH
#------------------------------------------------------------------------------

if [[ -z $REMOTE_BACKUPS_MAIN_PATH ]]; then

    remote_backups_main_path_status="UNUSED"
    echo "Environment variable REMOTE_BACKUPS_MAIN_PATH not set. No remote backup endpoint will be used"

elif [[ $REMOTE_BACKUPS_MAIN_PATH == *@*:/* ]]; then

    # Apparently includes correct remote login and path. Separates ssh login from remote path:
    remote_server=$(echo $REMOTE_BACKUPS_MAIN_PATH | cut -d':' -f1)
    remote_backups_main_path=$(echo $REMOTE_BACKUPS_MAIN_PATH | cut -d':' -f2)

    # Attempts to comunicate with the remote host:
    #ssh_command $remote_server "exit 0"
    ssh $SSH_OPTS $remote_server "exit 0"
    remote_server_status=$?

    if [[ $remote_server_status == 0 ]]; then

        # Attempts to perform similar checks as with $BACKUPS_MAIN_PATH, except it only returns "OK" if there was success:
        remote_backups_main_path_status=$(ssh $SSH_OPTS $remote_server "[[ -d $remote_backups_main_path ]] && [[ -r $remote_backups_main_path ]] && [[ -w $remote_backups_main_path ]] && echo 'OK' || { mkdir -p $remote_backups_main_path; [[ -d $remote_backups_main_path ]] && echo 'CREATED' || echo 'FAILED'; }")

        echo "$remote_server: Status of $remote_backups_main_path: '$remote_backups_main_path_status'"

        if [[ $remote_backups_main_path_status != FAILED ]]; then

            if [[ $REMOTE_MAX_BACKUP_CHAINS_PER_VM =~ [0-9] ]]; then

                # Is an integer number:
                echo "Max # of backup chains per VM to be kept remotely: $REMOTE_MAX_BACKUP_CHAINS_PER_VM"
            elif [[ -z $REMOTE_MAX_BACKUP_CHAINS_PER_VM ]]; then

                # Was not set:
                echo "Environment variable REMOTE_MAX_BACKUP_CHAINS_PER_VM not set. ALL backup chains that are recoverable will be kept remotely"
            else

                # Unset status variable to prevent keep running:
                unset remote_backups_main_path_status
                echo "ERROR: Incorrect syntax for environment variable REMOTE_MAX_BACKUP_CHAINS_PER_VM (must be a natural integer)"
            fi
        else
            unset remote_backups_main_path_status
            echo "ERROR: Remote endpoint: $REMOTE_BACKUPS_MAIN_PATH has permission issues (cannot be read or written) or is not a directory"
        fi
    else
        echo "ERROR: Connection with $remote_server failed with status $remote_server_status"
    fi
else
    echo "ERROR: Incorrect syntax for $REMOTE_BACKUPS_MAIN_PATH (must be an SSH-like absolute path)"
fi

# 1.4 TO DO: Check other ENV variables, and SSH key:
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# 2. Only when input parameters doesn't require to restart the container, it continues the rest of the checks:
#------------------------------------------------------------------------------

if [[ $domains_list_status == OK ]] && [[ $backups_main_path_status == OK ]] && [[ ! -z $remote_backups_main_path_status ]]; then

    # 2.1 Create/update Cron task for VMs to be (progressively) included in $scheduled_backups_list:
    #------------------------------------------------------------------------------

    echo "Deploying Cron task..."

    [[ -z $CRON_SCHEDULE ]] && { CRON_SCHEDULE="@daily"; echo "INFO: Environment variable 'CRON_SCHEDULE' is not set. Using default parameter ($CRON_SCHEDULE)"; }

    # Silently deletes any previous cron task:
    &> /dev/null crontab -r

    # Parses the actual cron task needed to run to $crontab_file
    # (Including ENV vars not being read from cron's environment):
    cat << end_of_crontab > $crontab_file
# These values are refreshed upon container's start:
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
BACKUPS_MAIN_PATH="$BACKUPS_MAIN_PATH"
RAM_LIMIT_PER_SCHED_BACKUP="$RAM_LIMIT_PER_SCHED_BACKUP"
REMOTE_BACKUPS_MAIN_PATH="$REMOTE_BACKUPS_MAIN_PATH"
RSYNC_ARGS="$RSYNC_ARGS"
SSH_OPTS="$SSH_OPTS"
VIRTNBDBACKUP_ARGS="$VIRTNBDBACKUP_ARGS"
$CRON_SCHEDULE $scheduled_backup_script
end_of_crontab

    # Sets the cron task:
    crontab $crontab_file

    # Initializes the log file (in case doesn't exist):
    touch -a $scheuled_logpath

    # Finally, runs cron and sends to background:
    cron -f -l -L2 &

    # Catching its PID:
    #cron_pid=$!

    # 2.2 Check if OS is Unraid and it has just been restarted (checking backups under this scenario assumes missing checkpoints / broken backup chains:
    #------------------------------------------------------------------------------

    if [[ $(os_is_unraid) == yes ]]; then

        echo "OS Unraid detected. Scanning for checkpoints..."

        for domain in ${DOMAINS_LIST[@]}; do

            # Looks for checkpoints in all VMs, only stopping if it finds something
            # (does not rely on expose checkpoints dir inside the container):
            [[ ! -z $(domain_checkpoint_list $domain) ]] && { checkpoints_found="yes"; break; }

        done

        if [[ -z $checkpoints_found ]]; then

            # Exports the variable, since it's modified by the scheduled script:
            export RESTARTED_SERVER="true"
            echo "___________________________________________________________________________________________________"
            echo ""
            echo "Unraid server appears to have been restarted recently or this is the very first usage, since no checkpoints were found by libvirt at all!"
            echo ""
            echo "All Virtual machines (except those ignored by thsi script, and declared in environment variable IGNORED_VMS_LIST) are in need to be Shut Down in order to check backup chains integrity more comprehensively, attempting to fixup or (re)creating as needed"
            echo ""

            for domain in ${DOMAINS_LIST[@]}; do

                if [[ $(domain_state $domain) != "shut off" ]]; then

                    if [[ ! -z $RESTART_VMS_IF_REQUIRED ]]; then

                        domain_shutdown $domain --wait $WAIT_TIME
                        if [[ $? -eq 0 ]]; then

                            # And into this list to be started as checks has been completed:
                            POWEREDOFF_VMS_LIST+=($domain)

                            # Adds successfully shut off VMs to the initial queue:
                            CHECK_PATCH_LIST+=($domain)

                        else

                            # VM Delayed too much without being shutdown. Added to this queue to be checked up periodically:
                            SHUTDOWN_REQUIRED_VMS_LIST+=($domain)
                        fi
                    else
                        # User needs to shutdown this VM before to perform any further checks:
                        SHUTDOWN_REQUIRED_VMS_LIST+=($domain)
                    fi
                else

                    # Adds already shut down VMs to the initial queue:
                    CHECK_PATCH_LIST+=($domain)
                fi
            done

            echo ""
            echo "RESTARTED_SERVER mode Summary:"
            echo ""
            echo "Ready for further checks: ${CHECK_PATCH_LIST[@]:-"None"}"
            [[ ! -z $RESTART_VMS_IF_REQUIRED ]] && \
            echo "Into automatic power cycle: ${POWEREDOFF_VMS_LIST[@]:-"None"}"
            echo "Manual shut down is needed before to proceed: ${SHUTDOWN_REQUIRED_VMS_LIST[@]:-"None"}"

        else
            # Fortunately there's not a 'RESTARTED_SERVER' scenario.
            # Add all remaining VMs in DOMAINS_LIST to the first queue:
            CHECK_PATCH_LIST=(${DOMAINS_LIST[@]})

            # Exports the variable, since it's modified by the scheduled script:
            RESTARTED_SERVER="false"
        fi
    else

        # OS is not Unraid.
        # Add all remaining VMs in DOMAINS_LIST to this queue:
        CHECK_PATCH_LIST=(${DOMAINS_LIST[@]})
    fi

    # 2.3 Initializes a file with variables externally stored, to be shared with the scheduler:
    #------------------------------------------------------------------------------
    cat << end_of_external_variables > $external_vars
# These values are shared (and constantly updated) by main and scheduler scripts:
CHECK_PATCH_LIST=(${CHECK_PATCH_LIST[@]})
SCHEDULED_BACKUPS_LIST=()
FAILED_VMS_LIST=()
ONGOING_CHECK="false"
ONGOING_BACKUP="false"
end_of_external_variables

    # 3. Begin monitorization for VMs in lists, performing operations as required:
    #------------------------------------------------------------------------------

    echo ""
    echo "############################################################################################################"
    echo "Starting Monitoring mode..."

    while true; do

        # Maximum standby period for monitoring should not exceed 10 seconds in any case,
        # because it could ignore SIGTERM from Docker, thus being killed with SIGKILL:
        sleep 1

        # 3.1 (Re)reads all external variables:
        #------------------------------------------------------------------------------
        source $external_vars

        if [[ $ONGOING_BACKUP == false ]]; then

            if [[ ! -z ${SHUTDOWN_REQUIRED_VMS_LIST[@]} ]]; then

                # 3.2 Check for VMs which are in need of shutdown first.
                # (This normally happens when the user took the action, or when a VM took long time to shutdown):
                #------------------------------------------------------------------------------
                i=0
                for domain in ${SHUTDOWN_REQUIRED_VMS_LIST[@]}; do

                    if [[ $(domain_state $domain) == "shut off" ]]; then

                        # Move to main queue for check:
                        CHECK_PATCH_LIST+=($domain)
                        unset SHUTDOWN_REQUIRED_VMS_LIST[$i]
                    fi
                done
            fi

            if [[ ! -z ${CHECK_PATCH_LIST[@]} ]]; then

                # 3.3 Status of at least on VM has changed, and sent to one queue:
                #------------------------------------------------------------------------------

                # Marks an ongoing check starting:
                ONGOING_CHECK="true"
                sed -i \
                -e "s/ONGOING_CHECK=.*/ONGOING_CHECK=\"$ONGOING_CHECK\"/" $external_vars

                echo "___________________________________________________________________________________________________"
                echo ""
                echo "Status change detected at $(date "+%Y-%m-%d %H:%M:%S")"
                echo "Automatic check for VM(s) '${CHECK_PATCH_LIST[@]} in progress..."

                check_patch
            fi

            # 3.4 Backups of VMs that passed check_patch successfuly will be checked for integrity (and fixed, when possible):
            #------------------------------------------------------------------------------
            [[ ! -z ${CHECK_BACKUPS_LIST[@]} ]] && check_backups


            if [[ ! -z ${AUTOSTART_VMS_LIST[@]} ]]; then

            # 3.5 When debugged AUTOSTART_VMS_LIST is set and VMs in list are shut down,
            # Turns them on:
            #------------------------------------------------------------------------------
            i=0
            for domain in ${AUTOSTART_VMS_LIST[@]}; do

                if [[ $(domain_state $domain) != running ]]; then

                    echo "$domain: Performing Auto start (declared into AUTOSTART_VMS_LIST)"
                    domain_start $domain --nowait
                fi

                    # Remove the VM from the list is being read:
                    unset AUTOSTART_VMS_LIST[$i]

                    # Increases the counter:
                    ((i++))
            done
            fi

            if [[ ! -z ${POWEREDOFF_VMS_LIST[@]} ]]; then

                # 3.6 Turns on all VMs that was previously shutdown for checks:
                #------------------------------------------------------------------------------
                echo "Starting (remaining) Virtual machines previously shut down for checks..."
                i=0
                for domain in ${POWEREDOFF_VMS_LIST[@]}; do

                    if [[ $(domain_state $domain) != running ]]; then

                        # Turn on the VM. Do not wait for Guest's QEMU agent:
                        domain_start $domain --nowait
                    fi

                    # Remove the VM from the list is being read:
                    unset POWEREDOFF_VMS_LIST[$i]

                    # Increases the counter:
                    ((i++))
                done
            fi

            # 3.7 Those VMs in need of a full backup chain, will run this process:
            #------------------------------------------------------------------------------
            [[ ! -z ${CREATE_BACKUP_CHAIN_LIST[@]} ]] && create_backup_chain


            if [[ $ONGOING_CHECK == true ]]; then

                # Only checked when status changes were initially detected:
                if [[ -z ${CHECK_PATCH_LIST[@]} ]]; then

                    # No VMs in CHECK_PATCH_LIST (string or array, as comes up)
                    # It means that all checks finished successfully, entering in 'silent' mode:
                    ONGOING_CHECK="false"
                    sed -i \
                    -e "s/ONGOING_CHECK=.*/ONGOING_CHECK=\"$ONGOING_CHECK\"/" $external_vars

                    echo ""
                    echo "############################################################################################################"
                    echo ""
                    echo "All VMs with status changed finished to be processed at $(date "+%Y-%m-%d %H:%M:%S")"
                    echo ""
                    echo "VM-Babysitter Global Summary:"
                    echo ""
                    echo "Current Scheduled Backups: ${SCHEDULED_BACKUPS_LIST[@]:-"None"}"
                    echo "Manual Shut Down Required: ${SHUTDOWN_REQUIRED_VMS_LIST[@]:-"None"}"
                    echo "Failing Virtual Machines: ${FAILED_VMS_LIST[@]:-"None"}"

                    if [[ ! -z ${SCHEDULED_BACKUPS_LIST[@]} ]] && \
                    [[ -z ${SHUTDOWN_REQUIRED_VMS_LIST[@]} ]] && \
                    [[ -z ${FAILED_VMS_LIST[@]} ]]; then

                        echo ""
                        echo "All Virtual Machines Running Under Incremental Backups!"
                        echo ""

                    elif [[ ! -z ${SHUTDOWN_REQUIRED_VMS_LIST[@]} ]] || [[ ! -z ${FAILED_VMS_LIST[@]} ]]; then

                        echo ""
                        echo "WARNING: USER ACTION IS REQUIRED!"
                        echo ""

                        [[ ! -z ${SHUTDOWN_REQUIRED_VMS_LIST[@]} ]] && \
                        echo "Perform a MANUAL SHUT DOWN of the following VM(s):'${SHUTDOWN_REQUIRED_VMS_LIST[@]}' to allow being checked automatically."

                        [[ ! -z ${FAILED_VMS_LIST[@]} ]] && \
                        echo "VM(s): '${FAILED_VMS_LIST[@]}' FAILED or behave ABNORMALLY during the checks. Do a manual check and ensure proper functioning; then restart this container in order to check again."
                    fi

                    if [[ -z ${SCHEDULED_BACKUPS_LIST[@]} ]]; then

                        echo ""
                        echo "At the moment, NO Virtual Machine is on schedule for incremental backup."
                        echo ""
                    fi
                fi
            fi
        fi
        # 3.8 Restarts the loop from 3.1, until receives SIGTERM or SIGKILL from Docker
        #------------------------------------------------------------------------------
    done

else
    # Initial checks have proven non-recoverable errors:
    echo "ERROR: Could not start due to errors on input parameters"
    stop_container
fi
