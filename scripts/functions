#!/bin/bash


# THIS SCIPT HOLDS ALL THE FUNCTIONS AND GLOBAL VARIABLES USED BY SCRIPTS

###############################################################################
# Common Variables:
###############################################################################
# Base MAC address used on the qemu/kvm implementation:
base_mac_addr="52:54:00"

# Maximum time to await for a response in certain functions:
wait_time=15

# Maximum number of attempts for a response in certain functions:
max_attempts=5

# SSH port can be omitted if 22. Otherwise, '-p <port_number>' :
ssh_port=""

###############################################################################
# Libvirt Related Functions:
###############################################################################

# -----------------------------------------------------------------------------
# Returns a list with existing checkpoints for a given VM according with libvirt.
# -----------------------------------------------------------------------------
domain_checkpoint_list()
{
    echo $(virsh checkpoint-list $1 --name --topological)
}

# -----------------------------------------------------------------------------
# Deletes checkpoints METADATA of a given VM:
# -----------------------------------------------------------------------------
domain_delete_checkpoint_metadata()
{
    local domain_delete_checkpoint_metadata_status=1

    local vm=$1
    local checkpoints_list=($(domain_checkpoint_list $1))
    local arguments="--metadata"

    if [[ ! -z ${checkpoints_list[@]} ]]; then

        echo "INFO: Libvirt reports ${#checkpoints_list[@]} checkpoints for VM '$vm'. This info will be removed..."

        for checkpoint in ${checkpoints_list[@]}; do
            &> /dev/null virsh checkpoint-delete $vm $checkpoint $arguments
        done
    else

        echo "INFO: No checkpoints for VM '$vm' reported by libvirt to remove"
    fi

}

#------------------------------------------------------------------------------
# Returns 'yes' or 'no' if domain exists and is persistent (not transient):
#------------------------------------------------------------------------------
domain_exists()
{
    [[ ! -z $(virsh list --all --name --persistent | grep -w "$1") ]] && echo "yes" || echo "no"
}

# -----------------------------------------------------------------------------
# Returns a string value with the UUID of the given domain:
# -----------------------------------------------------------------------------
domain_id()
{
    echo $(virsh dominfo $1 | grep -w "UUID:" | rev | cut -d' ' -f1 | rev)
}

# -----------------------------------------------------------------------------
# For a given VM name, returns a string value with (restorable) virtual drives (separated by spaces) (e.g. "hdc hdd")
# -----------------------------------------------------------------------------
domain_drives_list()
{
    echo $(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/file//g' -e 's/disk//g' -e 's/ //g' | cut -d'/' -f1)
}

# -----------------------------------------------------------------------------
# For a given VM name, returns a string value with absoulte path to its image disks (e.g. "/path-to/hdc.img /path-to/hdd.img")
# -----------------------------------------------------------------------------
domain_img_paths_list()
{
    echo $(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/ file //g' -e 's/ disk //g' | rev | cut -d' ' -f1 | rev )
}

#------------------------------------------------------------------------------
# Returns 'yes' or 'no' about if domain does have 'incremental-backup' capability (accepts extra parameters via $2):
#------------------------------------------------------------------------------
domain_is_patched()
{
    [[ ! -z $(virsh dumpxml $1 $2 | grep "<qemu:add capability='incremental-backup'/>") ]] && echo "yes" || echo "no"
}

# -----------------------------------------------------------------------------
# Returns a string that is a space separated list of mac addresses of a given VM:
# -----------------------------------------------------------------------------
domain_macaddr_list()
{
    echo $(virsh domiflist --inactive $1 | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}')
}

#------------------------------------------------------------------------------
# Attempts a full power cycle onto a given domain. Returns '0' if success and '1' if it fails:
#------------------------------------------------------------------------------
domain_powercycle()
{
    local domain=$1
    local powercycle_domain_status=1

    echo "Performing power cycle to $domain ..."

    # Sends the shutdown signal to the given domain:
    virsh shutdown $domain

    if [[ $? -eq 0 ]]; then

        local attempt=0
        while (( $attempt < $MAX_ATTEMPTS )); do
            ((attempt++))
            # Awaits for the VM (qemu guest service, actually) for being on
            sleep $wait_time

            if [[ $(domain_state $domain) == "shut off" ]]; then

                break

            elif [[ $attempt -eq $max_attempts ]]; then

                echo "WARNING: Unable to determine if VM $domain was completely shut down. Starting $domain anyway..."

            fi
        done

        # Turns on the domain again:
        virsh start $target_domain
        [[ $? -eq 0 ]] && { powercycle_domain_status=0; echo "INFO: $domain successfully restarted"; } || echo "ERROR: User action is required: Verify VM $domain (or libvirt status) and restart the container (This VM could not be started to complete the power cycle)"

    else
        echo "ERROR: Could not perform a power cycle to $domain"
    fi

    return $powercycle_domain_status
}

#------------------------------------------------------------------------------
# Powers on a given domain and awaits (unless --nowait is passed) for internal qemu agent to return a response:
#------------------------------------------------------------------------------
domain_start()
{

local domain_start_status
local vm_needed_state="running"

    if [[ $(domain_state $1) == $vm_needed_state ]]; then

        echo "INFO: VM '$1' is already $vm_needed_state"
    else

        # Starts the VM if is powered off:
        virsh start $1
        domain_start_status=$?

        if [[ $domain_start_status -eq 0 ]]; then

            if [[ $2 != --nowait ]]; then

                local attempt
                local agent_status

                # Await for QEMU agent response to exit successfully:
                local attempt=1
                while (( $attempt < $max_attempts )); do

                    # Awaits for the VM (qemu guest service, actually) for being on
                    sleep $wait_time

                    # (Silently) Gets VM output about its qemu agent:
                    > /dev/null virsh guestinfo $1
                    agent_status=$?

                    [[ $agent_status -eq 0 ]] && { echo "$1: Connected to QEMU agent"; break } ||           ((attempt++))
                done

                [[ $agent_status -ne 0 ]] && echo "WARNING: Gave up after $(( $wait_time * $max_attempts )) secs. awaiting for QEMU agent in VM $1. Ensure this service is installed and working on the guest OS to warrant concurrent data within backups."
            fi
        else
            echo "ERROR: Libvirt failed to start VM $1!"
        fi
    fi

    return $domain_start_status
}

#------------------------------------------------------------------------------
# Returns a string value with the state reported by libvirt (e.g. "running", "shut off", etc.)
# -----------------------------------------------------------------------------
domain_state()
{
    echo $(virsh domstate $1)
}

# -----------------------------------------------------------------------------
# Sends shutdown signal and awaits (unless --nowait is passed) until domain has been shutted down to return success:
# -----------------------------------------------------------------------------
domain_shutdown()
{
    local domain_shutdown_status
    local vm_needed_state="shut off"

    if [[ $(domain_state $1) == $vm_needed_state ]]; then

        echo "INFO: VM '$1' is already $vm_needed_state"
        domain_shutdown_status=0
    else

        virsh shutdown $1

        if [[ $domain_start_status -eq 0 ]]; then

            if [[ $2 != --nowait ]]; then

                local attempt=1
                while (( $attempt < $max_attempts )); do

                    sleep $wait_time
                    [[ $(domain_state $1) == $vm_needed_state ]] && { domain_shutdown_status=0; break; } || ((attempt++))
                done

                [[ $domain_shutdown_status -eq 0 ]] && echo "INFO: VM '$1' powered off successfully" || echo "WARNING: Gave up after $(( $wait_time * $max_attempts )) secs. awaiting for VM '$1' to power off"
            fi
        else
            echo "ERROR: Libvirt failed to shutdown VM $1!"
        fi
    fi

    return $domain_shutdown_status
}

# -----------------------------------------------------------------------------
# Returns a list with all persistent domains:
# -----------------------------------------------------------------------------
domains_list()
{
    echo $(virsh list --all --persistent --name)
}

###############################################################################
# POSIX Related Functions:
###############################################################################

# -----------------------------------------------------------------------------
# Retrieves checkpoints listed in .cpt file at a given backup path:
# -----------------------------------------------------------------------------
backup_checkpoint_list()
{
    echo $(cat $1/$(basename $1).cpt | sed -e 's/\[//g' -e 's/\"//g' -e 's/,//g' -e 's/\]//g')
}


# -----------------------------------------------------------------------------
# For a given checkpoint file, returns a string value with (restorable) virtual drives (separated by spaces) (e.g. "hdc hdd")
# -----------------------------------------------------------------------------
backup_restorable_drives_list()
{
    echo $(grep -e "checkpoint='bitmap'" $1 | cut -d"'" -f2)
}

# -----------------------------------------------------------------------------
# Looks for a given directory and returns 'yes' if empty:
# -----------------------------------------------------------------------------
dir_is_empty()
{
    find $1 -maxdepth 0 -empty -exec echo {} yes \;
}

# -----------------------------------------------------------------------------
# Returns a list of (ordered) bitmaps present into a given disk image:
# -----------------------------------------------------------------------------
disk_image_bitmap_list()
{
    echo $(sort_items $(qemu-img info $1 |  grep "name:" | rev | cut -d' ' -f1 | rev))
}

# -----------------------------------------------------------------------------
# From a given disk image, deletes a secific bitmap, returning the status of the command:
# -----------------------------------------------------------------------------
disk_image_delete_bitmap()
{
    qemu-img bitmap --remove $1 $2
    return $?
}

# -----------------------------------------------------------------------------
# Returns a random, uppercase, MAC address, based upon (optional) base pattern 'XX:XX:XX'
# -----------------------------------------------------------------------------
gen_random_macaddr()
{
    local seed=$1

    # If no base pattern is provided, will use a fixed parameter
    [[ -z $seed ]] && seed=$base_mac_addr

    printf '%s:%02X:%02X:%02X\n' ${seed^^} $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))
}

# -----------------------------------------------------------------------------
# Looks for a first concurrence of a given item into a given array name, returning the index if found and nothing if not found:
# -----------------------------------------------------------------------------
item_position()
{
    local searched_item=$1
    local array_name="$2[@]"

    local i=0
    for item in ${!array_name}; do

        [ $item == $searched_item ] && { echo $i; break; } || ((i++))
    done
}

# Returns a formatted string that is the last modified date and time:
# -----------------------------------------------------------------------------
last_modified()
{
    echo $(date -r $1 "+%Y-%m-%d %H:%M:%S")
}

# -----------------------------------------------------------------------------
# Patches a given xml file to provide incremental backups capability, returning sed status
# (Assumes the xml file has no patch):
# -----------------------------------------------------------------------------
patch_xml()
{
    # Modifies the XML file with sed, adding parameters as of virtnbdbackup documentation:
    sed -i -e "s|<domain type='kvm'>|<domain type='kvm' id='1' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'>|" -e "/<\/domain>/i \ \ <qemu:capabilities>\n      <qemu:add capability='incremental-backup'\/>\n  <\/qemu:capabilities>" $1

    return $?
}

# -----------------------------------------------------------------------------
# Guess OS name by kernel and returns a string with 'yes' if OS is Unraid, and otherwise 'no':
# -----------------------------------------------------------------------------
os_is_unraid()
#is_unraid()
{
    local is_unraid_status=1
    [[ ! -z $(uname  -r | grep -e "-Unraid$") ]] && echo "yes" || echo "no"
}

# -----------------------------------------------------------------------------
# From a given list, sorts unordered items lexicographically, with numbers naturally sorted:
# -----------------------------------------------------------------------------

sort_items()
{
    echo $@ | xargs -n1 | sort -V | xargs
}

###############################################################################
# Remote Commands & File Transfer Related Functions:
###############################################################################

# -----------------------------------------------------------------------------
# Sends a command string $2 via ssh to the server $1, returning the status of the operation:
#------------------------------------------------------------------------------
ssh_command()
{
    ssh $ssh_port -q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=$wait_time $1 $2
    return $?

}

# -----------------------------------------------------------------------------
# Sends a file $2 with scp to the server $1 at path $3, returning the status of the operation:
#------------------------------------------------------------------------------
scp_command()
{
    scp $ssh_port -q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=$wait_time $2 $1:$3
}

# -----------------------------------------------------------------------------
# Onto a local folder $3, mounts a remote folder located at $1:$2 via ssh, returning the status of the operation (to close the connection, only needs to 'umount $3'):
#------------------------------------------------------------------------------
sshfs_command()
{
    sshfs $ssh_port -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=$wait_time  $1:$2 $3
}

###############################################################################
# Display Related Functions;
###############################################################################

# -----------------------------------------------------------------------------
# Prompts a given question to the user, and returns either 'yes' or 'no':
# -----------------------------------------------------------------------------
yes_no()
{
    local question=$1
    local default_choice=$2
    local trailing_string="[yes/no]"
    local choice

    while true; do

        # Prompts and in case $default_choice was provided, it's displayed with upper caps:
        read -p "$question ${trailing_string/$default_choice/${default_choice^^}}: " choice

        case $choice in

            yes|YES|no|NO)

                echo ${choice,,}
                break
            ;;
            "")
                if [ ! -z $default_choice ]; then

                    echo $default_choice
                    break
                fi
            ;;
        esac

    done
}

# -----------------------------------------------------------------------------
# Prompts a given question to the user amd returns a number if is within (also given) parameters:
# -----------------------------------------------------------------------------
choose_number()
{
        local question=$1
        local min_choice=$2
        local max_choice=$3
        if [[ ! -z $4 ]] || [[ $min_choice -eq $max_choice ]]; then
            local default_choice=" (defaults to '$4')"
        fi
        local choice

    while true; do

        read -p "$question [$min_choice-$max_choice]$default_choice: " choice

        case $choice in

            [0-9])
                if [[ $choice -ge $min_choice ]] && [[ $choice -le $max_choice ]]; then

                    echo $choice
                    break
                fi
            ;;

            "")
                if [ ! -z $4 ]; then

                    echo $4
                    break
                fi
        esac
    done
}
