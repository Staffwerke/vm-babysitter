#!/bin/bash


# THIS SCIPT HOLDS ALL THE FUNCTIONS AND GLOBAL VARIABLES USED BY SCRIPTS

###############################################################################
# Common Variables:
###############################################################################
# Base MAC address used on the qemu/kvm implementation:
base_mac_addr="52:54:00"

# Maximum time to await for a response in certain functions:
wait_time=15

# Maximum number of attempts for a response in certain functions:
max_attempts=5

# SSH port can be omitted if 22. Otherwise, '-p <port_number>' :
ssh_port=""

###############################################################################
# Libvirt Related Functions:
###############################################################################

# -----------------------------------------------------------------------------
# Returns a list with existing checkpoints for a given VM according with libvirt.
# -----------------------------------------------------------------------------
domain_checkpoint_list()
{
    echo $(virsh checkpoint-list $1 --name --topological)
}

# -----------------------------------------------------------------------------
# Deletes specific checkpoints of a given VM. If '--all' argument is passed and no checkpoints are specified, deletes ALL checkpoints for such VM listed by libvirt.
# VM needs to be running or will fail):
# -----------------------------------------------------------------------------
domain_delete_checkpoint()
{
    local domain=$1
    shift
    local checkpoints_list=($@)

    # Second argument can be a single checkpoint, a list or '--all'
    [[ ${checkpoints_list[@]} == --all ]] && checkpoints_list=($(domain_checkpoint_list $domain))

    # VM must be running, or it won't work (as of QEMU 7.0.x):
    local vm_needed_state="running"

    if [[ $(domain_state $domain) == $vm_needed_state ]]; then

        if [[ ! -z ${checkpoints_list[@]} ]]; then

            echo "$domain: Removing ${#checkpoints_list[@]} checkpoint(s)..."

            for checkpoint in ${checkpoints_list[@]}; do
                &> /dev/null virsh checkpoint-delete $domain $checkpoint
            done
        else

            echo "$domain: Failed to proceed. Specify a list of specific checkpoints, or use option '--all' to remove all checkpoints"
        fi
    else
        echo "$domain: Failed to proceed. VM must be $vm_needed_state in order to delete checkpoints from QEMU and disk image(s)"
    fi

}

# -----------------------------------------------------------------------------
# Similar to 'domain_delete_checkpoint' but only deletes checkpoints metadata, and VM state is irrelevant:
# -----------------------------------------------------------------------------
domain_delete_checkpoint_metadata()
{
    local domain=$1
    shift
    local checkpoints_list=($@)

    # Second argument can be a single checkpoint, a list or '--all'
    [[ ${checkpoints_list[@]} == --all ]] && checkpoints_list=($(domain_checkpoint_list $domain))

    # Required to only delete QEMU metadata:
    local arguments="--metadata"

    if [[ ! -z ${checkpoints_list[@]} ]]; then

        echo "$domain: Removing ${#checkpoints_list[@]} checkpoint(s) metadata..."

        for checkpoint in ${checkpoints_list[@]}; do
            &> /dev/null virsh checkpoint-delete $domain $checkpoint $arguments
        done
    else

        echo "$domain: Failed to proceed. Specify a list of specific checkpoints, or use option '--all' to remove all checkpoints metadata"
    fi
}

#------------------------------------------------------------------------------
# Returns 'yes' or 'no' if domain exists and is persistent (not transient):
#------------------------------------------------------------------------------
domain_exists()
{
    [[ ! -z $(virsh list --all --name --persistent | grep -w "$1") ]] && echo "yes" || echo "no"
}

#------------------------------------------------------------------------------
# From a given domain, returns max ('--max')  or used ('--used') memory depending on the second argument (returns both separated with space if no argument is given):
#------------------------------------------------------------------------------
domain_getmem()
{

    local max_memory=$(virsh dominfo $1 | grep -e "Max memory:" | rev | cut -d ' ' -f2 | rev)
    local used_memory=$(virsh dominfo $1 | grep -e "Used memory:" | rev | cut -d ' ' -f2 | rev)
    local result

    if [[ -z $2 ]]; then
        result="$max_memory $used_memory"
    elif [[ $2 == --max ]]; then
        result=$max_memory
    elif [[ $2 == --used ]]; then
        result=$used_memory
    fi

    echo $result
}

# -----------------------------------------------------------------------------
# Returns a string value with the UUID of the given domain:
# -----------------------------------------------------------------------------
domain_id()
{
    echo $(virsh dominfo $1 | grep -w "UUID:" | rev | cut -d' ' -f1 | rev)
}

# -----------------------------------------------------------------------------
# For a given VM name, returns a string value with (restorable) virtual drives (separated by spaces) (e.g. "hdc hdd")
# -----------------------------------------------------------------------------
domain_drives_list()
{
    echo $(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/file//g' -e 's/disk//g' -e 's/ //g' | cut -d'/' -f1)
}

# -----------------------------------------------------------------------------
# For a given VM name, returns a string value with absoulte path to its image disks (e.g. "/path-to/hdc.img /path-to/hdd.img")
# -----------------------------------------------------------------------------
domain_img_paths_list()
{
    echo $(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/ file //g' -e 's/ disk //g' | rev | cut -d' ' -f1 | rev )
}

#------------------------------------------------------------------------------
# Returns 'yes' or 'no' about if domain does have 'incremental-backup' capability (accepts extra parameters via $2):
#------------------------------------------------------------------------------
domain_is_patched()
{
    [[ ! -z $(virsh dumpxml $1 $2 | grep "<qemu:add capability='incremental-backup'/>") ]] && echo "yes" || echo "no"
}

# -----------------------------------------------------------------------------
# Returns a string that is a space separated list of mac addresses of a given VM:
# -----------------------------------------------------------------------------
domain_macaddr_list()
{
    echo $(virsh domiflist --inactive $1 | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}')
}

#------------------------------------------------------------------------------
# Attempts a full power cycle onto a given domain. Returns '0' if success and '1' if it fails:
#------------------------------------------------------------------------------
domain_powercycle()
{
    local domain=$1
    local powercycle_domain_status=1

    echo "Performing power cycle to $domain ..."

    # Sends the shutdown signal to the given domain:
    virsh shutdown $domain

    if [[ $? -eq 0 ]]; then

        local attempt=0
        while (( $attempt < $MAX_ATTEMPTS )); do
            ((attempt++))
            # Awaits for the VM (qemu guest service, actually) for being on
            sleep $wait_time

            if [[ $(domain_state $domain) == "shut off" ]]; then

                break

            elif [[ $attempt -eq $max_attempts ]]; then

                echo "WARNING: Unable to determine if VM $domain was completely shut down. Starting $domain anyway..."

            fi
        done

        # Turns on the domain again:
        virsh start $target_domain
        [[ $? -eq 0 ]] && { powercycle_domain_status=0; echo "INFO: $domain successfully restarted"; } || echo "ERROR: User action is required: Verify VM $domain (or libvirt status) and restart the container (This VM could not be started to complete the power cycle)"

    else
        echo "ERROR: Could not perform a power cycle to $domain"
    fi

    return $powercycle_domain_status
}

#------------------------------------------------------------------------------
# From a given domain and size, changes max ('--max')  or used ('--used') according the 3rd argument (changes both if no argument is given.) Returns status '0' if sucess and '1' if any of the operations failed:
#------------------------------------------------------------------------------
domain_setmem()
{

    local domain_setmem_status=0

    if [[ -z $3 ]]; then

        for range in setmaxmem setmem; do
            > /dev/null virsh $range $1 $2 --config
            [[ $? -ne 0 ]] && domain_setmem_status=$?
        done

    elif [[ $3 == --max ]]; then

        > /dev/null virsh setmaxmem $1 $2 --config
        domain_setmem_status=$?

    elif [[ $3 == --used ]]; then

        > /dev/null virsh setmem $1 $2 --config
        domain_setmem_status=$?
    fi

    return $domain_setmem_status

}

# -----------------------------------------------------------------------------
# Sends shutdown signal and awaits (unless --nowait is passed) until domain has been shutted down to return success:
# -----------------------------------------------------------------------------
domain_shutdown()
{
    local domain_shutdown_status
    local vm_needed_state="shut off"

    if [[ $(domain_state $1) == $vm_needed_state ]]; then

        echo "INFO: VM '$1' is already $vm_needed_state"
        domain_shutdown_status=0
    else

        # VM is on. Send shutdown signal and catch status:
        virsh shutdown $1
        domain_shutdown_status=$?

        if [[ $domain_shutdown_status -eq 0 ]]; then

            # No extra arguments passed. Waits for effective shutdown of VM:
            if [[ $2 != --nowait ]]; then

                local went_to_shutdown
                local attempt=1
                while (( $attempt < $max_attempts )); do

                    sleep $wait_time

                    # Checks VM state to be effectively OFF:
                    [[ $(domain_state $1) == $vm_needed_state ]] && { went_to_shutdown=0; break; } || ((attempt++))
                done

                if [[ ! -z $went_to_shutdown ]]; then

                    echo "INFO: VM '$1' has been powered off successfully"
                else

                    domain_shutdown_status=1
                    echo "WARNING: Gave up after $(( $wait_time * $max_attempts )) secs. awaiting for VM '$1' to shut down"
                fi
            fi
        else
            echo "ERROR: Libvirt failed to shutdown VM $1!"
        fi
    fi

    return $domain_shutdown_status
}

#------------------------------------------------------------------------------
# Powers on a given domain and awaits (unless --nowait is passed) for internal qemu agent to return a response:
#------------------------------------------------------------------------------
domain_start()
{
    local domain_start_status
    local vm_needed_state="running"

    if [[ $(domain_state $1) == $vm_needed_state ]]; then

        echo "INFO: VM '$1' is already $vm_needed_state"
        domain_start_status=0
    else

        # Starts the VM if is powered off:
        virsh start $1
        domain_start_status=$?

        if [[ $domain_start_status -eq 0 ]]; then

            # No extra arguments passed. Waits for VM's QEMU agent response:
            if [[ $2 != --nowait ]]; then

                local attempt=1
                local agent_status
                while (( $attempt < $max_attempts )); do

                    sleep $wait_time

                    # (Silently) Gets VM output about its qemu agent:
                    > /dev/null virsh guestinfo $1
                    agent_status=$?

                    [[ $agent_status -eq 0 ]] && break || ((attempt++))
                done

                if [[ $agent_status -eq 0 ]]; then

                    echo "$1: Connected to QEMU agent"
                else
                    echo "WARNING: Gave up after $(( $wait_time * $max_attempts )) secs. awaiting for QEMU agent in VM $1. Ensure this service is installed and working on the guest OS to warrant concurrent data within backups."
                fi

            fi
        else
            echo "ERROR: ACTION REQUIRED: Libvirt failed to start VM $1!"
        fi
    fi

    return $domain_start_status
}

#------------------------------------------------------------------------------
# Returns a string value with the state reported by libvirt (e.g. "running", "shut off", etc.)
# -----------------------------------------------------------------------------
domain_state()
{
    echo $(virsh domstate $1)
}


# -----------------------------------------------------------------------------
# Returns a list with all persistent domains:
# -----------------------------------------------------------------------------
domains_list()
{
    echo $(virsh list --all --persistent --name)
}

###############################################################################
# Virtnbdbackup Related Functions:
###############################################################################

#------------------------------------------------------------------------------
# Creates a backup chain of given domain ($1) on $BACKUP_MAIN_PATH with given options
#------------------------------------------------------------------------------
do_backup_chain()
{
    # Status variable:
    local create_backup_chain_status=1

    # Consume initial arguments for each local variable below:

    # VM name:
    local domain=$1
    shift

    # Backup Mode: 'full' or 'inc'
    local backup_mode=$1
    shift

    # Full backup path:
    local backup_path=$1
    shift

    # Then, all remaining arguments (if any) are extra options passed to virtnbdbackup:
    local options=$@

    # Notifies the user about the ongoing process:
    echo ""
    echo "$domain: Started $backup_mode backup (this may take some time, or even look freezed...)"
    echo ""

    # Executes the operation:
    virtnbdbackup -d $domain -l $backup_mode -o $backup_path/$domain $options
    create_backup_chain_status=$?

    if [[ $create_backup_chain_status -eq 0 ]]; then

        echo "$domain: $backup_mode backup of successfully finished!"
    else

        echo "WARNING: $domain: virtnbdbackup failed with status $create_backup_chain_status. Read the logs above to determine the problem."

    fi

    return $create_backup_chain_status
}

###############################################################################
# POSIX Related Functions:
###############################################################################

# -----------------------------------------------------------------------------
# For a given backup_path, renames the current backup chain with a timestamp.
# If MAX_BACKUP_CHAINS_PER_VM or MAX_REMOTE_BACKUP_CHAINS_PER_VM are set,
# Deletes old backup chains except for the last ones in such variables:
# -----------------------------------------------------------------------------
archive_backup()
{

    local backup_path=$(dirname $1)
    local domain=$(basename $1)

    if [[ $MAX_BACKUP_CHAINS_PER_VM != 0 ]]; then

        # When env variable is not set, or greater than zero, archives the current backup chain with current timestamp name:
        local timestamp=$(date '+%Y-%m-%d.%H:%M:%S')
        mv $backup_path/$domain $backup_path/$domain.$timestamp
        echo "$domain: Latest backup chain archived as $backup_path/$domain.$timestamp"

        if [[ $MAX_BACKUP_CHAINS_PER_VM -ge 1 ]]; then

            # And when is greater than zero, deletes older backup chains, except the last ones as defined in the same variable:

            # Position of the first folder to delete, ordered from most recent timestamp
            local index=$( expr $MAX_BACKUP_CHAINS_PER_VM + 1 )

            # Creates a list with exact match of archived folders to delete (manually archived backup chains without this match aren't touched):
            local old_backups_list=($(find $backup_path -type d -name "$domain.*" | sort -r | grep -E "^$domain.[0-9]{4}-[0-9]{2}-[0-9]{2}.[0-9]{2}:[0-9]{2}:[0-9]{2}$" | tail -n +$index))

            if [[ ! -z ${old_backups_list[@]} ]]; then

                echo "$domain: Deleting old backup chains, except latest $MAX_BACKUP_CHAINS_PER_VM..."

                for old_backup in ${old_backups_list[@]}; do
                    echo "$old_backup"
                    rm -r $old_backup
                    done
            fi

        fi
    else

        # Env variable is 0. Remove backup chain directly:
        rm -rf $backup_path/$domain
        echo "$domain: Deleted backup chain at $backup_path/$domain (MAX_BACKUP_CHAINS_PER_VM = $MAX_BACKUP_CHAINS_PER_VM)"
    fi

    # To DO: REMOTE_MAX_BACKUP_CHAINS_PER_VM

}

# -----------------------------------------------------------------------------
# Retrieves checkpoints listed in .cpt file at a given backup path:
# -----------------------------------------------------------------------------
backup_checkpoint_list()
{
    local main_path=$1
    local cpt_file="$(basename $main_path).cpt"
    echo "$(cat $main_path/$cpt_file | sed -e 's/\[//g' -e 's/\"//g' -e 's/,//g' -e 's/\]//g')"
}


# -----------------------------------------------------------------------------
# For a given checkpoint file, returns a string value with (restorable) virtual drives (separated by spaces) (e.g. "hdc hdd")
# -----------------------------------------------------------------------------
backup_restorable_drives_list()
{
    echo $(grep -e "checkpoint='bitmap'" $1 | cut -d"'" -f2)
}

# -----------------------------------------------------------------------------
# Looks for a given directory and returns 'yes' if empty:
# -----------------------------------------------------------------------------
dir_is_empty()
{
    find $1 -maxdepth 0 -empty -exec echo {} yes \;
}

# -----------------------------------------------------------------------------
# Returns a list of (ordered) bitmaps present into a given disk image:
# -----------------------------------------------------------------------------
disk_image_bitmap_list()
{
    echo $(sort_items $(qemu-img info $1 |  grep "name:" | rev | cut -d' ' -f1 | rev))
}

# -----------------------------------------------------------------------------
# From a given disk image, deletes a secific bitmap, returning the status of the command:
# -----------------------------------------------------------------------------
disk_image_delete_bitmap()
{
    qemu-img bitmap --remove $1 $2
    return $?
}

# -----------------------------------------------------------------------------
# Returns a random, uppercase, MAC address, based upon (optional) base pattern 'XX:XX:XX'
# -----------------------------------------------------------------------------
gen_random_macaddr()
{
    local seed=$1

    # If no base pattern is provided, will use a fixed parameter
    [[ -z $seed ]] && seed=$base_mac_addr

    printf '%s:%02X:%02X:%02X\n' ${seed^^} $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))
}

# -----------------------------------------------------------------------------
# Looks for a first concurrence of a given item into a given array name, returning the index if found and nothing if not found:
# -----------------------------------------------------------------------------
item_position()
{
    local searched_item=$1
    local array_name="$2[@]"

    local i=0
    for item in ${!array_name}; do

        [ $item == $searched_item ] && { echo $i; break; } || ((i++))
    done
}

# Returns a formatted string that is the last modified date and time:
# -----------------------------------------------------------------------------
last_modified()
{
    echo $(date -r $1 "+%Y-%m-%d %H:%M:%S")
}

# -----------------------------------------------------------------------------
# Patches a given xml file to provide incremental backups capability, returning sed status
# (Assumes the xml file has no patch):
# -----------------------------------------------------------------------------
patch_xml()
{
    # Modifies the XML file with sed, adding parameters as of virtnbdbackup documentation:
    sed -i -e "s|<domain type='kvm'>|<domain type='kvm' id='1' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'>|" -e "/<\/domain>/i \ \ <qemu:capabilities>\n      <qemu:add capability='incremental-backup'\/>\n  <\/qemu:capabilities>" $1

    return $?
}

# -----------------------------------------------------------------------------
# Guess OS name by kernel and returns a string with 'yes' if OS is Unraid, and otherwise 'no':
# -----------------------------------------------------------------------------
os_is_unraid()
#is_unraid()
{
    local is_unraid_status=1
    [[ ! -z $(uname  -r | grep -e "-Unraid$") ]] && echo "yes" || echo "no"
}

# -----------------------------------------------------------------------------
# From a given list, sorts unordered items lexicographically, with numbers naturally sorted:
# -----------------------------------------------------------------------------

sort_items()
{
    echo $@ | xargs -n1 | sort -V | xargs
}

###############################################################################
# Remote Commands & File Transfer Related Functions:
###############################################################################

# -----------------------------------------------------------------------------
# Sends a command string $2 via ssh to the server $1, returning the status of the operation:
#------------------------------------------------------------------------------
ssh_command()
{
    ssh $ssh_port -q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=$wait_time $1 $2
    return $?

}

# -----------------------------------------------------------------------------
# Sends a file $2 with scp to the server $1 at path $3, returning the status of the operation:
#------------------------------------------------------------------------------
scp_command()
{
    scp $ssh_port -q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=$wait_time $2 $1:$3
}

# -----------------------------------------------------------------------------
# Onto a local folder $3, mounts a remote folder located at $1:$2 via ssh, returning the status of the operation (to close the connection, only needs to 'umount $3'):
#------------------------------------------------------------------------------
sshfs_command()
{
    sshfs $ssh_port -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=$wait_time  $1:$2 $3
}

###############################################################################
# Display Related Functions;
###############################################################################

# -----------------------------------------------------------------------------
# Prompts a given question to the user, and returns either 'yes' or 'no':
# -----------------------------------------------------------------------------
yes_no()
{
    local question=$1
    local default_choice=$2
    local trailing_string="[yes/no]"
    local choice

    while true; do

        # Prompts and in case $default_choice was provided, it's displayed with upper caps:
        read -p "$question ${trailing_string/$default_choice/${default_choice^^}}: " choice

        case $choice in

            yes|YES|no|NO)

                echo ${choice,,}
                break
            ;;
            "")
                if [ ! -z $default_choice ]; then

                    echo $default_choice
                    break
                fi
            ;;
        esac

    done
}

# -----------------------------------------------------------------------------
# Prompts a given question to the user amd returns a number if is within (also given) parameters:
# -----------------------------------------------------------------------------
choose_number()
{
        local question=$1
        local min_choice=$2
        local max_choice=$3
        if [[ ! -z $4 ]] || [[ $min_choice -eq $max_choice ]]; then
            local default_choice=" (defaults to '$4')"
        fi
        local choice

    while true; do

        read -p "$question [$min_choice-$max_choice]$default_choice: " choice

        case $choice in

            [0-9])
                if [[ $choice -ge $min_choice ]] && [[ $choice -le $max_choice ]]; then

                    echo $choice
                    break
                fi
            ;;

            "")
                if [ ! -z $4 ]; then

                    echo $4
                    break
                fi
        esac
    done
}
