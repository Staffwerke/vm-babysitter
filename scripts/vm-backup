#!/bin/bash

# Usage: vm-backup [--run-schedule] [--create-new] [domain1 domain2...]
# Runs virtnbdbackup to create/update backup chains of domains to LOCAL_BACKUP_PATH, from either:
# - A given list of domains passed as arguments,
# - All domains currently scheduled for backups, if '--run-schedule' is passed as the only argument, or
# - Creates new backup chains if '--create-new ' is passed as first argument, and then all domains as further arguments (forcing retention policy appliance in the process)

display_summary()
{
    echo "____________________________________________________________________________________________________________"
    echo -e "$backup_action Backup Summary:\n"
    echo "Successful backups:    ${backup_success_list[@]:-"None"}"
    echo "Failed backups:        ${backup_failed_list[@]:-"None"}"
    echo "Skipped (missing VMs): ${backup_skipped_list[@]:-"None"}"

    if [[ $on_demand_rsync ]]; then

        # Only show remote stats when remote endppoint is set:
        echo "____________________________________________________________________________________________________________"
        echo -e "$backup_action Rsync summary:\n"
        echo "Successful syncs: ${rsync_success_list[@]:-"None"}"
        echo "Failed to sync:   ${rsync_failed_list[@]:-"None"}"
    fi

    if [[ $(os_is_unraid) ]]; then

        # Notifies via Unraid about the results:
        if [[ -z ${backup_failed_list[@]} \
            && -z ${rsync_failed_list[@]} \
            && -z ${backup_skipped_list[@]} ]]; then

            unraid_notify "normal" "VM-Babysitter" "$backup_action Backup" "Finished Successfully"

        else
            [[ -n ${backup_skipped_list[@]} ]] \
                && unraid_notify "warning" "VM-Babysitter" "$backup_action Backup" "Unable to find VM(s): ${backup_skipped_list[@]} and therefore removed from schedule (maybe deleted by the user?) "

            [[ -n ${backup_failed_list[@]} ]] \
                && unraid_notify "warning" "VM-Babysitter" "$backup_action Backup finished with errors" "Could not perform backup(s) for: ${backup_failed_list[@]}"

            [[ -n ${rsync_failed_list[@]} ]] \
                && unraid_notify "warning" "VM-Babysitter" "$backup_action Rsync finished with errors" "Could not sync backup chain(s) of: ${rsync_failed_list[@]}"
        fi
    fi
}

# Load common functions:
source $functions_path

case $1 in

    --create-new)

            # Creates new backup chains of VMs in need of it (passed as arguments),
            # during container start or when a new VM is detected, appending/exporting VMs to their correspondent lists,
            # depending on the result:
            backup_action="Initial"

            # Forces to read from the 2nd argument, where the (first) VM is expected to be declared:
            shift

            # Virtnbdbackup mode is set to 'full':
            backup_mode="full"

            # Populates the backups list from VMs passed as (remaining) arguments:
            backups_list=($@)
    ;;

    --run-schedule)

        # Performs backups from SCHEDULED_BACKUPS_LIST when called via cron,
        # updating/exporting correspondent lists, depending on the results (included deleted VMs):
        backup_action="Scheduled"

        # Processes initial backups list from SCHEDULED_BACKUPS_LIST in external variables file:
        source $external_vars
        backups_list=(${SCHEDULED_BACKUPS_LIST[@]})

        # Virtnbdbackup mode is set to 'auto':
        backup_mode="auto"

        # On Scheduled mode, force '--no-color' for more clarity in log files:
        [[ -z $(grep -o -e "--nocolor" <<< "$VIRTNBDBACKUP_ARGS") ]] \
            && VIRTNBDBACKUP_ARGS="$VIRTNBDBACKUP_ARGS --nocolor"

        # Display initial message to be appended into log file:
        echo "############################################################################################################"
        echo "$backup_action Backup started at: $(date "+%Y-%m-%d %H:%M:%S")"
        echo "############################################################################################################"
    ;;

    *)
        # Without flags, the script performs 'on-demand' backups of the VMs passed as arguments. No lists are updated or exported.
        # Is mostly for test/debugging purposes, so use with care:

        # TODO: Add user confirmation action.
        backup_action="On-demand"

        # Virtnbdbackup mode is set to 'auto':
        backup_mode="auto"

        # Processes initial backups list from VMs (as arguments):
        backups_list=($@)
    ;;
esac

if [[ -n ${backups_list[@]} ]]; then

    # Notify via Unraid about the start of a scheduled process:
    [[ $(os_is_unraid) ]] \
        && unraid_notify "normal" "VM-Babysitter" "$backup_action Backup" "In progress for ${backups_list[@]}. Avoid to stop/restart this container until further notice"

    for domain in ${backups_list[@]}; do

        # Display screen divider when processing several backup chains:
        [[ ${#backups_list[@]} -gt 1 ]] \
            && echo "____________________________________________________________________________________________________________"

        if [[ $(domain_exists $domain) == yes ]]; then

            # When backup action is to create a new backup chain, force the application of retention policy, prior to perform the backup operation:
            [[ $backup_action == "Initial" ]] && force_retention_policy="--force"

            vm-retention-policy $force_retention_policy $domain

            # Under specific scenario of new backup chain and powered off VMs, force --start-server to turn on the VM in paused mode:
            if [[ ! -d $LOCAL_BACKUP_PATH/$domain || $(dir_is_empty $LOCAL_BACKUP_PATH/$domain) == yes ]] \
            && [[ $(domain_state $domain) == "shut off" && -z $(grep -o -e "-S" -e "--start-domain" <<< "$VIRTNBDBACKUP_ARGS") ]]; then

                start_domain="--start-domain"
            fi

            # Perform the backup operation:
            virtnbdbackup $start_domain -d $domain -l $backup_mode -o $LOCAL_BACKUP_PATH/$domain $VIRTNBDBACKUP_ARGS

            # Get last status for virtnbdbackup:
            virtnbdbackup_exit_code=$?

            if [[ $virtnbdbackup_exit_code -eq 0 ]]; then

                # Backup chain creation was successful!
                backup_success_list+=($domain)

            else
                # Failed to create a new backup chain:
                backup_failed_list+=($domain)
            fi

        else
            # Create a separated list of 'lost' VMs, and prompt about the unexpected error
            backup_skipped_list+=($item)
            echo "$domain: There is no VM to backup (skipped)"
        fi
    done

    if [[ -n ${backup_success_list[@]} && -n $RSYNC_BACKUP_PATH ]]; then

        # Activate rsync mode:
        on_demand_rsync=1

        for domain in ${backup_success_list[@]}; do

            # Display screen divider when processing several backup chains:
            [[ ${#backup_success_list[@]} -gt 1 ]] \
                && echo "____________________________________________________________________________________________________________"

            # Attempts to transfer changes via rsync:
            vm-rsync $domain

            # Get last status for rsync:
            rsync_exit_code=$?

            if [[ $rsync_exit_code -eq 0 ]]; then

                # Rsync exited normally:
                rsync_success_list+=($domain)
            else
                # Rsync failed:
                rsync_failed_list+=($domain)
            fi
        done
    fi

else
    echo "No Virtual machines for $backup_action Backup to process (exited)"
fi

case $backup_action in

    "Initial")

        # Append VM(s) to the correspondent lists to be exported.
        # (is assumed that VM(s) still don't exist into any list):
        FAILED_VMS_LIST+=(${backup_failed_list[@]})
        SCHEDULED_BACKUPS_LIST+=(${backup_success_list[@]})

        # Export all variables:
        sed -i \
        -e "s/FAILED_VMS_LIST=.*/FAILED_VMS_LIST=(${FAILED_VMS_LIST[@]})/" \
        -e "s/SCHEDULED_BACKUPS_LIST=.*/SCHEDULED_BACKUPS_LIST=(${SCHEDULED_BACKUPS_LIST[@]})/" \
        $external_vars

        # Show results on screen and log file:
        display_summary
    ;;

    "Scheduled")

        # VMs in backup_success_list are assumed to always exist in SCHEDULED_BACKUPS_LIST.

        if [[ -n ${backup_failed_list[@]} || -n ${backup_skipped_list[@]} ]]; then

            # When some VM is into one of these lists, it must be removed from SCHEDULED_BACKUPS_LIST,
            # appended to FAILED_VMS_LIST if failed.

            # Load SCHEDULED_BACKUPS_LIST FAILED_VMS_LIST again, in case other VMs were appended somewhere during this run:
            source $external_vars

            for vm in ${backup_failed_list[@]} ${backup_skipped_list[@]}; do

                # If any, delete each failed or skipped VM from the list:
                unset SCHEDULED_BACKUPS_LIST[$(item_position $vm "SCHEDULED_BACKUPS_LIST")]

                # Rebuild the array upon each iteration:
                SCHEDULED_BACKUPS_LIST=(${SCHEDULED_BACKUPS_LIST[@]})
            done

            # Append failed VMs to its correspondent list to be exported:
            FAILED_VMS_LIST+=(${backup_failed_list[@]})

            # Export all variables:
            sed -i \
            -e "s/FAILED_VMS_LIST=.*/FAILED_VMS_LIST=(${FAILED_VMS_LIST[@]})/" \
            -e "s/SCHEDULED_BACKUPS_LIST=.*/SCHEDULED_BACKUPS_LIST=(${SCHEDULED_BACKUPS_LIST[@]})/" \
            $external_vars
        fi

        # Show results into log file:
        display_summary

        # Append the ending date and time into log file:
        echo -e "\n$backup_action Backup ended at: $(date "+%Y-%m-%d %H:%M:%S")\n"
    ;;

    "On-demand")

        # When multiple backups chains were processed, display that the script has finished:
        [[ ${#backups_list[@]} -gt 1 ]] \
            && echo -e "\n$(basename $0): Finished"
    ;;
esac

