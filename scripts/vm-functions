#!/bin/bash


# THIS SCIPT HOLDS ALL THE FUNCTIONS AND GLOBAL VARIABLES USED BY SCRIPTS

###############################################################################
# Common Variables:
###############################################################################
# Base MAC address used on the qemu/kvm implementation:
base_mac_addr="52:54:00"

###############################################################################
# Libvirt Related Functions:
###############################################################################

# -----------------------------------------------------------------------------
# Returns a list with existing checkpoints for a given VM according with libvirt.
# -----------------------------------------------------------------------------
domain_checkpoint_list()
{
    echo $(virsh checkpoint-list $1 --name --topological)
}

# -----------------------------------------------------------------------------
# Deletes specific checkpoints of a given VM, or all if '--all' argument is passed instead.
# 'virsh checkpoint-delete' arguments are also processed:
# -----------------------------------------------------------------------------
domain_delete_checkpoint()
{
    local domain
    local checkpoints_list
    local delete_all_checkpoints
    local delete_options
    local vm_needed_state

    # First argument is always domain name:
    domain=$1
    shift

    # Remaining arguments are processed as they come:
    while [[ $@ != "" ]]; do

        case $1 in

            # Delete option, parsed as is:
            --children | --children-only | --metadata)
                delete_options+=($1)
            ;;
            # Indicates to delete all checkpoints found, instead of processing checkpoints_list:
            --all)
                delete_all_checkpoints="TRUE"
            ;;
            # Any other value is taken as a checkpoint name, therefore added in checkpoints_list:
            *)
                checkpoints_list+=($1)
            ;;
        esac

        # Shifts to the next argument:
        shift
    done

    # VMs must be running in order to delete checkpoints, except when '--metadata' argument is passed:
    if [[ ! ${delete_options[@]} =~ "--metadata" ]] && [[ $(domain_state $domain) != "running" ]]; then

        echo "$domain: Failed to proceed. VM must be $vm_needed_state in order to delete checkpoints from QEMU and disk image(s) simultaneously"
        exit 1
    fi

    # '--all' argument was passed. Search for all checkpoints in this VM:
    [[ ! -z $delete_all_checkpoints ]] && checkpoints_list=($(domain_checkpoint_list $domain))

    if [[ ! -z ${checkpoints_list[@]} ]]; then

        echo "$domain: Removing ${#checkpoints_list[@]} checkpoint(s)..."

        for checkpoint in ${checkpoints_list[@]}; do
            &> /dev/null virsh checkpoint-delete $domain $checkpoint ${delete_options[@]}
        done
    else
        echo "$domain: No checkpoints to delete"
    fi
}

#------------------------------------------------------------------------------
# Returns 'yes' or 'no' if domain exists and is persistent (not transient):
#------------------------------------------------------------------------------
domain_exists()
{
    [[ ! -z $(virsh list --all --name --persistent | grep -w "$1") ]] && echo "yes" || echo "no"
}

#------------------------------------------------------------------------------
# From a given domain, returns max ('--max')  or used ('--used') memory depending on the second argument (returns both separated with space if no argument is given):
#------------------------------------------------------------------------------
domain_getmem()
{

    local max_memory=$(virsh dominfo $1 | grep -e "Max memory:" | rev | cut -d ' ' -f2 | rev)
    local used_memory=$(virsh dominfo $1 | grep -e "Used memory:" | rev | cut -d ' ' -f2 | rev)
    local result

    if [[ -z $2 ]]; then
        result="$max_memory $used_memory"
    elif [[ $2 == --max ]]; then
        result=$max_memory
    elif [[ $2 == --used ]]; then
        result=$used_memory
    fi

    echo $result
}

# -----------------------------------------------------------------------------
# Returns a string value with the UUID of the given domain:
# -----------------------------------------------------------------------------
domain_id()
{
    echo $(virsh dominfo $1 | grep -w "UUID:" | rev | cut -d' ' -f1 | rev)
}

# -----------------------------------------------------------------------------
# For a given VM name, returns a string value with (restorable) virtual drives (separated by spaces) (e.g. "hdc hdd")
# -----------------------------------------------------------------------------
domain_drives_list()
{
    echo $(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/file//g' -e 's/disk//g' -e 's/ //g' | cut -d'/' -f1)
}

# -----------------------------------------------------------------------------
# For a given VM name, returns a string value with absoulte path to its image disks (e.g. "/path-to/hdc.img /path-to/hdd.img")
# -----------------------------------------------------------------------------
domain_img_paths_list()
{
    echo $(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/ file //g' -e 's/ disk //g' | rev | cut -d' ' -f1 | rev )
}

#------------------------------------------------------------------------------
# Returns 'yes' or 'no' about if domain does have 'incremental-backup' capability (accepts extra parameters via $2):
#------------------------------------------------------------------------------
domain_is_patched()
{
    [[ ! -z $(virsh dumpxml $1 $2 | grep "<qemu:add capability='incremental-backup'/>") ]] && echo "yes" || echo "no"
}

# -----------------------------------------------------------------------------
# Returns a string that is the loader path of a given VM, passed as argument:
# -----------------------------------------------------------------------------
domain_loader_path()
{
    local domain=$1
    echo $(virsh dumpxml --inactive --security-info $domain | grep -e "<loader" | cut -d'>' -f2 | cut -d '<' -f1)
}

# -----------------------------------------------------------------------------
# Returns a string that is a space separated list of mac addresses of a given VM:
# -----------------------------------------------------------------------------
domain_macaddr_list()
{
    echo $(virsh domiflist --inactive $1 | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}')
}

# -----------------------------------------------------------------------------
# Returns a string that is the nvram path of either an existing vm or the full path to an xml definition file.
# Argument type (vm or xml file path) is detected automatically:
# -----------------------------------------------------------------------------
domain_nvram_path()
{
    local message

    if [[ $(domain_exists $1) == yes ]]; then

        message=$(virsh dumpxml --inactive --security-info $1 | grep -e "<nvram>" | cut -d'>' -f2 | cut -d '<' -f1)

    elif [[ -f $1 ]]; then

        message=$(grep -e "<nvram>" $1 | cut -d'>' -f2 | cut -d '<' -f1)
    fi

    echo $message
}

#------------------------------------------------------------------------------
# Attempts a full power cycle onto a given domain, waiting for a determined '--wait' time in seconds (default is 60 secs).
# Returns '0' if success and '1' if it fails:
#------------------------------------------------------------------------------
domain_powercycle()
{
    local powercycle_status
    local shutdown_status
    local start_status

    # 1st argument is always domain:
    local domain=$1
    shift

    # 2nd argument is '--wait' and third is an integer. Otherwise defaults to 60:
    if [[ $1 == --wait ]] && [[ $2 =~ [0-9] ]]; then

        # 2nd argument is --wait and 3rd argument the time to wait, in seconds:
        local wait_time=$2

    else
        # In any other scenario, override a default value of 60 seconds:
        local wait_time="60"
    fi

    echo "$domain: Performing a full power cycle..."

    # Sends the shutdown signal to the given domain:
    virsh shutdown $domain
    shutdown_status=$?

    if [[ $shutdown_status -eq 0 ]]; then

        # Command was sent successfully.
        # A matter of query periodically during wait_time, until domain is actually reported shut off:

        local counter=0
        while (( $counter < $wait_time )); do

            # Increases the counter:
            ((counter++))
            if [[ $(domain_state $domain) == "shut off" ]]; then

                echo "$domain: Went shut down successfully after $counter seconds"
                break

            elif [[ $counter -eq $wait_time ]]; then

                powercycle_status=2
                echo "WARNING: VM $domain did not shut down after $wait_time seconds. This mean either a longer awaiting time should be set, or there are issues with this VM"
            fi
            # Sleep for one second:
            sleep 1
        done

        if [[ -z $powercycle_status ]]; then

            # Turn on the domain:
            virsh start $domain
            start_status=$?

            if [[ $start_status -eq 0 ]]; then

                powercycle_status=0
                echo "$domain: Power cycle completed successfully"

            else
                powercycle_status=1
                echo "ERROR: Libvirt failed to start VM $domain after shut down"
            fi
        fi

    else
        powercycle_status=1
        echo "ERROR: Libvirt failed to shut down VM $domain"
    fi

    return $powercycle_status
}

#------------------------------------------------------------------------------
# From a given domain and size(s) and/or flags, sets VM RAM. If both max and used ram sizes are passed, configures each. If one value and '--max' or '--used' are passed, configures according the flag. If one size is passed with no flag, configures both max and used the same. Returns status '0' if sucess and '1' if any of the operations failed:
#------------------------------------------------------------------------------
domain_setmem()
{
    local domain=$1                             # First argument is always VM
    shift
    local parameter_list=($@)                   # Remaining parameters are expected to be a string:
                                                # index 0 is always asumed as integer (RAM value in KiB)
                                                # index 1 can be another integer RAM value, a flag or null.
    shift
    local command_list=("setmaxmem" "setmem")   # index o is max RAM, index 1 is used RAM

    local domain_setmem_status=0

    # What defines the course of action is the value in index 1:
    case ${parameter_list[1]} in

        --max) # Assumes index 0 as max memory:
            virsh ${command_list[0]} $domain ${parameter_list[0]} --config
            domain_setmem_status=$?
        ;;

        --used) # index 0 as used memory:
            virsh ${command_list[1]} $domain ${parameter_list[0]} --config
            domain_setmem_status=$?
        ;;

        "") # Assumes index 0 as both, max and used memory (updates status if fails):
            for set in ${command_list[@]}; do
                virsh $set $domain ${parameter_list[0]} --config || domain_setmem_status=$?
            done
        ;;

        *) # Assumes index 0 as max memory and index 1 as used memory (updates status if fails):
            local i=0
            for set in ${command_list[@]}; do
                virsh $set $domain ${parameter_list[$i]} --config || domain_setmem_status=$?
                ((i++))
            done
        ;;
        esac

    return $domain_setmem_status
}

# -----------------------------------------------------------------------------
# Sends shutdown signal to a given domain, and awaits for '--wait' seconds or '--nowait' until domain has been shutted down to return success/fail:
# -----------------------------------------------------------------------------
domain_shutdown()
{
    local domain_shutdown_status

    local domain=$1
    shift

    case $1 in
        --wait)
            # When last argument is an integer, takes its value. Otherwise defaults to 60 secs:
            [[ $2 =~ [0-9] ]] && wait_time=$2 || local wait_time="60"
        ;;
        --nowait)
            wait_time=0
        ;;
        *)
            # Ignores any other arg and defaults to 60 secs.
            local wait_time="60"
    esac

    local vm_needed_state="shut off"

    if [[ $(domain_state $domain) == $vm_needed_state ]]; then

        echo "$domain: is already $vm_needed_state"
        domain_shutdown_status=0
    else

        # VM is on. Send shutdown signal and catch status:
        virsh shutdown $domain
        domain_shutdown_status=$?

        if [[ $domain_shutdown_status -eq 0 ]]; then

            if [[ $wait_time -gt 0 ]]; then

                local went_to_shutdown

                local counter=0
                while (( $counter < $wait_time )); do

                    ((counter++))

                    # Checks VM state to be effectively OFF:
                    [[ $(domain_state $domain) == $vm_needed_state ]] && { went_to_shutdown=1; break; } || sleep 1
                done

            fi

            if [[ $wait_time -eq 0 ]] || [[ ! -z $went_to_shutdown ]]; then

                    echo "$domain: Has been shut down successfully"

            elif [[  -z $went_to_shutdown ]]; then

                domain_shutdown_status=1
                echo "WARNING: Gave up after $wait_time seconds awaiting for VM '$domain' to be shut down"
            fi
        else
            echo "ERROR: Libvirt failed to shut down VM $domain"
        fi
    fi

    return $domain_shutdown_status
}

#------------------------------------------------------------------------------
# Powers on a given domain and awaits for '--wait' seconds or '--nowait' for internal qemu agent to return a response:
#------------------------------------------------------------------------------
domain_start()
{
    local domain_start_status

    local domain=$1
    shift

    case $1 in
        --wait)
            # When last argument is an integer, takes its value. Otherwise defaults to 60 secs:
            [[ $2 =~ [0-9] ]] && wait_time=$2 || local wait_time="60"
        ;;
        --nowait)
            wait_time=0
        ;;
        *)
            # Ignores any other arg and defaults to 60 secs.
            local wait_time=60
    esac

    local vm_needed_state="running"
    local agent_status

    if [[ $(domain_state $domain) == $vm_needed_state ]]; then

        echo "$domain: is already $vm_needed_state"
        domain_start_status=0
    else

        # Starts the VM if is powered off:
        virsh start $domain
        domain_start_status=$?

        if [[ $domain_start_status -eq 0 ]]; then

            if [[ $wait_time -gt 0 ]]; then

                local agent_status
                local counter=0
                while (( $counter < $wait_time )); do

                    ((counter++))

                    # (Silently) Gets VM output about its qemu agent:
                    &> /dev/null virsh guestinfo $domain
                    agent_status=$?

                    if [[ $agent_status -eq 0 ]]; then

                        echo "$domain: Connected to QEMU agent"
                        break
                    else
                        sleep 1
                    fi
                done
            fi

            if [[ $agent_status -eq 0 ]] || [[ $wait_time -gt 0 ]]; then

                echo "$domain: Started successfully"

            elif [[ $agent_status -ne 0 ]]; then
                echo "WARNING: Gave up after $wait_time seconds awaiting for QEMU agent in VM '$domain'. Ensure this service is installed on the guest OS, and configured at VM definitions in order to warrant concurrent data within backups."
            fi
        else
            echo "ERROR: Libvirt failed to start VM $domain"
        fi
    fi

    return $domain_start_status
}

#------------------------------------------------------------------------------
# Returns a string value with the state reported by libvirt (e.g. "running", "shut off", etc.)
# -----------------------------------------------------------------------------
domain_state()
{
    echo $(virsh domstate $1)
}


# -----------------------------------------------------------------------------
# Returns a list with all persistent domains:
# -----------------------------------------------------------------------------
domains_list()
{
    echo $(virsh list --all --persistent --name)
}

###############################################################################
# Virtnbdbackup Related Functions:
###############################################################################

#------------------------------------------------------------------------------
# Creates a backup chain of given domain ($1) on $BACKUP_MAIN_PATH with given options
#------------------------------------------------------------------------------
do_backup_chain()
{
    # Status variable:
    local create_backup_chain_status=1

    # Consume initial arguments for each local variable below:

    # VM name:
    local domain=$1
    shift

    # Backup Mode: 'full' or 'inc'
    local backup_mode=$1
    shift

    # Full backup path:
    local backup_path=$1
    shift

    # Then, all remaining arguments (if any) are extra options passed to virtnbdbackup:
    local options=$@

    # Notifies the user about the ongoing process:
    echo ""
    echo "$domain: Started $backup_mode backup (this may take some time, or even look freezed...)"
    echo ""

    # Executes the operation:
    virtnbdbackup -d $domain -l $backup_mode -o $backup_path/$domain $options
    create_backup_chain_status=$?

    if [[ $create_backup_chain_status -eq 0 ]]; then

        echo ""
        echo "$domain: $backup_mode backup successfully finished!"
    else

        echo ""
        echo "WARNING: $domain: virtnbdbackup failed with status $create_backup_chain_status. Read the logs above for more details"

    fi

    return $create_backup_chain_status
}

###############################################################################
# POSIX Related Functions:
###############################################################################

# -----------------------------------------------------------------------------
# Renames a backup folder (backup_path/domain) given as first argument
# Second argument, when passed, is the max # of old backup chains with same timestamp,
# and implies retention policy:
# -----------------------------------------------------------------------------
archive_backup()
{
    # Local folder to be manipulated:
    local backup_path=$(dirname $1)

    # VM name basename:
    local domain=$(basename $1)

    # Generate an updated time stamp to rename archived backups:
    local timestamp=$(date '+%Y-%m-%d.%H:%M:%S')

    # Archives the current backup chain, by renaming it with time stamp:
    mv $backup_path/$domain $backup_path/$domain.$timestamp
    echo "$domain: Current backup chain archived as $backup_path/$domain.$timestamp"

    if [[ ! -z $2 ]]; then

    # Second argument, when passed, triggers retention policy,
    # preserving as many old backup chains as the integer value is:
    local backups_to_keep=$2
    echo "Applying local retention policy..."

    # Position of the first folder to delete, ordered from most recent timestamp:
    local index=$( expr $backups_to_keep + 1 )

    # Creates a list with EXACT match of archived folder(s) to delete.
    # Pattern is based upon $(date '+%Y-%m-%d.%H:%M:%S'):
    local old_backups_list=($(find $backup_path -type d -name "$domain.*" | sort -r | grep -E "^$backup_path/$domain.[0-9]{4}-[0-9]{2}-[0-9]{2}.[0-9]{2}:[0-9]{2}:[0-9]{2}$" | tail -n +$index))

        if [[ ! -z ${old_backups_list[@]} ]]; then

            # Deletes all folders in the above generated list:
            echo "$domain: Deleting ${#old_backups_list[@]} old backup chain(s)..."
            rm -rf ${old_backups_list[@]}
        else
            echo "$domain: No old backup chains to delete by now"
        fi
    fi
}

# -----------------------------------------------------------------------------
# Similar with 'archive_backup' but operates on a remote endpoint via SSH:
# Returns SSH error status if fails attempt to connect:
# -----------------------------------------------------------------------------
archive_remote_backup()
{
    # Remote server (user@host format):
    local remote_server=$(echo $1 | cut -d':' -f1)

    # Remote folder to be manipulated:
    local remote_backup_path=$(echo $1 | cut -d':' -f2)

    # Main backup path where remote backup is located:
    local remote_main_backup_path=$(dirname $remote_backup_path)

    # VM name basename:
    local domain=$(basename $remote_backup_path)

    # Attempts to comunicate with the remote host:
    ssh $SSH_OPTIONS $remote_server "exit 0"
    local remote_server_status=$?

    if [[ $remote_server_status -eq 0 ]]; then

        # Remote Server is reachable.

        # Generate an updated time stamp to rename archived backups:
        local timestamp=$(date '+%Y-%m-%d.%H:%M:%S')

        # Checks in advance if remote backup path exists or not:
        local remote_backup_chain_exists=$(ssh $SSH_OPTIONS $remote_server "[[ -d $remote_backup_path ]] && echo \"yes\" || echo \"no\"")

        if [[ $remote_backup_chain_exists == "yes" ]]; then

            # Archive remote backup chain:
            ssh $SSH_OPTIONS $remote_server "mv $remote_backup_path $remote_backup_path.$timestamp"
            echo "$domain: Current backup chain at $remote_server renamed as $remote_backup_path.$timestamp"


        elif [[ $remote_backup_chain_exists == "no" ]]; then

            echo "$domain: No current backup chain(s) found at $remote_server"
        fi

        if [[ ! -z $2 ]]; then

            # When a second argument is passed, takes it as the max # of backup chains to keep remotely:
            local remote_backups_to_keep=$2
            echo "Applying remote retention policy on $remote_server..."

            # Position of the first folder to delete, ordered from most recent timestamp
            local index=$( expr $remote_backups_to_keep + 1 )

            # Creates a list with EXACT match of archived folder(s) to delete.
            # Pattern is based upon $(date '+%Y-%m-%d.%H:%M:%S'):
            local remote_old_backups_list=($(ssh $SSH_OPTIONS $remote_server "find $remote_main_backup_path -type d -name \"$domain.*\" | sort -r | grep -E \"^$remote_main_backup_path/$domain.[0-9]{4}-[0-9]{2}-[0-9]{2}.[0-9]{2}:[0-9]{2}:[0-9]{2}$\" | tail -n +$index"))

            if [[ ! -z ${remote_old_backups_list[@]} ]]; then

                # Deletes all folders in the above generated list:
                echo "$domain: Deleting ${#remote_old_backups_list[@]} old backup chain(s)..."
                ssh $SSH_OPTIONS $remote_server "rm -rf ${remote_old_backups_list[@]}"

            else
                echo "$domain: No old backup chains to delete by now"
            fi
        fi
    else

        # Returns status of failed connection:
        echo "WARNING: Remote endpoint $remote_server is currently unreachable (status: $remote_server_status)"
        return $remote_server_status
    fi
}

# -----------------------------------------------------------------------------
# Retrieves checkpoints listed in .cpt file at a given backup path as first argument.
# when second argument is '--num', retrieves the number of checkpoints instead of a list:
# -----------------------------------------------------------------------------
backup_checkpoint_list()
{
    local main_path=$1
    local cpt_file="$(basename $main_path).cpt"
    local checkpoint_list="$(cat $main_path/$cpt_file | sed -e 's/\[//g' -e 's/\"//g' -e 's/,//g' -e 's/\]//g')"
    [[ $2 == --num ]] && echo "$(echo "$checkpoint_list" | wc -w)" || echo "$checkpoint_list"
}



# -----------------------------------------------------------------------------
# For a given checkpoint file, returns a string value with (restorable) virtual drives (separated by spaces) (e.g. "hdc hdd")
# -----------------------------------------------------------------------------
backup_restorable_drives_list()
{
    echo $(grep -e "checkpoint='bitmap'" $1 | cut -d"'" -f2)
}

# -----------------------------------------------------------------------------
# Looks for a given directory and returns 'yes' if empty:
# -----------------------------------------------------------------------------
dir_is_empty()
{
    find $1 -maxdepth 0 -empty -exec echo {} yes \;
}

# -----------------------------------------------------------------------------
# Returns a list of (ordered) bitmaps present into a given disk image:
# -----------------------------------------------------------------------------
disk_image_bitmap_list()
{
    echo $(sort_items $(qemu-img info $1 |  grep "name:" | rev | cut -d' ' -f1 | rev))
}

# -----------------------------------------------------------------------------
# Deletes specific bitmaps of a given virtual disk, or all if '--all' argument is passed instead:
# -----------------------------------------------------------------------------
disk_image_delete_bitmap()
{

    local bitmaps_list

    # First argument is always the full path to the disk image:
    local virtual_disk_path=$1
    shift

    # Remaining arguments are processed as they come:
    while [[ $@ != "" ]]; do

        case $1 in

            # Indicates to delete all bitmaps found, instead of processing bitmaps_list:
            --all)
                bitmaps_list=($(disk_image_bitmap_list $virtual_disk_path))
                break
            ;;
            # Any other value is taken as a bitmap name, therefore added in bitmap_list:
            *)
                bitmaps_list+=($1)
            ;;
        esac

        # Shifts to the next argument:
        shift
    done

    if [[ ! -z ${bitmaps_list[@]} ]]; then

        echo "$domain: Removing ${#bitmaps_list[@]} bitmap(s)..."

        for bitmap in ${bitmaps_list[@]}; do
            &> /dev/null qemu-img bitmap --remove $virtual_disk_path $bitmap
        done

        [[ $(domain_state $domain) != "shut off" ]] && echo "$(basename $virtual_disk_path): VM full power cycle is needed in order to apply changes"

    else
        echo "$(basename $virtual_disk_path): No bitmaps to delete"
    fi
}

# -----------------------------------------------------------------------------
# Returns a random, uppercase, MAC address, based upon (optional) base pattern 'XX:XX:XX'
# -----------------------------------------------------------------------------
gen_random_macaddr()
{
    local seed=$1

    # If no base pattern is provided, will use a fixed parameter
    [[ -z $seed ]] && seed=$base_mac_addr

    printf '%s:%02X:%02X:%02X\n' ${seed^^} $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))
}

# -----------------------------------------------------------------------------
# Looks for a first concurrence of a given item into a given array name, returning the index if found and nothing if not found:
# -----------------------------------------------------------------------------
item_position()
{
    local searched_item=$1
    local array_name="$2[@]"

    local i=0
    for item in ${!array_name}; do

        [ $item == $searched_item ] && { echo $i; break; } || ((i++))
    done
}

# Returns a formatted string that is the last modified date and time:
# -----------------------------------------------------------------------------
last_modified()
{
    echo $(date -r $1 "+%Y-%m-%d %H:%M:%S")
}

# -----------------------------------------------------------------------------
# Patches a given xml file to provide incremental backups capability, returning sed status
# (Assumes the xml file has no patch):
# -----------------------------------------------------------------------------
patch_xml()
{
    # Modifies the XML file with sed, adding parameters as of virtnbdbackup documentation:
    sed -i -e "s|<domain type='kvm'>|<domain type='kvm' id='1' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'>|" -e "/<\/domain>/i \ \ <qemu:capabilities>\n      <qemu:add capability='incremental-backup'\/>\n  <\/qemu:capabilities>" $1

    return $?
}

# -----------------------------------------------------------------------------
# Guess OS name by kernel and returns a string with 'yes' if OS is Unraid, and otherwise 'no':
# -----------------------------------------------------------------------------
os_is_unraid()
{
    local is_unraid_status=1
    [[ ! -z $(uname  -r | grep -e "-Unraid$") ]] && echo "yes" || echo "no"
}

# -----------------------------------------------------------------------------
# From a given list, sorts unordered items lexicographically, with numbers naturally sorted:
# -----------------------------------------------------------------------------

sort_items()
{
    echo $@ | xargs -n1 | sort -V | xargs
}

###############################################################################
# Display Related Functions;
###############################################################################

# -----------------------------------------------------------------------------
# Prompts a given question to the user, and returns either 'yes' or 'no':
# -----------------------------------------------------------------------------
yes_no()
{
    local question=$1
    local default_choice=$2
    local trailing_string="[yes/no]"
    local choice

    while true; do

        # Prompts and in case $default_choice was provided, it's displayed with upper caps:
        read -p "$question ${trailing_string/$default_choice/${default_choice^^}}: " choice

        case $choice in

            yes|YES|no|NO)

                echo ${choice,,}
                break
            ;;
            "")
                if [ ! -z $default_choice ]; then

                    echo $default_choice
                    break
                fi
            ;;
        esac

    done
}

# -----------------------------------------------------------------------------
# Prompts a given question to the user amd returns a number if is within (also given) parameters:
# -----------------------------------------------------------------------------
choose_number()
{
        local question=$1
        local min_choice=$2
        local max_choice=$3
        if [[ ! -z $4 ]] || [[ $min_choice -eq $max_choice ]]; then
            local default_choice=" (defaults to '$4')"
        fi
        local choice

    while true; do

        read -p "$question [$min_choice-$max_choice]$default_choice: " choice

        case $choice in

            [0-9])
                if [[ $choice -ge $min_choice ]] && [[ $choice -le $max_choice ]]; then

                    echo $choice
                    break
                fi
            ;;

            "")
                if [ ! -z $4 ]; then

                    echo $4
                    break
                fi
        esac
    done
}

# -----------------------------------------------------------------------------
# Sends a message to Unraid's notification system, to be displayed according with user setup:
# -----------------------------------------------------------------------------
unraid_notify()
{
    local severity=\"$1\"
    shift
    local event=\"$1\"
    shift
    local subject=\"$1\"
    shift
    local message=\"$@\"

   ssh $SSH_OPTIONS root@$UNRAID_NOTIFY_HOST "/usr/local/emhttp/plugins/dynamix/scripts/notify -i $severity -e $event -s $subject -d $message"

# Adds a final delay to prevent false positive spamming detection (e.g. Telegram bots)
sleep 1
}
