#!/bin/bash

show_help()
{
cat << end_of_help

 USAGE: [LOCAL_BACKUP_PATH=...] $(basename $0) [ -h | --help ] [-s | --source <absolute-path>]

 $(basename $0) --  Restores backups of domains created with virtnbdbackup, total or partially, optionally to a defined point in time (checkpoint)

 INSTRUCTIONS:
  - It can restore a full system (default option), as well as individual disks or drives
  - Without arguments, it works interactively: A series of options and questions are presented before to actually start the process
  - When everything has been set to ptoceed, awaits for confirmation before to start (restoration may take time, depending on the data volume to restore, hadware speed, etc.)
  - Once completed, displays the final result about the operation (full success, partial restoration of disks or fail) showing a summary of restored/failed disks if restoration was partial.

 NOTES:
  - Use it only with backups created from the SAME Virtual Machine you're attempting to restore!
  - If the virtual machine to restore is running, it will be (gracefully) powered OFF right before to start the process
  - When old disk images are kept and restoration was successful, a timestamp with its last modification time is appended to each replaced image fila.
  - The script is NOT aware of remaining space left, so you must be careful when keping too many old images, specially on scenarios with constrains about storage.

end_of_help
}

# #############################################################################
# Main execution:
# #############################################################################

# Load functions:
source /usr/local/bin/vm-functions

# -----------------------------------------------------------------------------
# Read user parameters:

case $1 in

    '') # When no arguments are given, default backups location is LOCAL_BACKUP_PATH
        [[ -n $LOCAL_BACKUP_PATH ]] \
            && main_backups_path=$LOCAL_BACKUP_PATH \
            || main_backups_path="/backups"
    ;;

    -s|--source) # User provides a custom location for main_backups_path

        case $2 in

            [/]*)   # Verify the given argument is an existing folder:
                    [[ -d $2 ]] \
                        && main_backups_path="$2" \
                        || { echo -e "ERROR: Path '$2' was not found. Provide a valid path to scan for backups\n"; vm_restore_exit_code=1; }
            ;;

            *)      # Is not an absolute path:
                    echo -e "ERROR: '$2' is not an absolute path. Provide a valid path to scan for backups\n"
                    vm_restore_exit_code=1
            ;;
        esac
    ;;

    -h|--help)  # Show help:
                show_help
                vm_restore_exit_code=0
    ;;

    *)  # Unknown option:
        echo -e "Unknown argument '$1' Usage: $(basename $0) [ -h | --help ] [-s | --source <absolute-path>]\n"
        vm_restore_exit_code=1
    ;;
esac

if [[ -z $vm_restore_exit_code ]]; then

    # No exit code means the input parameters are correct.

    # =============================================================================
    # Begin interactive mode:
    # =============================================================================

    for folder in $(find $main_backups_path -mindepth 1 -maxdepth 1 -type d | sort -u); do

        # Get a list of file extensions in folder:
        extensions_list="$(list_extensions $folder)"

        # Extensions 'data' and 'xml' are proof it's a virtnbdbackup type:
        [[ -n $(grep -x data <<< $extensions_list) && -n $(grep -x xml <<< $extensions_list) ]] \
            && src_backups_list+=($folder)
    done

    if [[ -n ${src_backups_list[@]} ]]; then

        # -----------------------------------------------------------------------------
        # Show all restorable backups:
        # -----------------------------------------------------------------------------

        echo -e "\nRetrieving info from backups at '$main_backups_path'..."
        screen_header "-"
        printf "%3s %-19s %15s  %-19s  %-19s  %s\n" "#" "Backup of" "Checkpoints" "From date ($(date +%Z))" "To date ($(date +%Z))" "Source directory"
        screen_header "-"

        for ((i=0; i<${#src_backups_list[@]}; i++)); do

            # (Re) initilize variables:
            first_saved=""
            last_saved=""

            # Get domain names, # of checkpoints and times of each checkpoint:
            src_domains_list+=("$(backup_domain_info --name ${src_backups_list[$i]})")
            src_checkpoints_num_list+=("$(backup_checkpoints_num ${src_backups_list[$i]})")
            src_all_dates_list+=("$(backup_times_list ${src_backups_list[$i]})")

            # Also get first and last checkpoint dates, human readable:
            first_saved_date=$( date -d @$(echo "${src_all_dates_list[$i]}" | cut -d ' ' -f1) "+%Y-%m-%d %H:%M:%S")
            last_saved_date=$(date -d @$(echo "${src_all_dates_list[$i]}" | rev | cut -d ' ' -f1 | rev) "+%Y-%m-%d %H:%M:%S")

            # Show the line with backup information:
            printf "%3s %-31s %3s  %-19s  %-19s  %s\n" "$(($i + 1))" "${src_domains_list[$i]}" "${src_checkpoints_num_list[$i]}" "$first_saved_date" "$last_saved_date" "$(basename ${src_backups_list[$i]})"
        done

        # -----------------------------------------------------------------------------
        # Ask the user to choose a backup to restore:
        # -----------------------------------------------------------------------------
        echo ""
        user_choice=$(($(choose_number "Choose a backup to restore" "1" "${#src_backups_list[@]}") - 1))

        # Get all chosen backup metadata, from gathered above and directly from functions:
        src_domain=${src_domains_list[$user_choice]}
        src_checkpoints_num=${src_checkpoints_num_list[$user_choice]}
        src_path=${src_backups_list[$user_choice]}
        src_dates_list=(${src_all_dates_list[$user_choice]})

        # -----------------------------------------------------------------------------
        # Show multiple checkpoints, if any:
        # -----------------------------------------------------------------------------
         if [[ $src_checkpoints_num -ge 2 ]]; then

            # Get specific list of checkpoints in src_path:
            src_checkpoints_list=($(backup_checkpoints_list $src_path))

            # Header to show when there are incremental backups:
            echo -e "\nRetrieving checkpoints list from backup of domain '$src_domain' at sub-folder '$(basename $src_path)'..."
            screen_header "-"
            printf "%3s %-18s  %s\n" "#" "Checkpoint Name" "Saved at ($(date +%Z)):"
            screen_header "-"

            for ((i=0; i<${#src_checkpoints_list[@]}; i++)); do

                # Prints on screen detailed (and tabulated) data for the given checkpoint:
                printf "%3s %-18s  %s\n" "$(($i + 1))" "${src_checkpoints_list[$i]}" "$(date -d @$(echo ${src_dates_list[$i]}))"
            done

            # -----------------------------------------------------------------------------
            # Ask the user to choose a specific checkpoint to restore:
            # -----------------------------------------------------------------------------
            echo ""
            user_choice=$(($(choose_number "Choose a specific point in time to restore (or press ENTER to select the latest one) :" "1" "$src_checkpoints_num" "$src_checkpoints_num") - 1))

            if [[ $user_choice -ne $src_checkpoints_num ]]; then

                # When user_choice is different than the default option,
                # set these variables to notify and to be used with virtnbdrestore when restoring (up to chosen checkpoint):
                chosen_checkpoint="${src_checkpoints_list[$user_choice]}"
                until_chosen_checkpoint="--until $chosen_checkpoint"
            fi
        fi

        # Gets drive(s) and disk path(s) into backup to be restored (at chosen checkpoint, if defined):
        src_id=$(backup_domain_info --id $src_path)
        src_drives_list=($(backup_restorable_list --drives $src_path $chosen_checkpoint))
        src_imgpaths_list=($(backup_restorable_list --paths $src_path $chosen_checkpoint))

        [[ -n $chosen_checkpoint ]] && chosen_checkpoint_message=" (at checkpoint '$chosen_checkpoint')"
        echo -e "Backup of domain '$src_domain' from source '$src_path'$chosen_checkpoint_message selected for restoration\n"

        # -----------------------------------------------------------------------------
        # When applies, compare backup info (name, id, drives, paths, etc.) with existing domains:
        # -----------------------------------------------------------------------------
        echo -e "Analyzing all possible courses of action..."

        # Get the (ordered) list of existing domains:
        existing_domains_list=($(domains_list | sort -u))

        for domain in ${existing_domains_list[@]}; do

            # (Re) initilize variables:
            drives_list=()
            imgpaths_list=()
            partial_drives_list=()
            partial_imgpaths_list=()

            # Detect if a domain with same name exists (there can be only one):
            [[ $src_domain == $domain ]] && dest_domain_exists=true

            # Detect if any domain with same uuid exists (there can be only one):
            [[ $src_id == $(domain_id $domain) ]] && { dest_id_exists=true; dest_id_domain=$domain; }

            # Detect which domain(s) have total or partial match(es) with image path(s):
            imgpaths_list=($(domain_img_paths_list $domain))
            drives_list=($(domain_drives_list $domain))

            if [[ "${src_imgpaths_list[@]}" == "${imgpaths_list[@]}" && "${src_drives_list[@]}" == "${drives_list[@]}"  ]]; then

                # Domain has exactly the same drives and image paths as in chosen backup.

                # Add domain separated list to display with high priority:
                high_path_match_domains_list+=($domain)

                # And add metadata to other lists in order to process during following up processes:
                matching_domains_list+=($domain)
                matching_drives_list+=("${drives_list[@]}")
                matching_imgpaths_list+=("${imgpaths_list[@]}")

            else # No exact matches by path.

                # Attempt to find partial matches:
                for ((i=0; i<${#src_imgpaths_list[@]}; i++)); do

                    if [[ ${src_imgpaths_list[$i]} == ${imgpaths_list[$i]} && ${src_drives_list[$i]} == ${drives_list[$i]} ]]; then

                        # Domain has at least one matching drive and path as in chosen backup:
                        partial_imgpaths_list+=(${src_imgpaths_list[$i]})
                        partial_drives_list+=(${drives_list[$i]})
                    fi
                done

                if [[ -n ${partial_imgpaths_list[@]} ]]; then

                    # Add domain separated list to display with mid priority:
                    mid_path_match_domains_list+=($domain)

                    # And add metadata to other lists in order to process during following up processes:
                    matching_domains_list+=($domain)
                    matching_drives_list+=("${partial_drives_list[@]}")
                    matching_imgpaths_list+=("${partial_imgpaths_list[@]}")

                else # Not even partial matches by path

                    if [[ $domain == $src_domain || $domain == $dest_id_domain ]]; then

                        # Domain matches by either name or uuid.
                        # Add domain separated list to display with low priority:
                        no_path_match_domains_list+=($domain)

                        # Add metadata to other lists in order to process during following up processes:
                        matching_domains_list+=($domain)
                        matching_drives_list+=("${drives_list[@]}")
                        matching_imgpaths_list+=("${imgpaths_list[@]}")
                    fi
                fi
            fi
        done

        # Fill all unset boolean variables about existing metadata to false:
        [[ -z $dest_domain_exists ]] && dest_domain_exists=false
        [[ -z $dest_id_exists ]] && dest_id_exists=false
        [[ $dest_domain_exists == false && $dest_id_exists == false && -z ${matching_domains_list[@]} ]] && no_matching_domains=true

        # -----------------------------------------------------------------------------
        # Show available actions about how to restore this backup:
        # -----------------------------------------------------------------------------
        screen_header "-"
        echo -e "Available actions to perform with backup of domain '$src_domain'"
        screen_header "-"

        # Number of options present in the below dialog:
        menu_option=1

        # Applies to all scenarios (default option):
        echo -e "$menu_option. Total or partial restoration with a custom domain name"

        # Set first as default option:
        default_option=$menu_option

        if [[ $no_matching_domains == true ]]; then

            # Applies when no existing domain, uuid or image path(s), match with chosen backup:
            ((menu_option++))
            echo -e "$menu_option. Total or partial restoration as new domain '$src_domain' <- no matches found"

            # When no matches, set as default option instead:
            default_option=$menu_option

        else # It's a match!

            for domain in ${high_path_match_domains_list[@]}; do

                if [[ $dest_domain_exists == true && $src_domain == $dest_id_domain ]]; then
                    matching_message="name, uuid &"
                    # When full match, set as default option instead:
                    default_option=$menu_option
                elif [[ $dest_domain_exists == true && $dest_id_exists == false ]]; then
                    matching_message="name &"
                elif [[ $dest_domain_exists == false && $dest_id_exists == true ]]; then
                    matching_message="uuid &"
                fi

                # Applies when at least, all image path(s) coincide (showing which elements match with backup):
                ((menu_option++))
                echo -e "$menu_option. Total or partial restoration onto existing domain '$domain' <- $matching_message all disk image(s) match"
            done

            for domain in ${mid_path_match_domains_list[@]}; do

                if [[ $dest_domain_exists == true && $src_domain == $dest_id_domain ]]; then
                    matching_message="name, uuid &"
                elif [[ $dest_domain_exists == true && $dest_id_exists == false ]]; then
                    matching_message="name &"
                elif [[ $dest_domain_exists == false && $dest_id_exists == true ]]; then
                    matching_message="uuid &"
                fi

                # Applies when at least, one image path coincide (showing which elements match with backup):
                ((menu_option++))
                echo -e "$menu_option. Partial restoration onto existing domain '$domain' <- $matching_message some disk image(s) match"
            done

            for domain in ${no_path_match_domains_list[@]}; do

                if [[ $dest_domain_exists == true && $src_domain == $dest_id_domain ]]; then
                    matching_message="name & uuid match"
                elif [[ $dest_domain_exists == true && $dest_id_exists == false ]]; then
                    matching_message="name matches"
                elif [[ $dest_domain_exists == false && $dest_id_exists == true ]]; then
                    matching_message="uuid matches"
                fi

                # Applies when at least, domain name or uuid coincide (showing which elements match with backup):
                ((menu_option++))
                echo -e "$menu_option. Custom restoration onto existing domain '$domain' <- $matching_message"
            done
        fi

        echo ""
        user_choice=$(choose_number "Choose an action" "1" "$menu_option" "$default_option")

        if [[ $user_choice -eq 1 ]]; then

            # -----------------------------------------------------------------------------
            # Ask the user for a name for the new domain dest_domain:
            # -----------------------------------------------------------------------------
            read -p "Insert a name for the new domain, which will be created from backup of domain '$src_domain': " dest_domain

            # TODO: Add Qemu/KVM domain name constrains:
            while [[ $dest_domain == $(grep -o -e "$dest_domain" <<< "${existing_domains_list[@]}") ]]; do

                # Ask for a different name if the domain already exists on the list
                read -p "Domain '$dest_domain' already exists or is invalid. Choose a different name: " dest_domain
            done

            # Domain name was chosen by the user
            set_custom_domain=true

        else
            # Domain name was chosen by available options:
            set_custom_domain=false
        fi

        if [[ -z ${matching_domains_list[@]} ]]; then

            # -----------------------------------------------------------------------------
            # No matches. dest_domain is same src_domain:
            # -----------------------------------------------------------------------------
            # Gets dest_domain (when not already set), drives and paths from source metadata:
            [[ -z $dest_domain ]] && dest_domain=$src_domain
            dest_drives_list=(${src_drives_list[@]})
            dest_imgpaths_list=(${src_imgpaths_list[@]})

        else
            # -----------------------------------------------------------------------------
            # Total or partial match(es). Choose the domain from array matching_domains_list,
            # at user_choice minus minimal possible option (2):
            # -----------------------------------------------------------------------------
            user_choice=$(($user_choice - 2))

            # Gets dest_domain (when not already set), drives and paths from matching metadata:
            [[ -z $dest_domain ]] && dest_domain=${matching_domains_list[$user_choice]}
            dest_drives_list=(${matching_drives_list[$user_choice]})
            dest_imgpaths_list=(${matching_imgpaths_list[$user_choice]})

        fi

        if [[ $set_custom_domain == true || $no_matching_domains == true ]]; then

            # Tell virtnbdrestore to define the domain with the user selected name:
            define_domain="--define"
            name_domain="--name $dest_domain"

            # Custom message:
            restoration_message="restored and defined as a new"

        else # Domain exists.

            # Custom message:
            restoration_message="restored onto the already existing"
        fi

        echo -e "Backup of domain '$src_domain' selected to be $restoration_message domain with name: '$dest_domain'\n"

        # -----------------------------------------------------------------------------
        # Show available options about specific drive(s) and path(s) how to restore this backup:
        # -----------------------------------------------------------------------------
        echo -e "Retrieving info about restorable drives and disk image paths..."
        screen_header "-"
        printf "%5s  %s\n" "Drive" "Original path"
        screen_header "-"

        for ((i=0; i<${#dest_drives_list[@]}; i++)); do

            # List all drives and respective disk image files:
            printf "%5s  %s\n" "${dest_drives_list[$i]}" "${dest_imgpaths_list[$i]}"
        done

        screen_header "-"
        echo -e "Available actions for restorable device(s):"

        # Custom path options:
        # -----------------------------------------------------------------------------
        # Number of options present in the below dialog:
        menu_option=1

        echo "$menu_option. Restore drives '${dest_drives_list[@]}' to a custom path"

        # Save values for further selection:
        selectable_drives_list+=("${dest_drives_list[@]}")
        selectable_dest_path_list+=("#")
        selectable_imgs_list+=("$(basename -a ${dest_imgpaths_list[@]})")

        # When multiple drives, show custom path options for individual restoration:
        if [[ ${#dest_drives_list[@]} -gt 1 ]]; then

            for ((i=0; i<${#dest_drives_list[@]}; i++)); do

                ((menu_option++))
                echo "$menu_option. Only restore drive '${dest_drives_list[$i]}' to a custom path"

                # Save values for further selection:
                selectable_drives_list+=("${dest_drives_list[$i]}")
                selectable_dest_path_list+=("#")
                selectable_imgs_list+=("$(basename -a ${dest_imgpaths_list[$i]})")
            done
        fi

        # Defined path(s) options:
        # -----------------------------------------------------------------------------
        # Get the unique dir paths available to restore:
        unique_dirs_list=($(dirname ${dest_imgpaths_list[@]} | uniq))

        for ((i=0; i<${#unique_dirs_list[@]}; i++)); do

            ((menu_option++))
            echo "$menu_option. Restore drives '${dest_drives_list[@]}' onto path '${unique_dirs_list[$i]}'"

            # Save values for further selection:
            selectable_drives_list+=("${dest_drives_list[@]}")
            selectable_dest_path_list+=("${unique_dirs_list[$i]}")
            selectable_imgs_list+=("$(basename -a ${dest_imgpaths_list[@]})")

            # First defined path concurrence option for all devices becomes the default option:
            default_option=$menu_option

            # When multiple drives, show defined options for individual restoration:
            if [[ ${#dest_drives_list[@]} -gt 1 ]]; then

                for ((j=0; j<${#dest_drives_list[@]}; j++)); do

                    ((menu_option++))
                    echo "$menu_option. Only restore drive '${dest_drives_list[$j]}' onto path '${unique_dirs_list[$i]}'"

                    # Save values for further selection:
                    selectable_drives_list+=("${dest_drives_list[$j]}")
                    selectable_dest_path_list+=("${unique_dirs_list[$i]}")
                    selectable_imgs_list+=("$(basename -a ${dest_imgpaths_list[$j]})")
                done
            fi
        done

        echo ""
        user_choice=$(($(choose_number "Choose an action" "1" "$menu_option" "$default_option") - 1))

        # Set dest_imgs_list from user choice:
        dest_imgs_list=(${selectable_imgs_list[$user_choice]})

        if [[ ${selectable_dest_path_list[$user_choice]} == "#" ]]; then

            # -----------------------------------------------------------------------------
            # Ask the user for a custom path for drives:
            # -----------------------------------------------------------------------------
            read -p "Insert an absolute path to restore disk image(s) '${dest_imgs_list[@]}': " dest_path

            while [[ -z $dest_path || $dest_path != /* ]]; do

                # Ask for a different path name if invalid:
                read -p "Path '$dest_path' is not absolute or is invalid. Choose a valid path: " dest_path
            done

        else
            # Set dest_path from user choice:
            dest_path=${selectable_dest_path_list[$user_choice]}
        fi

        # Determine if backup to bestored requires chnages on definitions:
        for ((i=0; i<${#src_imgpaths_list[@]}; i++)); do

            if [[ ${src_imgpaths_list[@]} == $dest_path/${dest_imgs_list[$i]} ]]; then

                # At least an original disk image path doesn't match with destination.
                src_dest_imgpaths_mismatch=true
            fi
        done

        if [[ $src_dest_imgpaths_mismatch == true ]]; then

            # Tell virtnbdrestore to adjust config, modifying, among other things, new paths of disk images:
            adjust_config="--adjust-config"

            # And also tell to define this domain with chosen name, if not already set:
            [[ -z $define_domain ]] && define_domain="--define"
            [[ -z $name_domain ]] && name_domain="--name $dest_domain"
        fi

        if [[ "${selectable_drives_list[$user_choice]}" == "${dest_drives_list[@]}" ]]; then

            # Everything will be restored by default.

            # Custom message:
            drives_message="All disk image(s)"

        else
            # Notify to virtnbdrestore to only restore the selected drive, via optional argument:
            upto_chosen_disk="--disk ${selectable_drives_list[$user_choice]}"

            # Custom message:
            drives_message="Selected disk image '${selectable_drives_list[$user_choice]}'"
        fi

        echo -e "$drives_message selected to be restored onto path '$dest_path'\n"

        # -----------------------------------------------------------------------------
        # Ask the user to start the restoration process:
        # -----------------------------------------------------------------------------

        if [[ $dest_domain == $(grep -o -e "$dest_domain" <<< "${existing_domains_list[@]}") ]]; then

            # When dest_domain exists, get the state of such domain:
            dest_domain_state=$(domain_state $dest_domain)

            # Notify in advance when dest_domain is not shut off:
            [[ $dest_domain_state != "shut off" ]] \
                && start_restoration_message="Domain '$dest_domain' is currently $dest_domain_state. Are you agree with shut down this domain automatically to start the restoration process?"
        fi

        [[ -z $start_restoration_message ]] \
            && start_restoration_message="Everything is ready to begin! Are you agree to start with the restoration process?"

        start_restoration=$(yes_no "$start_restoration_message" "no")

        if [[ $start_restoration == yes ]]; then

            if [[ -n $dest_domain_state && $dest_domain_state != "shut off" ]]; then

                # Shutdown existing dest_domain that is not shut off:
                domain_shutdown $dest_domain --wait $WAIT_TIME
                domain_shutdown_exit_code=$?
            fi

            if [[ -z $domain_shutdown_exit_code || $domain_shutdown_exit_code -eq 0 ]]; then

                # Look for existing dest_imgs_list in dest_path
                for ((i=0; i<${#dest_imgs_list[@]}; i++)); do

                    if [[ -f $dest_path/${dest_imgs_list[$i]} ]]; then

                        # If found, rename with timestamp, and save the full path:
                        saved_imgpaths_list+=($dest_path/${dest_imgs_list[$i]}.$(last_modified_time $($dest_path/${dest_imgs_list[$i]})))
                        mv $dest_path/${dest_imgs_list[$i]} ${saved_imgpaths_list[$i]}

                        echo "Disk image file ${dest_imgs_list[$i]} exists on path '$dest_path'. Renamed to $(basename ${saved_imgpaths_list[$i]})"
                    fi
                done

                #echo -e "\nBackup restoration of domain '$src_domain' from source '$src_path'$chosen_checkpoint_message is about to be $restoration_message domain '$dest_domain' in progress...\n"

                # Run the command, with all arguments gathered during the process:
                screen_header "="
                virtnbdrestore --input $src_path --output $dest_path $until_chosen_checkpoint $define_domain $name_domain $adjust_config $upto_chosen_disk
                screen_header "="
                virtnbdrestore_exit_code=$?

                if [[ $virtnbdrestore_exit_code -eq 0 ]]; then

                    echo -e "Backup restoration of domain '$dest_domain' ended successfully!"

                    if [[ $dest_domain_exists == true || $dest_id_exists == true ]]; then

                        echo "Pruning any existing checkpoints metadata from domain '$dest_domain'..."
                        domain_delete_checkpoints $dest_domain --all --metadata
                    fi

                    # Return success status:
                    vm_restore_exit_code=0
                    echo -e "\n$(basename $0): Finished.\n"

                else
                    echo -e "ERROR: Backup restoration of domain '$dest_domain' failed! (virtnbdrestore exit code: $virtnbdrestore_exit_code)\n"

                    # Undo any renaming of existing disk images at $dest_path:
                    for ((i=0; i<${saved_imgpaths_list[@]}; i++)); do

                        mv -f ${saved_imgpaths_list[$i]} $dest_path/${dest_imgs_list[$i]}
                        echo "Reverted ${saved_imgpaths_list[$i]} back to $dest_path/${dest_imgs_list[$i]}"

                        vm_restore_exit_code=1
                    done
                fi
            else
                echo -e "ERROR: Could not safely start the restoration process, because domain '$dest_domain' current state ($(domain_state $dest_domain)) disallows it!\n"
            fi
        else
            echo -e "\n$(basename $0): Restoration cancelled by user.\n"
            vm_restore_exit_code=2
        fi
    else
        vm_restore_exit_code=1
        echo -e "ERROR: No backups found at path '$main_backups_path'\n\nUSAGE: [LOCAL_BACKUP_PATH=...] $(basename $0) [ -h | --help ] [-s | --source <absolute-path>]\n"
    fi
fi
# End program with resulting exit code:
exit $vm_restore_exit_code

