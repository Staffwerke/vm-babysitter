#!/bin/bash

# Variables:
# -----------------------------------------------------------------------------

# Load functions:
source /usr/local/bin/vm-functions

# Generic name for all checkpoints (and bitmaps) into a given backup chain:
checkpoint_name="virtnbdbackup"

# Shows Help and basic Usage:
# -----------------------------------------------------------------------------
show_help()
{
cat << end_of_help

 $(basename $0) -- Restores disk image(s) of a virtual machine from saved backups (made with vm-full-backup, vm-inc-backup or virtnbdbackup-auto) up to a selected checkpoint in time.

    USAGE: $(basename $0) [ -h | --help ] [-s | --source <absolute-path>]

    INSTRUCTIONS:
    - It can restore a full system (default option), as well as individual disks or drives
    - Without arguments, it works interactively: A series of options and questions are presented before to actually start the process
    - When everything has been set to ptoceed, awaits for confirmation before to start (restoration may take time, depending on the data volume to restore, hadware speed, etc.)
    - Once completed, displays the final result about the operation (full success, partial restoration of disks or fail) showing a summary of restored/failed disks if restoration was partial.

    NOTES:
    - Use it only with backups created from the SAME Virtual Machine you're attempting to restore!
    - If the virtual machine to restore is running, it will be (gracefully) powered OFF right before to start the process
    - When old disk images are kept and restoration was successful, a timestamp with its last modification time is appended to each replaced image fila.
    - The script is NOT aware of remaining space left, so you must be careful when keping too many old images, specially on scenarios with constrains about storage.

 (Mantainer: Adri√°n Parilli <a.parilli@staffwerke.de>")

end_of_help
}

# #############################################################################
# Main execution:
# #############################################################################

# -----------------------------------------------------------------------------
# Read user parameters:

case $1 in

    '') # When no arguments are given, default backups location is LOCAL_BACKUP_PATH
        [[ -n $LOCAL_BACKUP_PATH ]] \
            && main_backups_path=$LOCAL_BACKUP_PATH \
            || main_backups_path="/backups"
    ;;

    -s|--source) # User provides a custom location for main_backups_path

        case $2 in

            [/]*)   # Verify the given argument is an existing folder:
                    [[ -d $2 ]] \
                        && main_backups_path="$2" \
                        || { echo -e "ERROR: Path '$2' was not found. Provide a valid path to scan for backups\n"; vm_restore_exit_code=1; }
            ;;

            *)      # Is not an absolute path:
                    echo -e "ERROR: '$2' is not an absolute path. Provide a valid path to scan for backups\n"
                    vm_restore_exit_code=1
            ;;
        esac
    ;;

    -h|--help)  # Show help:
                show_help
                vm_restore_exit_code=0
    ;;

    *)  # Unknown option:
        echo -e "Unknown argument '$1' Usage: $(basename $0) [ -h | --help ] [-s | --source <absolute-path>]\n"
        vm_restore_exit_code=1
    ;;
esac

if [[ -z $vm_restore_exit_code ]]; then

    # No exit code means the input parameters are correct.

    # =============================================================================
    # Begin interactive mode:
    # =============================================================================

    for folder in $(find $main_backups_path -mindepth 1 -maxdepth 1 -type d | sort -u); do

        # Get a list of file extensions in folder:
        extensions_list="$(list_extensions $folder)"

        # Extensions 'data' and 'xml' are proof it's a virtnbdbackup type:
        [[ -n $(grep -x data <<< $extensions_list) && -n $(grep -x xml <<< $extensions_list) ]] \
            && src_backups_list+=($folder)
    done

    if [[ -n ${src_backups_list[@]} ]]; then

        # -----------------------------------------------------------------------------
        # Show all restorable backups:
        # -----------------------------------------------------------------------------

        echo -e "\nRetrieving info from backups at '$main_backups_path'..."
        echo '-------------------------------------------------------------------------------'
        printf "%3s %-31s %3s  %-19s  %-19s  %s\n" "#" "Backup of" "#Cp" "From date ($(date +%Z))" "To date ($(date +%Z))" "Source folder"
        echo '-------------------------------------------------------------------------------'
        i=0
        for backup in "${src_backups_list[@]}"; do

            # (Re) initilize variables:
            first_checkpoint=""
            last_checkpoint=""

            # Get domain names, # of checkpoints and times of each checkpoint:
            src_backup_domains_list+=("$(backup_domain_name $backup)")
            src_backup_checkpoints_num+=("$(backup_checkpoints_num $backup)")
            src_backup_times_list+=("$(backup_times_list $backup)")

            # Also get first and last checkpoint dates, human readable:
            first_checkpoint_date=$( date -d @$(echo "${src_backup_times_list[$i]}" | cut -d ' ' -f1) "+%Y-%m-%d %H:%M:%S")
            last_checkpoint_date=$(date -d @$(echo "${src_backup_times_list[$i]}" | rev | cut -d ' ' -f1 | rev) "+%Y-%m-%d %H:%M:%S")

            # Show the line with backup information:
            printf "%3s %-31s %3s  %-19s  %-19s  %s\n" "$(( $i + 1))" "${src_backup_domains_list[$i]}" "${src_backup_checkpoints_num[$i]}" "$first_checkpoint_date" "$last_checkpoint_date" "$( basename ${src_backups_list[$i]})"
            ((i++))
        done

        # -----------------------------------------------------------------------------
        # Asks the user to choose a backup to restore:
        # -----------------------------------------------------------------------------
        echo ""
        user_choice=$(choose_number "Choose a backup to restore" "1" "${#src_backups_list[@]}")

        exit

    else
        vm_restore_exit_code=1
        echo "ERROR: No backups found at path '$main_backups_path'"
    fi


# Step 1: Asks the user to choose a VM to restore:
# -----------------------------------------------------------------------------
    dest_domains_list=($(virsh list --all --persistent --name))
    if [ $? == 0 ] && [[ ${#dest_domains_list[@]} -ge 1 ]]; then

        # Only proceeds either if libvirt doesn't report an error, and if there are non-trasient VMs:
        echo ""
        echo "Scanning for Virtual Machines..."
        echo ""
        echo "${#dest_domains_list[@]} VMs found in Host $(cat /etc/hostname):"
        echo '-------------------------------------------------------------------------------'
        printf " %s \t %-15s \t %s \n" "#" "VM Name" "Drives"
        echo '-------------------------------------------------------------------------------'

        i=0
        for vm in "${dest_domains_list[@]}"; do

            # Gets a list with drives in each VM that can b e restored:
            dest_domain_drives_list+=("$(domain_drives_list $vm)")

            # Shows each VM found, including the restorable drives:
            printf " %s \t %-15s \t %s \n" "$(( $i + 1))" "$vm" "${dest_domain_drives_list[$i]}"
            ((i++))
        done

        read -p "Choose the Virtual Machine # in the list [1-${#dest_domains_list[@]}] to be restored: " user_choice

        while true; do

            if [[ $user_choice -ge 1 ]] && [[ $user_choice -le ${#dest_domains_list[@]} ]]; then

                # Saves VM specs that will be used for restoration:
                dest_domain="${dest_domains_list[(( $user_choice - 1 ))]}"
                dest_domain_drives_list=(${dest_domain_drives_list[(( $user_choice - 1 ))]})
                domain_img_paths_list=($(domain_img_paths_list $dest_domain))

                break
            else
                read -p "'$user_choice' is invalid. Please choose a number of the list [1-${#dest_domains_list[@]}]: " user_choice
            fi
        done

        echo ""
        echo "Virtual Machine '$dest_domain' selected for restoration"
        echo ""

# Step 2: Asks the user for the main path to backups:
# -----------------------------------------------------------------------------
        read -p "Insert the Full path to the Nearest directory containing all backups sub-directories of '$dest_domain': " main_backups_path

        while true; do
            if [[ $main_backups_path == /* ]] && [ -d $main_backups_path ]; then

                echo "Scanning for existing backup chains of $dest_domain in $main_backups_path ..."
                folders_list=$(find $main_backups_path -type d -name "$dest_domain*")

                i=0
                for folder in $folders_list; do
                    if [ -f $folder/*.cpt ] && [ -d $folder/checkpoints ]; then

                        # If a virtnbdbackup scheme is detected, it is considered a valid backup folder:
                        src_backups_list+=("$folder")

                        # Gets the drives backed up in the main checkpoint:
                        src_backup_drives_list+=("$(backup_restorable_drives_list $folder/checkpoints/$checkpoint_name.0.xml)")

                        # And finally, creates an ordered list of backup names to be displayed:
                        src_backup_names_list+=("$(echo $folder | rev | cut -d '/' -f1 | rev)")
                    fi
                done

                # Will continue only when at least one valid virtnbdbackup folder has been detected:
                [ ! -z $src_backups_list ] && break || read -p "Sorry, no matching backups for '$dest_domain' were found in '$main_backups_path'. Choose a more specific path containing backups: " main_backups_path

            else
                read -p "'$main_backups_path': Does not exist, is not a directory, or it is a relative path. Verify the path and re-enter it: " main_backups_path
            fi
        done

        # Shows a list of restorable backups folder to choose:
        echo ""
        echo "${#src_backups_list[@]} backups found in '$main_backups_path':"

        if [[ ${#src_backups_list[@]} -gt 1 ]]; then

# Step 3: If multiple backups found for certain VM, asks the user to choose a backup to restore:
# -----------------------------------------------------------------------------

            echo '-------------------------------------------------------------------------------'
            printf " %s \t %-15s \t %s \n" "#"  "Backup Name" "Drives"
            echo '-------------------------------------------------------------------------------'
            i=0
            for backup in "${src_backups_list[@]}"; do

                printf " %s \t %-15s \t  %s \n" " $(( $i + 1))" "${src_backup_names_list[$i]}" "${src_backup_drives_list[$i]}"
                ((i++))
            done

            read -p "Choose the Backup Number in the list [1-${#src_backups_list[@]}] you want to restore: " user_choice

            while true; do

                if [[ $user_choice -ge 1 ]] && [[ $user_choice -le ${#src_backups_list[@]} ]]; then

                    # Saves Backup specs that will be used later:
                    main_backups_path="${src_backups_list[(( $user_choice - 1 ))]}"
                    chosen_backup_name="${src_backup_names_list[(( $user_choice - 1 ))]}"
                    src_backup_drives_list=(${src_backup_drives_list[(( $user_choice - 1 ))]})
                    break
                else
                    read -p "'$user_choice' is invalid. Please choose a number of the list [1-${#src_backups_list[@]}]: " user_choice
                fi
            done
        else

            echo "Backup with name '${src_backup_names_list[@]}' selected automatically (no other recognizable backups available for VM '$dest_domain' in '$main_backups_path')"

            chosen_backup_name="${src_backup_names_list[@]}"
            main_backups_path="${src_backups_list[@]}"
            src_backup_drives_list=(${src_backup_drives_list[@]})
        fi

        echo ""
        echo "Scanning for checkpoints..."

        checkpoints_list=(`cat $main_backups_path/*.cpt | sed -e 's/\[//g' -e 's/\"//g' -e 's/,//g' -e 's/\]//g'`)

        echo "${#checkpoints_list[@]} Checkpoints found for backup '$chosen_backup_name':"

         #if [[ ${#checkpoints_list[@]} -gt 1 ]]; then

# Step 4: If multiple checkpoints are found, asks the user to choose a specific checkpoint to restore:
# -----------------------------------------------------------------------------

            # Header to show when there are incremental backups:
            echo '-------------------------------------------------------------------------------'
            printf " %s \t %-10s \n" "Checkpoint" "Saved at"
            echo '-------------------------------------------------------------------------------'
            i=0
            for checkpoint in "${checkpoints_list[@]}"; do

                # Gets the Date/Time of a given checkpoint into the chosen backup:
                checkpoint_dates_list+=("$(last_modified $main_backups_path/checkpoints/$checkpoint.xml)")

                # Prints on screen detailed (and tabulated) data for the given checkpoint:
                printf ' %s \t %-10s \n' "$checkpoint" "${checkpoint_dates_list[$i]}"
                ((i++))
            done

            default_choice=$(( ${#checkpoints_list[@]} - 1 ))
            read -p "Choose the Checkpoint Number in the list [0-$default_choice] you want to restore, or press ENTER to select the latest one: " user_choice

            while true; do

                if [ -z $user_choice ]; then

                    checkpoint_index="${checkpoints_list[$default_choice]}"
                    checkpoint_date="${checkpoint_dates_list[$default_choice]}"
                    break

                elif [[ $user_choice -ge 0 ]] && [[ $user_choice -le $(( ${#checkpoints_list[@]} -1 )) ]]; then

                    checkpoint_index="${checkpoints_list[$user_choice]}"
                    checkpoint_date="${checkpoint_dates_list[$user_choice]}"
                    break
                else
                    read -p "$user_choice : Invalid user_choice. Please choose a number of the list [0-$(( ${#checkpoints_list[@]} - 1 ))]: " user_choice
                fi
            done
        #else

            #echo "INFO: No incremental backups detected in '$chosen_backup_name', the (only) existing backup will be used..."
            #checkpoint_index="${checkpoints_list[@]}"
            #checkpoint_date=$(last_modified $main_backups_path/$chosen_backup_name/checkpoints/${checkpoints_list[$checkpoint_index]}.xml)
        #fi

        echo ""
        echo "Checkpoint selected: '$checkpoint_index' (Saved at $checkpoint_date)"
        echo ""

        if [[ ${#dest_domain_drives_list[@]} -gt 1 ]] || [[ ${#src_backup_drives_list[@]} -gt 1 ]]; then

# Step 5: If multiple drives are found, asks the user for restoring specific ones:
# -----------------------------------------------------------------------------

            if [[ ${dest_domain_drives_list[@]} == ${src_backup_drives_list[@]} ]]; then

                # Only use case it's when both VM and backup chain, contain identical lists of drives:
                echo "${#src_backup_drives_list[@]} restorable drives found at both, VM '$dest_domain' and Backup '$chosen_backup_name': ${src_backup_drives_list[@]}"
                read -p "In order to restore only specific drive(s), insert their names separated by spaces; or just press ENTER to restore all the drives: " user_selected_drives

                while true; do

                    if [ -z "$user_selected_drives" ]; then

                        # The user has pressed ENTER without specify specific drives:
                        selected_drives=(${src_backup_drives_list[@]})
                        break
                    else

                        selected_drives=()
                        invalid_drives=()
                        for drive in $user_selected_drives; do

                            # Verifies the drive name is in $src_backup_drives_list, and adds if it matches:
                            [[ ! -z $(echo ${src_backup_drives_list[@]} | grep -w $drive) ]] && selected_drives+=("$drive") || invalid_drives+=("$drive")
                        done

                        # When at least one invalid drive has been detected, notifies the user and asks for insert drive names correctly:
                        if [[ ${#invalid_drives[@]} -eq 0 ]]; then

                            selected_drives=($(sort_items ${selected_drives[@]}))
                            break
                        else

                            invalid_drives="${invalid_drives[@]}"
                            read -p "'${invalid_drives// /,}' not found. Specify the exact drives you want to restore (or just ENTER to restore all the drives): " user_selected_drives
                        fi
                    fi
                done

            #else
                    # TO DO: Add other use cases (e.g. VM and backup lists of drives don't match, etc.)
            fi
        else
            selected_drives=(${src_backup_drives_list[@]})
        fi

        echo ""
        echo "Drives to be restored back at VM '$dest_domain': ${selected_drives[@]}"

# Step 6: Ask for keep or not old backup files:
# -----------------------------------------------------------------------------

        echo ""
        read -p "Do you want to keep the old disk images? [yes/no]: " user_choice

        while true; do

            case $user_choice in

                yes|YES)
                    keep_old_disks=1
                    break
                ;;
                no|NO)
                    break
                ;;
                *)
                    read -p "Please, write 'yes' or 'no': " user_choice
                ;;
            esac
        done

        echo ""
        read -n1 -s -r -p $'\nEverything is ready to begin!\nPress any key to start the process, or Ctrl+C to Cancel...\n' key

# Step 7: Perform the restoration:
# -----------------------------------------------------------------------------

        # Shutdown dest_domain
        domain_shutdown $dest_domain --wait $WAIT_TIME

        if [[ $? == 0 ]]; then

            echo ""
            echo "INFO: Restoration of VM '$dest_domain' (${selected_drives[@]}) checkpoint '$checkpoint_index' saved at $checkpoint_date in progress..."
            i=0
            for drive in ${selected_drives[@]}; do

                echo '-------------------------------------------------------------------------------'
                echo ""
                # Current image name and path for $drive:
                img_name=$(basename ${domain_img_paths_list[$i]})
                img_path=$(dirname ${domain_img_paths_list[$i]})

                if [[ -f $img_path/$img_name ]]; then

                    # Saves the old disk image with a different name:
                    old_img_name="$img_name.$(last_modified $img_path/$img_name)"
                    old_img_name=${old_img_name// /_}

                    mv $img_path/$img_name $img_path/$old_img_name
                fi

                # Retrieves the correspondent drive according the chosen options,
                # to the same directory where original image disk is, using the same drive name (e.g. 'hdc')
                virtnbdrestore -i $main_backups_path -o $image_path --until $checkpoint_index -d $drive
                echo ""

                if [[ $? == 0 ]]; then

                    echo "INFO: Stream of drive $drive successfully transferred"

                    if [[ -f $img_path/$old_img_name ]]; then

                        # Notify about the old image saved, or delete accordingly:
                        [[ $keep_old_disks ]] \
                            && echo "INFO: Old disk image at $img_path saved as '$old_img_name'" \
                            || rm -f $img_path/$old_img_name
                    fi

                    # Adds the drive to the restored_drives list:
                    restored_drives+=($drive)
                    echo "INFO: Image Drive '$drive' has been successfully restored!"
                else
                    # Removes any incomplete image, if exists:
                    [[ -f $img_path/$img_name ]] && rm -f $img_path/$image_name

                    # Restore previous existing image:
                    [[ -f $img_path/$old_img_name ]] && mv $img_path/$old_img_name $img_path/$img_name

                    # Adds the drive to the failed_drives list:
                    failed_drives+=($drive)
                    echo "WARNING: Stream of drive $drive has failed!"
                fi

                ((i++))
            done

            echo '==============================================================================='
            echo ""

            if [[ ${#restored_drives[@]} -eq ${#selected_drives[@]} ]]; then

                echo "Querying libvirt for old checkpoints..."
                domain_delete_checkpoints $dest_domain --all --metadata

                echo ""
                echo "INFO: Restoration of Virtual Machine '$dest_domain' has been successfully completed!"
                status=0

            elif [[ ${#restored_drives[@]} -gt 1 ]]; then

                echo ""
                echo "WARNING: Restoration of Virtual Machine '$dest_domain' was NOT complete! (Successed: '${restored_drives[@]}' / Failed: '${failed_drives[@]}')"
                echo "Check the logs above to determine the cause of the problem, solve it and run this script again (choosing the above failed drives for restoration only)"
                status=2
            else
                echo "ERROR: Restoration of Virtual Machine '$dest_domain' failed!"
                echo "Check the logs above to determine the cause of the problem, solve it and run this script again (no changes has been made onto the Virtual Machine)"
            fi
        else
            echo "ERROR: Could not safely start the restoration process because the Virtual Machine '$dest_domain' current state ($(domain_state $dest_domain)) disallows it!"
        fi
    else
        echo "ERROR: No persistent Virtual Machines detected! (is libvirt service running?)"
    fi
fi

# End program with resulting exit code:
exit $vm_restore_exit_code

