#!/bin/bash

# Variables:
# -----------------------------------------------------------------------------

# Load functions:
source /usr/local/bin/vm-functions

# Generic name for all checkpoints (and bitmaps) into a given backup chain:
checkpoint_name="virtnbdbackup"

# Shows Help and basic Usage:
# -----------------------------------------------------------------------------
show_help()
{
cat << end_of_help

 $(basename $0) -- Restores disk image(s) of a virtual machine from saved backups (made with vm-full-backup, vm-inc-backup or virtnbdbackup-auto) up to a selected checkpoint in time.

    USAGE: $(basename $0) [ -h | --help ] [-s | --source <absolute-path>]

    INSTRUCTIONS:
    - It can restore a full system (default option), as well as individual disks or drives
    - Without arguments, it works interactively: A series of options and questions are presented before to actually start the process
    - When everything has been set to ptoceed, awaits for confirmation before to start (restoration may take time, depending on the data volume to restore, hadware speed, etc.)
    - Once completed, displays the final result about the operation (full success, partial restoration of disks or fail) showing a summary of restored/failed disks if restoration was partial.

    NOTES:
    - Use it only with backups created from the SAME Virtual Machine you're attempting to restore!
    - If the virtual machine to restore is running, it will be (gracefully) powered OFF right before to start the process
    - When old disk images are kept and restoration was successful, a timestamp with its last modification time is appended to each replaced image fila.
    - The script is NOT aware of remaining space left, so you must be careful when keping too many old images, specially on scenarios with constrains about storage.

 (Mantainer: Adri√°n Parilli <a.parilli@staffwerke.de>")

end_of_help
}

# #############################################################################
# Main execution:
# #############################################################################

# -----------------------------------------------------------------------------
# Read user parameters:

case $1 in

    '') # When no arguments are given, default backups location is LOCAL_BACKUP_PATH
        [[ -n $LOCAL_BACKUP_PATH ]] \
            && main_backups_path=$LOCAL_BACKUP_PATH \
            || main_backups_path="/backups"
    ;;

    -s|--source) # User provides a custom location for main_backups_path

        case $2 in

            [/]*)   # Verify the given argument is an existing folder:
                    [[ -d $2 ]] \
                        && main_backups_path="$2" \
                        || { echo -e "ERROR: Path '$2' was not found. Provide a valid path to scan for backups\n"; vm_restore_exit_code=1; }
            ;;

            *)      # Is not an absolute path:
                    echo -e "ERROR: '$2' is not an absolute path. Provide a valid path to scan for backups\n"
                    vm_restore_exit_code=1
            ;;
        esac
    ;;

    -h|--help)  # Show help:
                show_help
                vm_restore_exit_code=0
    ;;

    *)  # Unknown option:
        echo -e "Unknown argument '$1' Usage: $(basename $0) [ -h | --help ] [-s | --source <absolute-path>]\n"
        vm_restore_exit_code=1
    ;;
esac

if [[ -z $vm_restore_exit_code ]]; then

    # No exit code means the input parameters are correct.

    # =============================================================================
    # Begin interactive mode:
    # =============================================================================

    for folder in $(find $main_backups_path -mindepth 1 -maxdepth 1 -type d | sort -u); do

        # Get a list of file extensions in folder:
        extensions_list="$(list_extensions $folder)"

        # Extensions 'data' and 'xml' are proof it's a virtnbdbackup type:
        [[ -n $(grep -x data <<< $extensions_list) && -n $(grep -x xml <<< $extensions_list) ]] \
            && src_backups_list+=($folder)
    done

    if [[ -n ${src_backups_list[@]} ]]; then

        # -----------------------------------------------------------------------------
        # Show all restorable backups:
        # -----------------------------------------------------------------------------

        echo -e "\nRetrieving info from backups at '$main_backups_path'..."
        screen_header "-"
        printf "%3s %-19s %15s  %-19s  %-19s  %s\n" "#" "Backup of" "Checkpoints" "From date ($(date +%Z))" "To date ($(date +%Z))" "Source directory"
        screen_header "-"

        i=0
        for backup in ${src_backups_list[@]}; do

            # (Re) initilize variables:
            first_saved=""
            last_saved=""

            # Get domain names, # of checkpoints and times of each checkpoint:
            src_domains_list+=("$(backup_domain_info --name $backup)")
            src_checkpoints_num_list+=("$(backup_checkpoints_num $backup)")
            src_all_dates_list+=("$(backup_times_list $backup)")

            # Also get first and last checkpoint dates, human readable:
            first_saved_date=$( date -d @$(echo "${src_all_dates_list[$i]}" | cut -d ' ' -f1) "+%Y-%m-%d %H:%M:%S")
            last_saved_date=$(date -d @$(echo "${src_all_dates_list[$i]}" | rev | cut -d ' ' -f1 | rev) "+%Y-%m-%d %H:%M:%S")

            # Show the line with backup information:
            printf "%3s %-31s %3s  %-19s  %-19s  %s\n" "$(( $i + 1))" "${src_domains_list[$i]}" "${src_checkpoints_num_list[$i]}" "$first_saved_date" "$last_saved_date" "$(basename ${src_backups_list[$i]})"
            ((i++))
        done

        # -----------------------------------------------------------------------------
        # Ask the user to choose a backup to restore:
        # -----------------------------------------------------------------------------
        echo ""
        user_choice=$(( $(choose_number "Choose a backup to restore" "1" "${#src_backups_list[@]}") - 1 ))

        # Get all chosen backup metadata, from gathered above and directly from functions:
        src_domain=${src_domains_list[$user_choice]}
        src_checkpoints_num=${src_checkpoints_num_list[$user_choice]}
        src_path=${src_backups_list[$user_choice]}
        src_dates_list=(${src_all_dates_list[$user_choice]})

        # -----------------------------------------------------------------------------
        # Show multiple checkpoints, if any:
        # -----------------------------------------------------------------------------
         if [[ $src_checkpoints_num -ge 2 ]]; then

            # Get specific list of checkpoints in src_path:
            src_checkpoints_list=($(backup_checkpoints_list $src_path))

            # Header to show when there are incremental backups:
            echo -e "\nRetrieving checkpoints list from backup of domain '$src_domain' at sub-folder '$(basename $src_path)'..."
            screen_header "-"
            printf "%3s %-18s  %s\n" "#" "Checkpoint Name" "Saved at ($(date +%Z)):"
            screen_header "-"
            i=0
            for checkpoint in ${src_checkpoints_list[@]}; do

                # Prints on screen detailed (and tabulated) data for the given checkpoint:
                printf "%3s %-18s  %s\n" "$(($i + 1))" "$checkpoint" "$(date -d @$(echo ${src_dates_list[$i]}))"
                ((i++))
            done

            # -----------------------------------------------------------------------------
            # Ask the user to choose a specific checkpoint to restore:
            # -----------------------------------------------------------------------------
            echo ""
            user_choice=$(( $(choose_number "Choose a specific point in time to restore (or press ENTER to select the latest one) :" "1" "$src_checkpoints_num" "$src_checkpoints_num") - 1 ))

            if [[ $user_choice -ne $src_checkpoints_num ]]; then

                # When user_choice is different than the default option,
                # set these variables to notify and to be used with virtnbdrestore when restoring (up to chosen checkpoint):
                chosen_checkpoint="${src_checkpoints_list[$user_choice]}"
                until_chosen_checkpoint="--until $chosen_checkpoint"
            fi
        fi

        # Gets drive(s) and disk path(s) into backup to be restored (at chosen checkpoint, if defined):
        src_id=$(backup_domain_info --id $src_path)
        src_drives_list=($(backup_restorable_list --drives $src_path $chosen_checkpoint))
        src_imgpaths_list=($(backup_restorable_list --paths $src_path $chosen_checkpoint))

        [[ -n $chosen_checkpoint ]] && chosen_checkpoint_message=" at checkpoint '$chosen_checkpoint'"
        echo -e "Backup of domain '$src_domain' from source '$src_path', selected for restoration\n"

        # -----------------------------------------------------------------------------
        # When applies, compare backup info (name, id, drives, paths, etc.) with existing domains:
        # -----------------------------------------------------------------------------
        echo -e "Analyzing all possible courses of action..."

        # Get the (ordered) list of existing domains:
        existing_domains_list=($(domains_list | sort -u))

        for domain in ${existing_domains_list[@]}; do

            drives_list=()
            imgpaths_list=()
            partial_drives_list=()
            partial_imgpaths_list=()

            # Detect if a domain with same name exists (there can be only one):
            [[ $src_domain == $domain ]] && dest_domain_exists=true

            # Detect if any domain with same uuid exists (there can be only one):
            [[ $src_id == $(domain_id $domain) ]] && { dest_id_exists=true; dest_id_domain=$domain; }

            # Detect which domain(s) have total or partial match(es) with image path(s):
            imgpaths_list=($(domain_img_paths_list $domain))
            drives_list=($(domain_drives_list $domain))

            if [[ "${src_imgpaths_list[@]}" == "${imgpaths_list[@]}" && "${src_drives_list[@]}" == "${drives_list[@]}"  ]]; then

                # Domain has exactly the same drives and image paths as in chosen backup.

                # Add domain separated list to display with high priority:
                full_match_domains_list+=($domain)

                # And add metadata to other lists in order to process during following up processes:
                matching_domains_list+=($domain)
                matching_drives_list+=("${drives_list[@]}")
                matching_imgpaths_list+=("${imgpaths_list[@]}")

            else # Attempt to find partial matches:

                i=0
                for imgpath in ${src_imgpaths_list[@]}; do

                    if [[ ${src_imgpaths_list[$i]} == ${imgpaths_list[$i]} && ${src_drives_list[$i]} == ${drives_list[$i]} ]]; then

                        # Domain has at least one matching drive and path as in chosen backup:
                        partial_imgpaths_list+=($imgpath)
                        partial_drives_list+=(${drives_list[$i]})
                    fi

                    ((i++))
                done

                if [[ -n ${partial_imgpaths_list[@]} ]]; then

                    # Add domain separated list to display with low priority:
                    partial_match_domains_list+=($domain)

                    # And add metadata to other lists in order to process during following up processes:
                    matching_domains_list+=($domain)
                    matching_drives_list+=("${partial_drives_list[@]}")
                    matching_imgpaths_list+=("${partial_imgpaths_list[@]}")
                fi
            fi
        done

        # Fill all unset boolean variables about existing metadata to false:
        [[ -z $dest_domain_exists ]] && dest_domain_exists=false
        [[ -z $dest_id_exists ]] && dest_id_exists=false

        # -----------------------------------------------------------------------------
        # Show available actions about how to restore this backup:
        # -----------------------------------------------------------------------------
        screen_header "-"
        echo -e "Available actions to perform with backup of domain '$src_domain'"
        screen_header "-"

        # Number of options present in the below dialog:
        menu_option=1

        # Applies to all scenarios (default option):
        echo -e "$menu_option. Full restoration with a custom domain name"

        if [[ $dest_domain_exists == false && $dest_id_exists == false && -z ${matching_domains_list[@]} ]]; then

            # Applies when no existing domain, uuid or image path(s), match with chosen backup:
            ((menu_option++))
            echo -e "$menu_option. Full restoration as new domain '$src_domain' <- no matches found"
        fi

        for domain in ${full_match_domains_list[@]}; do

            if [[ $dest_domain_exists == true && $src_domain == $dest_id_domain ]]; then
                matching_message="name, uuid &"
            elif [[ $dest_domain_exists == true && $dest_id_exists == false ]]; then
                matching_message="name &"
            elif [[ $dest_domain_exists == false && $dest_id_exists == true ]]; then
                matching_message="uuid &"
            fi

            # Applies when at least, all image path(s) coincide (showing which elements match with backup):
            ((menu_option++))
            echo -e "$menu_option. Full restoration onto existing domain '$domain' <- $matching_message all disk image(s) match"
        done

        for domain in ${partial_match_domains_list[@]}; do

            if [[ $dest_domain_exists == true && $src_domain == $dest_id_domain ]]; then
                matching_message="name, uuid &"
            elif [[ $dest_domain_exists == true && $dest_id_exists == false ]]; then
                matching_message="name &"
            elif [[ $dest_domain_exists == false && $dest_id_exists == true ]]; then
                matching_message="uuid &"
            fi

            # Applies when at least, one image path coincide (showing which elements match with backup):
            ((menu_option++))
            echo -e "$menu_option. Partial restoration onto existing domain '$domain' <- $matching_message some disk image(s) match"
        done

        echo ""
        user_choice=$(choose_number "Choose an action" "1" "$menu_option" "1")

        case $user_choice in

            1)  # -----------------------------------------------------------------------------
                # Ask the user for a name for the new domain dest_domain:
                # -----------------------------------------------------------------------------
                read -p "Insert a name for the new domain, which will be created from backup of domain '$src_domain': " dest_domain

                # TODO: Add Qemu/KVM domain name constrains:
                while [[ $dest_domain == $(grep -o -e "$dest_domain" <<< "${existing_domains_list[@]}") ]]; do

                    # Ask for a different name if the domain already exists on the list
                    read -p "Domain '$dest_domain' already exists or is invalid. Choose a different name: " dest_domain
                done

                # Gets dest_drives_list from source metadata:
                dest_drives_list=(${src_drives_list[@]})
                dest_imgpaths_list=(${src_imgpaths_list[@]})

                # Custom message:
                restoration_message="restored onto a new"
            ;;

            2)  # -----------------------------------------------------------------------------
                # No matches. dest_domain is same src_domain:
                # -----------------------------------------------------------------------------
                # Gets dest_domain and dest_drives_list from source metadata:
                dest_domain=$src_domain
                dest_drives_list=(${src_drives_list[@]})
                dest_imgpaths_list=(${src_imgpaths_list[@]})

                # Custom message:
                restoration_message="restored onto a new"
            ;;

            *)  # -----------------------------------------------------------------------------
                # Total or partial match(es). Choose the domain from array matching_domains_list,
                # at user_choice minus minimal possible option (3):
                # -----------------------------------------------------------------------------
                dest_index=$(( $user_choice - 3 ))

                # Gets dest_domain and dest_drives_list from matching metadata:
                dest_domain=${matching_domains_list[$dest_index]}
                dest_drives_list=(${matching_drives_list[$dest_index]})
                dest_imgpaths_list=(${matching_imgpaths_list[$dest_index]})

                # Custom message:
                restoration_message="restored onto the already existing"
            ;;
        esac

        echo -e "Backup of domain '$src_domain' will be $restoration_message domain with name: '$dest_domain'\n"

        # -----------------------------------------------------------------------------
        # Show available options about specific drive(s) and path(s) how to restore this backup:
        # -----------------------------------------------------------------------------
        echo -e "Retrieving info about restorable drives and disk image paths..."
        screen_header "-"
        printf "%5s  %s\n" "Drive" "Originally saved from path"
        screen_header "-"

        # List all drives and respective disk image files:
        i=0
        for drive in ${dest_drives_list[@]}; do

            printf "%5s  %s\n" "$drive" "${dest_imgpaths_list[$i]}"
            ((i++))
        done

        screen_header "-"
        echo -e "Available actions for restorable device(s):"

        # Number of options present in the below dialog:
        menu_option=1

        # Custom path options:
        # -----------------------------------------------------------------------------
        echo "$menu_option. Restore drives '${dest_drives_list[@]}' to a custom path"

        # When multiple drives, show custom path options for individual restoration:
        if [[ ${#dest_drives_list[@]} -gt 1 ]]; then

            i=0
            for drive in ${dest_drives_list[@]}; do

                ((menu_option++))
                echo "$menu_option. Only restore the drive '$drive' to a custom path"
                ((i++))
            done
        fi

        # Defined path(s) options:
        # -----------------------------------------------------------------------------
        # Get the unique dir paths available to restore:
        unique_dirs_list=($(dirname ${dest_imgpaths_list[@]} | uniq))

        i=0
        for folder in ${unique_dirs_list[@]}; do

            ((menu_option++))
            echo "$menu_option. Restore drives '${dest_drives_list[@]}' onto path '$folder'"

            # First defined path concurrence option for all devices becomes the default option:
            default_option=$menu_option

            # When multiple drives, show defined options for individual restoration:
            if [[ ${#dest_drives_list[@]} -gt 1 ]]; then

                j=0
                for drive in ${dest_drives_list[@]}; do

                    ((menu_option++))
                    echo "$menu_option. Only restore the drive '$drive' onto path '$folder'"
                    ((i++))
                done
            fi

            ((i++))
        done

        echo ""
        user_choice=$(choose_number "Choose an action" "1" "$menu_option" "$default_option")

        # -----------------------------------------------------------------------------
        # Ask the user to start the restoration process:
        # -----------------------------------------------------------------------------

        if [[ $dest_domain == $(grep -o -e "$dest_domain" <<< "${existing_domains_list[@]}") ]]; then

            # When dest_domain exists, get the state of such domain:
            dest_domain_state=$(domain_state $dest_domain)

            # Notify in advance when dest_domain is not shut off:
            [[ $dest_domain_state != "shut off" ]] \
                && start_restoration_message="Domain '$dest_domain' is currently $dest_domain_state. Are you agree with shut down this domain automatically to start the restoration process?"
        fi

        [[ -z $start_restoration_message ]] \
            && start_restoration_message="Everything is ready to begin! Are you agree to start the restoration process?"

        start_restoration=$(yes_no "$start_restoration_message" "no")

        if [[ $start_restoration == yes ]]; then

            if [[ -n $dest_domain_state && $dest_domain_state != "shut off" ]]; then

                # Shutdown existing dest_domain that is not shut off:
                domain_shutdown $dest_domain --wait $WAIT_TIME
                domain_shutdown_exit_code=$?
            fi

            if [[ -z $domain_shutdown_exit_code || $domain_shutdown_exit_code -eq 0 ]]; then

                echo -e "\nRestoration of backup from '$src_domain' in progress...\n"

                # Run the command
                virtnbdrestore -i $src_path -o ${dest_imgpaths_list[0]} $until_chosen_checkpoint

            else
                echo -e "ERROR: Could not safely start the restoration process, because domain '$dest_domain' current state ($(domain_state $dest_domain)) disallows it!\n"
            fi
        else
            echo -e "\n$(basename $0): Restoration cancelled by user.\n"
        fi

        # Dummy exit to stop the script early, as modifications go by:
        exit

    else
        vm_restore_exit_code=1
        echo -e "ERROR: No backups found at path '$main_backups_path'\n"
    fi

###############################################################################

        if [[ ${#existing_drives[@]} -gt 1 ]] || [[ ${#src_drives_list[@]} -gt 1 ]]; then

# Step 5: If multiple drives are found, asks the user for restoring specific ones:
# -----------------------------------------------------------------------------

            if [[ ${existing_drives[@]} == ${src_drives_list[@]} ]]; then

                # Only use case it's when both VM and backup chain, contain identical lists of drives:
                echo "${#src_drives_list[@]} restorable drives found at both, VM '$dest_domain' and Backup '$chosen_backup_name': ${src_drives_list[@]}"
                read -p "In order to restore only specific drive(s), insert their names separated by spaces; or just press ENTER to restore all the drives: " user_selected_drives

                while true; do

                    if [ -z "$user_selected_drives" ]; then

                        # The user has pressed ENTER without specify specific drives:
                        selected_drives=(${src_drives_list[@]})
                        break
                    else

                        selected_drives=()
                        invalid_drives=()
                        for drive in $user_selected_drives; do

                            # Verifies the drive name is in $src_drives_list, and adds if it matches:
                            [[ ! -z $(echo ${src_drives_list[@]} | grep -w $drive) ]] && selected_drives+=("$drive") || invalid_drives+=("$drive")
                        done

                        # When at least one invalid drive has been detected, notifies the user and asks for insert drive names correctly:
                        if [[ ${#invalid_drives[@]} -eq 0 ]]; then

                            selected_drives=($(sort_items ${selected_drives[@]}))
                            break
                        else

                            invalid_drives="${invalid_drives[@]}"
                            read -p "'${invalid_drives// /,}' not found. Specify the exact drives you want to restore (or just ENTER to restore all the drives): " user_selected_drives
                        fi
                    fi
                done

            #else
                    # TO DO: Add other use cases (e.g. VM and backup lists of drives don't match, etc.)
            fi
        else
            selected_drives=(${src_drives_list[@]})
        fi

        echo ""
        echo "Drives to be restored back at VM '$dest_domain': ${selected_drives[@]}"

# Step 7: Perform the restoration:
# -----------------------------------------------------------------------------

        # Shutdown dest_domain
        domain_shutdown $dest_domain --wait $WAIT_TIME

        if [[ $? == 0 ]]; then

            echo ""
            echo "INFO: Restoration of VM '$dest_domain' (${selected_drives[@]}) checkpoint '$checkpoint_index' saved at $checkpoint_date in progress..."
            i=0
            for drive in ${selected_drives[@]}; do

                screen_header "-"
                echo ""
                # Current image name and path for $drive:
                imgname=$(basename ${domain_imgpaths_list[$i]})
                imgpath=$(dirname ${domain_imgpaths_list[$i]})

                if [[ -f $imgpath/$imgname ]]; then

                    # Saves the old disk image with a different name:
                    old_imgname="$imgname.$(last_modified $imgpath/$imgname)"
                    old_imgname=${old_imgname// /_}

                    mv $imgpath/$imgname $imgpath/$old_imgname
                fi

                # Retrieves the correspondent drive according the chosen options,
                # to the same directory where original image disk is, using the same drive name (e.g. 'hdc')
                virtnbdrestore -i $main_backups_path -o $image_path --until $checkpoint_index -d $drive
                echo ""

                if [[ $? == 0 ]]; then

                    echo "INFO: Stream of drive $drive successfully transferred"

                    if [[ -f $imgpath/$old_imgname ]]; then

                        # Notify about the old image saved, or delete accordingly:
                        [[ $keep_old_disks ]] \
                            && echo "INFO: Old disk image at $imgpath saved as '$old_imgname'" \
                            || rm -f $imgpath/$old_imgname
                    fi

                    # Adds the drive to the restored_drives list:
                    restored_drives+=($drive)
                    echo "INFO: Image Drive '$drive' has been successfully restored!"
                else
                    # Removes any incomplete image, if exists:
                    [[ -f $imgpath/$imgname ]] && rm -f $imgpath/$image_name

                    # Restore previous existing image:
                    [[ -f $imgpath/$old_imgname ]] && mv $imgpath/$old_imgname $imgpath/$imgname

                    # Adds the drive to the failed_drives list:
                    failed_drives+=($drive)
                    echo "WARNING: Stream of drive $drive has failed!"
                fi

                ((i++))
            done

            echo '==============================================================================='
            echo ""

            if [[ ${#restored_drives[@]} -eq ${#selected_drives[@]} ]]; then

                echo "Querying libvirt for old checkpoints..."
                domain_delete_checkpoints $dest_domain --all --metadata

                echo ""
                echo "INFO: Restoration of Virtual Machine '$dest_domain' has been successfully completed!"
                status=0

            elif [[ ${#restored_drives[@]} -gt 1 ]]; then

                echo ""
                echo "WARNING: Restoration of Virtual Machine '$dest_domain' was NOT complete! (Successed: '${restored_drives[@]}' / Failed: '${failed_drives[@]}')"
                echo "Check the logs above to determine the cause of the problem, solve it and run this script again (choosing the above failed drives for restoration only)"
                status=2
            else
                echo "ERROR: Restoration of Virtual Machine '$dest_domain' failed!"
                echo "Check the logs above to determine the cause of the problem, solve it and run this script again (no changes has been made onto the Virtual Machine)"
            fi
        else
            echo "ERROR: Could not safely start the restoration process because the Virtual Machine '$dest_domain' current state ($(domain_state $dest_domain)) disallows it!"
        fi
    else
        echo "ERROR: No persistent Virtual Machines detected! (is libvirt service running?)"
    fi
fi

# End program with resulting exit code:
exit $vm_restore_exit_code

