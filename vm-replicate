#!/bin/bash

: << schedule

Similar to virtnbdrestore-auto (interactive) but creates a new VM based on definitions from an existing VM

Lists all available VMs to choose one:

Asks for:
    DONE New VM name (mandatory)
    Patch for incremental backup (if not detected)

Generate:
    DONE UUID
    DONE MAC addr (per each interface)

Modify:
    DONE disk images paths (based on VM name)
    DONE nvram image path (based on UUID)

Copy/clone:
    DONE nvram (from qemu template) on given location
    DONE If source VM is running, shuts it down prior to perform a disk copy
    writable disk images from original to new location (qemu-img)

Patch (if required by user)

Validate the VM
Define the VM.

schedule

# Temporal path to store files (as .xml):
working_path="$HOME/.$(basename $0).tmp"

# Location of script where all functions and global variables to be used are declared:
# (Here, on the same dir
functions_path="$(dirname $0)/functions"

# Main execution:
# -----------------------------------------------------------------------------

# Load functions:
source $functions_path

status=1
if [ -z $@ ]; then

    # No input parameters enables the interctive mode:
    #show_help
    #read -n1 -s -r -p $'Press any key to continue, or Ctrl+C to Cancel...\n' key

    # Asks the user to choose a VM to clone:
    # -----------------------------------------------------------------------------
    vms_list=($(virsh list --all --persistent --name))
    if [ $? == 0 ] && [[ ${#vms_list[@]} -ge 1 ]]; then

        # Only proceeds either if libvirt doesn't report an error, and if there are non-trasient VMs:
        echo ""
        echo "Scanning for Virtual Machines..."
        echo ""
        echo "${#vms_list[@]} VMs found in Host $(cat /etc/hostname):"
        echo '-------------------------------------------------------------------------------'
        printf " %s \t %-15s \t %s \n" "#" "VM Name"
        echo '-------------------------------------------------------------------------------'

        i=0
        for vm in "${vms_list[@]}"; do

            # Shows each VM found, including the restorable drives:
            printf " %s \t %s \n" "$(( $i + 1))" "$vm"
            ((i++))
        done

        read -p "Choose the Virtual Machine # in the list [1-${#vms_list[@]}] to be replicated: " choice

        while true; do

            if [[ $choice -ge 1 ]] && [[ $choice -le ${#vms_list[@]} ]]; then

                # If choice is consistent, saves the value and breaks the loop:
                src_vm="${vms_list[(( $choice - 1 ))]}"
                break
            else

                # Otherwise, alerts about the error and asks for $choice again:
                read -p "'$choice' is invalid. Please choose a number of the list [1-${#vms_list[@]}]: " choice
            fi
        done

        echo ""
        echo "INFO: VM '$src_vm' selected for being replicated"
        echo ""

        # Asks the user for a name to be used for the New VM:
        # -----------------------------------------------------------------------------
        read -p "Choose a unique name for the new VM to be replicated from $src_vm': " dest_vm

        while true; do

            for vm in "${vms_list[@]}"; do

                # Checks if $dest_vm is already defined, breaking the loop if so:
                [ $dest_vm == $vm ] && { matches_existing_vm=1; break; }
            done

            # End the loop if $dest_vm doesn't exist already, warns and asks for another name if it does:
            [[ ! $matches_existing_vm ]] && break || read -p "'$dest_vm' is an existing VM. You must choose a different name for the new VM to be replicated from '$src_vm': " dest_vm
        done

        # Asks the user if copy disks from $src_vm for $dest_vm:
        # -----------------------------------------------------------------------------
        read -p "Do you want to copy disk images from '$src_vm' into '$dest_vm'? (NOTE: If '$src_vm' is running, it will be temporarily shutted down prior to perform the copy)' [yes/no]: " choice

        while true; do

            case $choice in

                yes|YES)
                    copy_disks=1
                    break
                ;;
                no|NO)
                    break
                ;;
                *)
                    read -p "Please, write 'yes' or 'no': " choice
                ;;
            esac
        done

        # If incremental backup patch is not detected in $src_vm, asks the user for applying this patch into $dest_vm:
        # -----------------------------------------------------------------------------
        if [[ $(vm_is_patched $src_vm) == false ]]; then

            # $src_vm isn't patched. Asks if $dest_vm should be patched:
            read -p "Do you want to patch VM '$dest_vm' in order to accept incremental backups? [yes/no]: " choice

            while true; do

                case $choice in

                    yes|YES)
                        patch_vm=1
                        break
                    ;;
                    no|NO)
                        break
                    ;;
                    *)
                        read -p "Please, write 'yes' or 'no': " choice
                    ;;
                esac
            done
        fi

        echo ""
        echo "INFO: Processing parameters for VM '$dest_vm'..."
        echo ""

        # Dumps $src_vm definitions apart, and apply changes:
        # -----------------------------------------------------------------------------

        # Create the temporary folder to be used:
        mkdir -p $working_path

        # Path to xml definitions file to be processed:
        vm_definitions_file=$working_path/$dest_vm.xml

        # Dumps current VMs XML file to a temporal location:
        virsh dumpxml --inactive --security-info $src_vm > $vm_definitions_file

        # Replaces $src_vm by $dest_vm:
        # -----------------------------------------------------------------------------
        sed -i -e "s|<name>$src_vm</name>|<name>$dest_vm</name>|" $vm_definitions_file

        # Replaces UUID:
        # -----------------------------------------------------------------------------

        # UUID of $src_vm:
        src_uuid=$(domain_id $src_vm)

        # Random UUID to replace the original one:
        dest_uuid=$(uuidgen)

        # Replaces all matches of $src_uuid for $dest_uuid:
        sed -i -e "s|$src_uuid|$dest_uuid|g" $vm_definitions_file

        if [[ $(is_unraid) ]]; then

            # On UnRaid, checks for nvram (already replaced with $dest_uuid, if exists):
            vm_nvram_path=$(grep -e "<nvram>" $vm_definitions_file | cut -d'>' -f2 | cut -d '<' -f1)

            if [ ! -z $vm_nvram_path ]; then

                # If exists in definitions and not as file, a new nvram file must be provisioned.
                # On UnRaid, it's located at a well defined path:
                template_nvram_path="/usr/share/qemu/ovmf-x64/OVMF_VARS-pure-efi.fd"

                # So, simply copies the template, renamed as the nvram filedefined for $dest_vm:
                cp -f $template_nvram_path $vm_nvram_path

                [[ $? -eq 0 ]] && echo "INFO: NVRAM device '$vm_nvram_path' successfully created." || echo "WARNING: Could not create a NVRAM device. Check the log above to detemrine the cause of the issue "
            fi
        fi

        # Replaces MAC addresses for (qemu/kvm) random ones:
        # -----------------------------------------------------------------------------

        # Gets the original list of MAC addresses from $src_vm:
        src_macaddr_list=($(get_vm_macaddr $src_vm))

        for mac in ${vm_mac_addr_list[@]}; do

            # Creates a random MAC addr for the given $src_vm MAC
            dest_macaddr_list+=($(gen_random_macaddr))

            # Replaces matching listed mac for a random one:
            sed -i -e "s|<mac address='$mac'/>|<mac address='${dest_macaddr_list[${#dest_macaddr_list[@]}]}'/>|" $vm_definitions_file
        done

        # Replaces disk image names and/or paths
        # -----------------------------------------------------------------------------

        # Gets the original disk image paths of #src_vm:
        src_img_paths_list=($(list_vm_img_paths $src_vm))

        i=0
        for path in ${src_img_paths_list[@]}; do

            #Attempts to define new paths and/or images based upon VM names:
            new_path=(${path//$src_vm/$dest_vm})

            if [[ $path != $new_path ]]; then

            # When $path results modified by matches in VM name, asks for confirmation:
            read -p "Create/Define automatically disk image path as '$new_path'? [ENTER to confirm, or insert a custom path manually]: " choice

            while true; do

                if [ -z $choice ]; then

                    # User confirms the automatic choice:
                    dest_img_paths_list+=($new_path)
                    break

                elif [[ $choice == /* ]]; then

                    # User defined the path manually:
                    dest_img_paths_list+=($choice)
                    break
                else
                    read -p "$choice : Invalid choice. Insert an absolute path to the new disk image, or press ENTER to set it as '$new_path': " choice
                fi
            done

            else

                echo "Disk image '$path' cannot be modified automatically by this script. Choose one of the following options:"
                echo ""
                echo "1. Insert manually the path to the new disk image"
                echo "2. Keep using the same disk image in both VMs: '$src_vm' and '$dest_vm' (may cause issues, use at your own risk)"
                echo "3. Do not define this  "
                read -p " What would you like to do?" choice




                # Replaces matching path for a new path:
                sed -i -e "s|<source file='$path'/>|<source file='${dest_img_paths_list[$i]}'/>|" $vm_definitions_file

                # Creates the folder that will contain the given disk image:
                mkdir -p $(dirname $new_path)
            else
                echo "WARNING: Could not find a match to replace path '$path' in VM '$dest_vm'. You will need to replace"
                # No matches for $src_vm were found:
                failed_paths_list+=($path)
            fi
            ((i++))
        done

        if [ ! -z ${dest_img_paths_list[@]} ]; then

            # $src_vm disks must be closed in order to perform a copy:
            if [[ $copy_disks ]] && [[ $(domain_state $src_vm) == running ]]; then

                # Mark $src_vm  to be turned on after the copy:
                src_vm_was_on=1

                # Shuts down $src_vm
                shutdown_vm $src_vm

                # Gets the status of the operation:
                shutdown_status=$?
            fi

            i=0
            for image_path in ${dest_img_paths_list[@]}; do

                # Creates the full path for each image file, if doesn't exist:
                mkdir -p $(dirname $image_path)

                if [ $copy_disks ] && [[ $shutdown_status -eq 0 ]]; then

                    # Copies the image disk only when conditions apply:
                    echo "INFO: Replicating '${src_img_paths_list[$i]}' as '$image_path'..."
                    qemu-img convert -O qcow2 ${src_img_paths_list[$i]} $image_path
                fi
                ((i++))
            done

            # Starts $src_vm if it was previously running before the copy:
            [[ $src_vm_was_on ]] && virsh start $src_vm
        fi

        # Reports about the success/fail of the operation:
        # -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------

    else
        echo "ERROR: No persistent Virtual Machines detected! (is libvirt service running?)"
    fi
else
    # Argument(s) detected. By now, only shows the help and exits:
    echo "WARNING: Arguments aren't suported"
    #show_help
    #status=0
fi

exit $status
