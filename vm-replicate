#!/bin/bash

# Temporal path to store files (as .xml):
working_path="$HOME/.$(basename $0).tmp"

# Location of script where all functions and global variables to be used are declared:
# (Here, on the same dir
functions_path="$(dirname $0)/functions"

# Main execution:
# -----------------------------------------------------------------------------

# Load functions:
source $functions_path

status=1
if [ -z $@ ]; then

    # No input parameters enables the interctive mode:
    #show_help
    #read -n1 -s -r -p $'Press any key to continue, or Ctrl+C to Cancel...\n' key

    vms_list=($(virsh list --all --persistent --name))

    if [ $? == 0 ] && [[ ${#vms_list[@]} -ge 1 ]]; then

        # Only proceeds either if libvirt doesn't report an error, and if there are non-trasient VMs:
        echo ""
        echo "Scanning for Virtual Machines..."
        echo ""
        echo "${#vms_list[@]} VMs found in Host $(cat /etc/hostname):"
        echo '-------------------------------------------------------------------------------'
        printf " %s \t %-15s \t %s \n" "#" "VM Name" "Drives"
        echo '-------------------------------------------------------------------------------'

        i=0
        for vm in "${vms_list[@]}"; do

            # Gets a list with drives in each VM that can b e restored:
            vm_drives_list+=("$(list_vm_drives $vm)")

            # Shows each VM found, including the restorable drives:
            printf " %s \t %-15s \t %s \n" "$(( $i + 1))" "$vm" "${vm_drives_list[$i]}"
            ((i++))
        done

        # Asks the user to choose a VM to clone:
        # -----------------------------------------------------------------------------
        echo ""
        choice=$(choose_number "Choose the Virtual Machine # in the list to be replicated" "1" "${#vms_list[@]}")

        # Saves VM specs that will be used for restoration:
        src_vm="${vms_list[(( $choice - 1 ))]}"
        src_vm_img_paths_list=($(list_vm_img_paths $src_vm))
        vm_drives_list=(${vm_drives_list[(( $choice - 1 ))]})

        echo ""
        echo "INFO: VM $src_vm selected as source for being replicated"

# ADD OPTION TO REPLICATE VM ON A REMOTE HOST:
# -----------------------------------------------------------------------------

        # Asks the user for a name to be used for the New VM:
        # -----------------------------------------------------------------------------
        read -p "Choose a unique name for the new VM: " dest_vm

        while true; do

            vm_already_exists=""
            for vm in ${vms_list[@]}; do

                [[ $dest_vm == $vm ]] && { vm_already_exists=1; break; }
            done

            [ ! -z $vm_already_exists ] && read -p "VM $dest_vm already exists. You must choose a different name: " dest_vm || break
        done

        if [ ! -z ${vm_drives_list[@]} ]; then

            # Asks the user for copying disks from $src_vm for $dest_vm
            # -----------------------------------------------------------------------------
            echo ""
            copy_disks=$(yes_no "Do you want to replicate the disk images from $src_vm into $dest_vm?" "yes")
            case $copy_disks in

                yes)
                    echo ""
                    echo "INFO: Disk images will be provisioned"

                    # Looks for the VM state and notifies about a sudden shutdown (necessary to perform disk clonning:
                    src_vm_state=$(domain_state $src_vm)
                    [[  $src_vm_state != "shut off" ]] && echo "WARNING: VM $src_vm is currently $src_vm_state. It will be temporarily shutted down during the process."
                ;;

                no)
                    echo ""
                    echo "INFO: No disk images will be provisioned (you must provide it manually)"

                    # Asks the user for checking / modifying paths:
                    # -----------------------------------------------------------------------------
                    check_paths=$(yes_no "Do you still want to check (and possibly redefine) image disk paths for VM $dest_vm?" "yes")
            esac

            if [ $copy_disks == yes ] || [ $check_paths == yes ]; then

                # When disk images are to be copied, or the user wants to check / redefine new paths for $dest_vm
                # Shows the possible options and ways to modify them:
                # -----------------------------------------------------------------------------

                i=0
                for path in ${src_vm_img_paths_list[@]}; do

                    auto_path=""
                    # Number of options present in the below dialog:
                    menu_option=1
                    echo ""
                    echo '-------------------------------------------------------------------------------'
                    echo "Options for disk ${vm_drives_list[$i]} (source: $path) "
                    echo '-------------------------------------------------------------------------------'
                    echo ""
                    echo "$menu_option. Set the disk image path manually to custom location and name"

                    # Attempts to find a new path matching by Vm name:
                    proposed_path=${path//$src_vm/$dest_vm}

                    if [[ $path != $proposed_path ]]; then

                        # And if this action is possible, proposes it as an option:
                        auto_path=1
                        ((menu_option++))
                        echo "$menu_option. Set the disk image path automatically to: $proposed_path"
                    fi

                    if [ $copy_disks == no ] ; then

                        # Only when user has chosen to not copy disks, show the 3rd option:
                        ((menu_option++))
                        echo "$menu_option. Keep the disk image path unchanged: $path"
                    fi

                    echo ""
                    choice=$(choose_number "Choose the # of the action you want to perform" "1" "$menu_option")

                    case $choice in

                        1)
                            # User has chosen to set path manually:
                            echo ""
                            read -p "Insert the full path to the disk image (e.g. /path/to/disk.img): " manual_path
                            while true; do

                                for path in ${dest_vm_img_paths_list[@]}; do

                                    path_already_exists=""
                                    # Checks if path was already defined for another disk (in the same VM):
                                    [[ $manual_path == $path ]] && { path_already_exists=1; break; }
                                done

                                message=""
                                if [ $path_already_exists ]; then

                                    message="'$manual_path' was already defined for this VM and cannot be used"
                                elif [[ $manual_path != /* ]]; then

                                    message="'$manual_path' is not an absolute path"
                                else

                                    dest_vm_img_paths_list+=($manual_path)
                                    break
                                fi

                                read -p "$message. Insert the full path to the disk image (image name included): " manual_path
                            done
                        ;;
                        2)
                            if [ $auto_path ]; then

                                # $proposed_path is plausible and has been chosen:
                                dest_vm_img_paths_list+=($proposed_path)
                            elif [ $copy_disks == yes ]; then

                                # $proposed_path isn't plausible and $copy_disks was set to 'no'
                                # User has set to keep path:
                                dest_vm_img_paths_list+=($path)
                            fi
                        ;;
                        3)
                                # $proposed_path is plausible and $copy_disks was set to 'no'
                                # User has set to keep path:
                                dest_vm_img_paths_list+=($path)
                        ;;
                    esac

                    echo ""
                    echo "INFO: Disk image path for ${vm_drives_list[$i]} set to ${dest_vm_img_paths_list[$i]}"
                done
            fi
        fi

        # If incremental backup patch is not detected in $src_vm, asks the user for applying this patch into $dest_vm:
        # -----------------------------------------------------------------------------
        if [[ $(vm_is_patched $src_vm) == false ]]; then

            # $src_vm isn't patched. Asks if $dest_vm should be patched:
            patch_vm=$(yes_no "Do you want to patch VM '$dest_vm' in order to accept incremental backups?" "yes")

        fi
        # End of interactive part.
        # -----------------------------------------------------------------------------

        echo ""
        echo "INFO: Processing parameters for VM '$dest_vm'..."
        echo ""

        # Dumps $src_vm definitions apart, and apply changes:
        # -----------------------------------------------------------------------------

        # Create the temporary folder to be used:
        mkdir -p $working_path

        # Path to xml definitions file to be processed:
        vm_definitions_file=$working_path/$dest_vm.xml

        # Dumps current VMs XML file to a temporal location:
        virsh dumpxml --inactive --security-info $src_vm > $vm_definitions_file

        # Replaces VM name ($src_vm by $dest_vm):
        # -----------------------------------------------------------------------------
        sed -i -e "s|<name>$src_vm</name>|<name>$dest_vm</name>|" $vm_definitions_file

        # Replaces VM UUID (randomized):
        # -----------------------------------------------------------------------------

        # UUID of $src_vm:
        src_uuid=$(domain_id $src_vm)

        # Random UUID to replace the original one:
        dest_uuid=$(uuidgen)

        # Replaces all matches of $src_uuid for $dest_uuid:
        sed -i -e "s|$src_uuid|$dest_uuid|g" $vm_definitions_file

        # On UnRaid, checks for nvram (already replaced with $dest_uuid, if exists):
        # -----------------------------------------------------------------------------
        if [[ $(is_unraid) ]]; then

            vm_nvram_path=$(grep -e "<nvram>" $vm_definitions_file | cut -d'>' -f2 | cut -d '<' -f1)

            if [ ! -z $vm_nvram_path ]; then

                # If exists in definitions and not as file, a new nvram file must be provisioned.
                # On UnRaid, it's located at a well defined path:
                template_nvram_path="/usr/share/qemu/ovmf-x64/OVMF_VARS-pure-efi.fd"

                # So, simply copies the template, renamed as the nvram filedefined for $dest_vm:
                cp -f $template_nvram_path $vm_nvram_path

                [[ $? -eq 0 ]] && echo "INFO: NVRAM device '$vm_nvram_path' successfully created." || echo "WARNING: Could not create a NVRAM device. Check the log above to detemrine the cause of the issue "
            fi
        fi

        # Replaces MAC addresses for (qemu/kvm) randomized ones:
        # -----------------------------------------------------------------------------

        # Gets the original list of MAC addresses from $src_vm:
        src_macaddr_list=($(get_vm_macaddr $src_vm))

        for mac in ${vm_mac_addr_list[@]}; do

            # Creates a random MAC addr for the given $src_vm MAC
            dest_macaddr_list+=($(gen_random_macaddr))

            # Replaces matching listed mac for a random one:
            sed -i -e "s|<mac address='$mac'/>|<mac address='${dest_macaddr_list[${#dest_macaddr_list[@]}]}'/>|" $vm_definitions_file
        done

        # When defined by the user, Replaces disk image paths:
        # -----------------------------------------------------------------------------

        if [ ! -z ${dest_vm_img_paths_list[@]} ]; then

            i=0
            for path in ${dest_vm_img_paths_list[@]}; do

                # Replaces $src_vm paths for a $dest_vm paths:
                sed -i -e "s|<source file='${src_vm_img_paths_list[$i]}'/>|<source file='$path'/>|" $vm_definitions_file
            done
        fi

        # When defined by the user, replicates disk images:
        # -----------------------------------------------------------------------------

        if [ $copy_disks == yes ]; then


            if [[ $(domain_state $src_vm) != "shut off" ]]; then

                # Mark $src_vm  to be turned on after the copy:
                src_vm_was_on=1

                # Shuts down $src_vm
                shutdown_vm $src_vm

                # Gets the status of the operation:
                shutdown_status=$?

            else
                shutdown_status=0
            fi


            if [[ $shutdown_status -eq 0 ]]; then

                i=0
                for image_path in ${dest_vm_img_paths_list[@]}; do

                    # Copies the image disk only when conditions apply:
                    echo "INFO: Replicating '${src_vm_img_paths_list[$i]}' as '$image_path'..."

                    mkdir -p $(dirname $image_path)
                    qemu-img convert -O qcow2 ${src_vm_img_paths_list[$i]} $image_path

                    # Notifies about success or fail of each disk image provisioning for $dest_vm:
                    [[ $? -eq 0 ]] && echo "INFO: $image_path provisioned successfully" || echo "ERROR: Failed provisioning $image_path. Read the logs above for more info"
                    ((i++))
                done
            else
                echo "ERROR: VM $src_vm could not be properly powered off. Aborting disk image provisioning. Read the logs above for more info"

            fi
            if [ $src_vm_was_on ]; then

                # Starts $src_vm if it was previously running before the copy:
                echo "INFO: Powering on $src_vm..."
                virsh start $src_vm
            fi
        fi

        # If requested, patches $dest_vm for incremental backups:
        # -----------------------------------------------------------------------------

        if [ $patch_vm ]; then

            # Patches $dest_vm:
            patch_xml $vm_definitions_file

            [[ $? -eq 0 ]] && message="INFO: Incremental backup capability successfully added to $dest_vm" || message="WARNING: Oops! Something went wrong adding incremental backup capability to $dest_vm. This may imply this VM is incompatible with QEMU/KVM."
        fi

        # Finally, defines the VM in QEMU/KVM and cleanses temporal files::
        # -----------------------------------------------------------------------------

         virsh define $vm_definitions_file

        if [[ $? -eq 0 ]]; then

            echo "INFO: VM $dest_vm successfully added"
            rm -rf $working_path
            status=0
        else
            echo "ERROR: Could not define VM $dest_vm to QEMU/KVM. Check $working_path in order to see what could be wrong."
        fi

    else
        echo "ERROR: No persistent Virtual Machines detected! (is libvirt service running?)"
    fi
else
    # Argument(s) detected. By now, only shows the help and exits:
    echo "WARNING: Arguments aren't suported"
    #show_help
    #status=0
fi

exit $status
