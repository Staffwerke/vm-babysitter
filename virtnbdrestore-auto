#!/bin/bash

: << 'scheduled_actions'
virtnbdrestore-auto

DONE Choose the VM to be restored
DONE Choose the path to the backup to be restored
DONE If more than one checkpoint detected, show a list of them and choose which one to restore.

Check selected backup for disk(s)
If more than one backed up disk, ask for choose which disk will be restored

Ask the user if wants to keep old disks after restoration
Ask the user if it wants to turn on the VM once it has been restored

Confirm restoration begin:

For each selected disk:
    Restore until the given checkpoint (if given one) onto the original location according with virsh
    If process is successful, rename the resulting disk with '.restored' extension.
    If VM is running, shutdown it (await for 'shut off' state)
    If VM has previous checkpoints, delete all metadata.
    If 'keep' answer was yes, rename old disk image with timestamp. Delete if no.
    Rename the .restored as the original disk.

If 'turn on' answer is yes, start the VM.
scheduled_actions

# -----------------------------------------------------------------------------

# VM name
#vm_name=$1

# Backup location
#backup_path=$2

#checkpoint_num="$3"

# Returns a formatted string that is the last modified date and time:
# -----------------------------------------------------------------------------
last_modified()
{
    echo $(date -r $1 "+%Y-%m-%d %H:%M:%S")
}

# Returns a string value with the state reported by libvirt (e.g. "running", "shut off", etc.)
# -----------------------------------------------------------------------------
domain_state()
{
echo $(virsh domstate $1)
}

# For a given VM name, returns a string value with (restorable) virtual drives (separated by spaces) (e.g. "hdc hdd")
# -----------------------------------------------------------------------------
vm_drives_list()
{
    local vm_drives=($(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/file//g' -e 's/disk//g' -e 's/ //g' | cut -d'/' -f1))
    echo ${vm_drives[@]}
}

# For a given VM name, returns a string value with absoulte path to its image disks (e.g. "/path-to/hdc.img /path-to/hdd.img")
# -----------------------------------------------------------------------------
vm_img_paths_list()
{
    local img_paths=$(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/file//g' -e 's/disk//g' -e 's/ //g')
    echo ${img_paths/\// \/} | cut -d' ' -f2
}

# Main execution:
# -----------------------------------------------------------------------------

# Load all functions
#source $PWD/functions.sh

status=1
if [ -z $@ ]; then

    #echo "Let's begin! A list of existent VMs will be displayed below"
    #read -n1 -s -r -p $'Press any key to continue...\n' key

# Asks the user to choose a VM to restore:
# -----------------------------------------------------------------------------
    vms_list=($(virsh list --all --persistent --name))
    if [ $? == 0 ] && [[ ${#vms_list[@]} -ge 1 ]]; then

        # Only proceeds is libvirt doesn't report an error, and if there are non-trasient VMs:

        echo ""
        echo "${#vms_list[@]} VMs found in $(cat /etc/hostname):"
        echo  '-------------------------------------------------'
        printf '%s\t%s\t\t%s\n' '#' 'VM Name ' 'Drives'
        echo  '-------------------------------------------------'
        #vms_drives_list=()
        i=0
        for vm in "${vms_list[@]}"; do

            #vms_drives_list+=("$(vm_drives $vm)")
            printf '%s\t%s\t\t%s\n' "$(( $i + 1))" "$vm    " "$(vm_drives_list $vm)" #"$(domain_state $vm)"       #"${vms_drives_list[$i]}"
            ((i++))
        done

        read -p "Choose the VM Number on the list you want to be restored [1-${#vms_list[@]}]: " choice

        while true; do
            if [[ $choice -ge 1 ]] && [[ $choice -le ${#vms_list[@]} ]]; then
                vm_name=${vms_list[(($choice - 1))]}
                break
            else
                read -p "$choice : Invalid choice. Please choose a number of the list [1-${#vms_list[@]}]: " choice
            fi
        done

        echo ""
        echo "VM '$vm_name' selected for being restored"
        echo ""

# Asks the user for the main path to backups:
# -----------------------------------------------------------------------------
        read -p "Insert the full path to the Main Backups folder (where all backups are stored): " backup_path

        while true; do
            if [[ $backup_path == /* ]] && [ -d $backup_path ]; then

                # Scan directory for valid backup folders:
                items_list=$(ls $backup_path) #| grep '/$' | sed -e 's/\///g')

                backups_list=()
                for item in $items_list; do
                    if [ -d $backup_path/$item ] && [ -f $backup_path/$item/*.cpt ] && [ -d $backup_path/$item/checkpoints ]; then

                        # If virtnbdbackup scheme are detected, it is considered a valid backup folder:
                        backups_list+=("$item")
                    fi
                done

                if [ ! -z $backups_list ]; then

                    # Will continue only when at least one valid virtnbdbackup folder was detected:
                    break

                else
                    read -p "No backups were found in '$backup_path'. Choose another path with backups: " backup_path
                fi
            else
                read -p "'$backup_path': Does not exist (not a directory) or it is a relative path. Verify the path and try again: " backup_path
            fi
        done

# Ask the user to choose a backup to restore:
# -----------------------------------------------------------------------------

        # Shows a list of restorable backups folder to choose:
        echo ""
        echo "${#backups_list[@]} backups found in $backup_path:"
        echo "--------------------------------------------"
        printf '%s\t%s\n' "#    "  "Backup Name"
        echo "--------------------------------------------"
        i=1
        for backup in "${backups_list[@]}"; do
            printf '%s\t%s\n' "$i   " "$backup"
            ((i++))
        done

        read -p "Choose the Backup Number in the list you want to restore [1-${#backups_list[@]}]: " choice

        while true; do
            if [[ $choice -ge 1 ]] && [[ $choice -le ${#backups_list[@]} ]]; then

                # Will only continue if the given option is valid:
                backup_name=${backups_list[(( $choice - 1 ))]}
                break
            else
                read -p "$choice : Invalid choice. Please choose a number of the list [1-${#backups_list_list[@]}]: " choice
            fi
        done

# Ask the user to choose a checkpoint (if any) to restore
# (Will be skipped automatically if no incremental backups are detected):
# -----------------------------------------------------------------------------
        echo ""
        echo "Scanning for checkpoints..."

        checkpoints_list=(`cat $backup_path/$backup_name/*.cpt | sed -e 's/\[//g' -e 's/\"//g' -e 's/,//g' -e 's/\]//g'`)

        echo "${#checkpoints_list[@]} Checkpoints found in $backup_path/$backup_name:"

        # More than one item means the backup chain has incremental backups:
        if [[ ${#checkpoints_list[@]} -gt 1 ]]; then

            # Header to show when there are incremental backups:
            echo  '--------------------------------------------'
            printf '%s\t%s\n' 'Checkpoint.Index  ' 'Date / Time'
            echo  '--------------------------------------------'
            checkpoint_dates_list=()
            i=0
            for checkpoint in "${checkpoints_list[@]}"; do

                # Gets the Date/Time of a given checkpoint into the chosen backup:
                checkpoint_dates_list+=("$(last_modified $backup_path/$backup_name/checkpoints/$checkpoint.xml)")

                # Prints on screen detailed (and tabulated) data for the given checkpoint:
                printf '%s\t%s\n' "$checkpoint    " "${checkpoint_dates_list[$i]}"
                ((i++))
            done

            read -p "Choose the Checkpoint Index in the list you want want to restore [0-$(( ${#checkpoints_list[@]} - 1 ))]: " choice

            while true; do
                if [[ $choice -ge 0 ]] && [[ $choice -le $(( ${#checkpoints_list[@]} -1 )) ]]; then

                    checkpoint_index=$choice
                    checkpoint_date="${checkpoint_dates_list[$checkpoint_index]}"
                    break
                else
                    read -p "$choice : Invalid choice. Please choose a number of the list [0-$(( ${#checkpoints_list[@]} - 1 ))]: " choice
                fi
            done

        else
            # When no incremental backups are detected, will only gather info abotu the (unique) existing full backup,
            # and will show the info:
            checkpoint_index=0
            checkpoint_date=$(last_modified $backup_path/$backup_name/checkpoints/${checkpoints_list[$checkpoint_index]}.xml)
            echo "INFO: No incremental backups detected in '$backup_name' (the existing full backup will be chosen automatically)"
        fi

        echo ""
        echo "Selected checkpoint: '${checkpoints_list[$checkpoint_index]}' (Saved at $checkpoint_date)"
        echo ""
        status=0

    else
        echo "ERROR: No VMs detected in $(cat /etc/hostname) (is libvirt service running?)"
    fi

fi

exit $status
