#!/bin/bash

# -----------------------------------------------------------------------------

# VM name
#vm_name=$1

# Backup location
#backup_path=$2

#checkpoint_num="$3"

# Generic name for all checkpoints (and bitmaps) into a given backup chain:
checkpoint_name="virtnbdbackup"

# Default path for checkpoints of a given backup chain (there are cases where this parameter is outside the backup chain)
#checkpoints_path="checkpoints"

# Returns a formatted string that is the last modified date and time:
# -----------------------------------------------------------------------------
last_modified()
{
    echo $(date -r $1 "+%Y-%m-%d_%H:%M:%S")
}

# Returns a string value with the state reported by libvirt (e.g. "running", "shut off", etc.)
# -----------------------------------------------------------------------------
domain_state()
{
echo $(virsh domstate $1)
}

# For a given checkpoint file, returns a string value with (restorable) virtual drives (separated by spaces) (e.g. "hdc hdd")
# -----------------------------------------------------------------------------
list_backup_drives()
{
    echo $(grep -e "checkpoint='bitmap'" $1 | cut -d"'" -f2)
}

# For a given VM name, returns a string value with (restorable) virtual drives (separated by spaces) (e.g. "hdc hdd")
# -----------------------------------------------------------------------------
list_vm_drives()
{
    echo $(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/file//g' -e 's/disk//g' -e 's/ //g' | cut -d'/' -f1)
}

# For a given VM name, returns a string value with absoulte path to its image disks (e.g. "/path-to/hdc.img /path-to/hdd.img")
# -----------------------------------------------------------------------------
list_vm_img_paths()
{
    echo $(virsh domblklist --details $1 | grep -e file | grep -e disk | sed -e 's/ file //g' -e 's/ disk //g' | rev | cut -d' ' -f1 | rev )
}

# Sorts unordered items lexicographically. This is used for user input not in order:
# -----------------------------------------------------------------------------
sort_items()
{
    echo $@ | xargs -n1 | sort | xargs
}

# Runs a volatile container that executes virtnbdrestore with specific options:
# -----------------------------------------------------------------------------
restore_vm()
{
local restore_status=1
local restore_vm_command="/usr/local/bin/virtnbdrestore"

local action="restore"
local full_backup_path="$1"
local full_restoration_path="$2"
local point_in_time="--until $3"
local drive_to_restore="-d $4"

local full_restore_vm_command="$restore_vm_command -i $full_backup_path -a $action -o $full_restoration_path $point_in_time $drive_to_restore"

if [[ -x $restore_vm_command ]] ; then

    # When virtnbdbackup is installed locally, attempt a to recovery via local scripts:
    $full_restore_vm_command
    #echo "Simulation of local execution: $full_restore_vm_command"
else

    # Otherwise, use virtnbdbackup-docker to perform the operation:

    # Docker source image:
    local src_image="adrianparilli/virtnbdbackup-docker:latest"

    # Name of the Docker container to be used in this operation (based upon backup and drive names):
    local docker_name=$(echo $full_backup_path | rev | cut -d'/' -f1 | rev)

    # Common bind mounts for all Operating Systems:
    local bind_mounts=" -v $full_backup_path:$full_backup_path -v $full_restoration_path:$full_restoration_path -v /var/tmp:/var/tmp"

    # Filters kernel with matching string "Unraid" and pass specific mount points. By now, all other Operating systems are mounted in the same way:
    [[ ! -z $(uname  -r | grep -e "-Unraid$") ]] && bind_mounts+=" -v /var/run:/run -v /var/lock:/run/lock" || bind_mounts+=" -v /run:/run"

    # Runs Docker!
    docker run --rm --name $action-$docker_name $bind_mounts $src_image $full_restore_vm_command
    #echo "Simulation of docker execution: docker run --rm --name $action-$docker_name $bind_mounts $src_image $full_restore_vm_command"
fi

restore_status=$?

return $restore_status

}

# Sends shutdown signal and awaits until domain has been shutted down to return success:
# -----------------------------------------------------------------------------
shutdown_vm()
{

local shutdown_vm_status=1
local vm_needed_state="shut off"

if [[ $(domain_state $1) == $vm_needed_state ]]; then

    echo "INFO: VM '$1' is already $vm_needed_state"
    shutdown_vm_status=0
else


    local wait_time=15
    local max_attempts=10
    local attempt=1

    while (( $attempt < $max_attempts )); do

        virsh shutdown $1

        sleep $wait_time

        [[ $(domain_state $1) == $vm_needed_state ]] && { shutdown_vm_status=0; break; } ||((attempt++))
    done

    local message=""
    [[ $shutdown_vm_status -eq 0 ]] && message="INFO: VM '$1' powered off successfully" || message="WARNING: Gave up after $(( $wait_time * $max_attempts )) secs. waiting for VM '$1' to power off"
fi
    echo $message
    return $shutdown_vm_status
}


# Main execution:
# -----------------------------------------------------------------------------

# Load all functions
#source $PWD/functions.sh

status=1
if [ -z $@ ]; then

    # No input parameters enables the interctive mode:

    #echo "This script restores Virtual Machine's disk image(s) saved with virtnbdbackup, and should be used only with backups created from the same VM you're attempting to restore"
    #read -n1 -s -r -p $'Press any key to continue...\n' key

# Step 1: Asks the user to choose a VM to restore:
# -----------------------------------------------------------------------------
    vms_list=($(virsh list --all --persistent --name))
    if [ $? == 0 ] && [[ ${#vms_list[@]} -ge 1 ]]; then

        # Only proceeds either if libvirt doesn't report an error, and if there are non-trasient VMs:
        echo""
        echo "Scanning for Virtual Machines..."
        echo ""
        echo "${#vms_list[@]} VMs found in Host $(cat /etc/hostname):"
        echo '------------------------------------------------------------------------------------------------------------'
        printf " %s \t %-15s \t %s \n" "#" "VM Name" "Drives"
        echo '------------------------------------------------------------------------------------------------------------'

        i=0
        for vm in "${vms_list[@]}"; do

            # Gets a list with drives in each VM that can b e restored:
            vm_drives_list+=("$(list_vm_drives $vm)")

            # Shows each VM found, including the restorable drives:
            printf " %s \t %-15s \t %s \n" "$(( $i + 1))" "$vm" "${vm_drives_list[$i]}"
            ((i++))
        done

        read -p "Choose the Virtual Machine # in the list [1-${#vms_list[@]}] you want to be restored: " choice

        while true; do

            if [[ $choice -ge 1 ]] && [[ $choice -le ${#vms_list[@]} ]]; then

                # Saves VM specs that will be used for restoration:
                vm_name="${vms_list[(( $choice - 1 ))]}"
                vm_drives_list=(${vm_drives_list[(( $choice - 1 ))]})
                vm_img_paths_list=($(list_vm_img_paths $vm_name))

                break
            else
                read -p "'$choice' is invalid. Please choose a number of the list [1-${#vms_list[@]}]: " choice
            fi
        done

        echo ""
        echo "Virtual Machine '$vm_name' selected for restoration"
        echo ""

# Step 2: Asks the user for the main path to backups:
# -----------------------------------------------------------------------------
        read -p "Insert the Full path to the Nearest directory containing all backups sub-directories of $vm_name: " backup_path

        while true; do
            if [[ $backup_path == /* ]] && [ -d $backup_path ]; then

                echo "Scanning for existing backup chains of $vm_name in $backup_path ..."
                folders_list=$(find $backup_path -type d -name "$vm_name*")

                i=0
                for folder in $folders_list; do
                    if [ -f $folder/*.cpt ] && [ -d $folder/checkpoints ]; then

                        # If a virtnbdbackup scheme is detected, it is considered a valid backup folder:
                        backups_list+=("$folder")

                        # Gets the drives backed up in the main checkpoint:
                        backup_drives_list+=("$(list_backup_drives $folder/checkpoints/$checkpoint_name.0.xml)")

                        # And finally, creates an ordered list of backup names to be displayed:
                        backup_names_list+=("$(echo $folder | rev | cut -d '/' -f1 | rev)")
                    fi
                done

                # Will continue only when at least one valid virtnbdbackup folder has been detected:
                [ ! -z $backups_list ] && break || read -p "Sorry, no matching backups for $vm_name were found in '$backup_path'. Choose a more specific path containing backups: " backup_path

            else

                read -p "'$backup_path': Does not exist, is not a directory, or it is a relative path. Verify the path and re-enter it: " backup_path
            fi
        done


        # Shows a list of restorable backups folder to choose:
        echo ""
        echo "${#backups_list[@]} backups found in $backup_path:"

        if [[ ${#backups_list[@]} -gt 1 ]]; then

# Step 3: If multiple backups found for certain VM, asks the user to choose a backup to restore:
# -----------------------------------------------------------------------------

            echo '------------------------------------------------------------------------------------------------------------'
            printf " %s \t %-15s \t %s \n" "#"  "Backup Name" "Drives"
            echo '------------------------------------------------------------------------------------------------------------'
            i=0
            for backup in "${backups_list[@]}"; do

                printf " %s \t %-15s \t  %s \n" " $(( $i + 1))" "${backup_names_list[$i]}" "${backup_drives_list[$i]}"
                ((i++))
            done

            read -p "Choose the Backup Number in the list [1-${#backups_list[@]}] you want to restore: " choice

            while true; do
                if [[ $choice -ge 1 ]] && [[ $choice -le ${#backups_list[@]} ]]; then

                    # Saves Backup specs that will be used later:
                    backup_path="${backups_list[(( $choice - 1 ))]}"
                    backup_name="${backup_names_list[(( $choice - 1 ))]}"
                    backup_drives_list=(${backup_drives_list[(( $choice - 1 ))]})
                    break
                else
                    read -p "'$choice' is invalid. Please choose a number of the list [1-${#backups_list[@]}]: " choice
                fi
            done
        else

            echo "Backup named as '${backup_names_list[@]}' selected automatically (no other recognizable backups available for VM '$vm_name' in $backup_path)"

            backup_name="${backup_names_list[@]}"
            backup_path="${backups_list[@]}"
            backup_drives_list=(${backup_drives_list[@]})
        fi


        echo ""
        echo "Scanning for checkpoints..."

        checkpoints_list=(`cat $backup_path/*.cpt | sed -e 's/\[//g' -e 's/\"//g' -e 's/,//g' -e 's/\]//g'`)

        echo "${#checkpoints_list[@]} Checkpoints found for backup '$backup_name':"

         if [[ ${#checkpoints_list[@]} -gt 1 ]]; then

# Step 4: If multiple checkpoints are found, asks the user to choose a specific checkpoint to restore:
# -----------------------------------------------------------------------------

            # Header to show when there are incremental backups:
            echo '------------------------------------------------------------------------------------------------------------'
            printf " %s \t %s \n" "Checkpoint" "Saved at"
            echo '------------------------------------------------------------------------------------------------------------'
            i=0
            for checkpoint in "${checkpoints_list[@]}"; do

                # Gets the Date/Time of a given checkpoint into the chosen backup:
                checkpoint_dates_list+=("$(last_modified $backup_path/checkpoints/$checkpoint.xml)")

                # Prints on screen detailed (and tabulated) data for the given checkpoint:
                printf ' %s \t %s \n' "$checkpoint" "${checkpoint_dates_list[$i]}"
                ((i++))
            done

            default_choice=$(( ${#checkpoints_list[@]} - 1 ))

            read -p "Choose the Checkpoint Number in the list [0-$default_choice] you want to restore, or press ENTER to select the latest one: " choice

            while true; do
                if [ -z $choice ]; then

                    checkpoint_index="${checkpoints_list[$default_choice]}"
                    checkpoint_date="${checkpoint_dates_list[$default_choice]}"
                    break

                elif [[ $choice -ge 0 ]] && [[ $choice -le $(( ${#checkpoints_list[@]} -1 )) ]]; then

                    checkpoint_index="${checkpoints_list[$choice]}"
                    checkpoint_date="${checkpoint_dates_list[$choice]}"
                    break
                else

                    read -p "$choice : Invalid choice. Please choose a number of the list [0-$(( ${#checkpoints_list[@]} - 1 ))]: " choice
                fi
            done
        else

            echo "INFO: No incremental backups detected in '$backup_name', the (only) existing backup will be used..."
            checkpoint_index="${checkpoints_list[@]}"
            checkpoint_date=$(last_modified $backup_path/$backup_name/checkpoints/${checkpoints_list[$checkpoint_index]}.xml)
        fi

        echo ""
        echo "Checkpoint selected: '$checkpoint_index' (Saved at $checkpoint_date)"
        echo ""

        if [[ ${#vm_drives_list[@]} -gt 1 ]] || [[ ${#backup_drives_list[@]} -gt 1 ]]; then

# Step 5: If multiple drives are found, asks the user for restoring specific ones:
# -----------------------------------------------------------------------------

            if [[ ${vm_drives_list[@]} == ${backup_drives_list[@]} ]]; then

                # Only use case it's when both VM and backup chain, contain identical lists of drives:
                echo "${#backup_drives_list[@]} restorable drives found in both, VM $vm_name and Backup $backup_name: ${backup_drives_list[@]}"
                read -p "To restore specific drive(s) only, insert their names separated by spaces; or just press ENTER to restore all the drives: " chosen_drives

                while true; do

                    if [ -z "$chosen_drives" ]; then

                        # The user has pressed ENTER without specify specific drives:
                        selected_drives=(${backup_drives_list[@]})
                        break
                    else

                        selected_drives=()
                        invalid_drives=()
                        for drive in $chosen_drives; do

                            # Verifies the drive name is in $backup_drives_list, and adds if it matches:
                            [[ ! -z $(echo ${backup_drives_list[@]} | grep -w $drive) ]] && selected_drives+=("$drive") || invalid_drives+=("$drive")
                        done

                        # When at least one invalid drive has been detected, notifies the user and asks for insert drive names correctly:
                        if [[ ${#invalid_drives[@]} -eq 0 ]]; then

                            selected_drives=($(sort_items ${selected_drives[@]}))
                            break
                        else

                            invalid_drives="${invalid_drives[@]}"
                            read -p "'${invalid_drives// /,}' not found. Specify the exact drives you want to restore (or just ENTER to restore all the drives): " chosen_drives
                        fi
                    fi
                done

            #else

                    # TO DO: Add other use cases (e.g. VM and backup lists of drives don't match, etc.

            fi
        else

            selected_drives=(${backup_drives_list[@]})
        fi

        echo "Drives to be restored in VM $vm_name: ${selected_drives[@]}"

# Step 6: Ask for keep or not old backup files:
# -----------------------------------------------------------------------------

        read -p "Do you want to keep the old disk images? [yes/no]: " choice

        while true; do

            case $choice in

                yes|YES)
                    keep_old_disks=1
                    break
                ;;

                no|NO)
                    break
                ;;

                *)
                    read -p "Please, write 'yes' or 'no': " choice
                ;;
            esac
        done

        read -n1 -s -r -p $'\nReady to go!\nPress any key to start (or Ctrl+C to Cancel)\n' key

# Step 7: Perform the restoration:
# -----------------------------------------------------------------------------

        # Shutdown $vm_name
        shutdown_vm $vm_name

        if [[ $? == 0 ]]; then

            echo ""
            echo "INFO: Restoration of VM '$vm_name' (${selected_drives[@]}) checkpoint '$checkpoint_index' saved at $checkpoint_date in progress..."
            echo "============================================================================================================"
            i=0
            for drive in ${selected_drives[@]}; do

                # Current image name and path for $drive:
                img_name=$(basename ${vm_img_paths_list[$i]})
                img_path=$(dirname ${vm_img_paths_list[$i]})

                # Retrieves the correspondent drive according the chosen options,
                # to the same directory where original image disk is, using the same drive name (e.g. 'hdc')
                restore_vm $backup_path $img_path $checkpoint_index $drive

                echo '------------------------------------------------------------------------------------------------------------'
                echo""

                if [[ $? == 0 ]]; then

                    echo "INFO: Stream of drive $drive successfully transferred"

                    if [[ -f $img_path/$img_name ]]; then

                        if [[ $keep_old_disks ]]; then

                            # Saves the old disk image with a different name:
                            old_img_name="$img_name.$(last_modified $img_path/$img_name)"
                            mv $img_path/$img_name $img_path/$old_img_name

                            echo "INFO: Old disk image at $img_path saved as '$old_img_name'"
                        else
                            # Removes the old image before to be replaced by the new one:
                            rm -f $img_path/$img_name
                        fi
                    else
                        echo "WARNING: Disk image ($img_name) was not found at $img_path (it will be replaced directly)"
                    fi

                    # Renames the retrieved image to its correspondent name as of libvirt definitions (name and path):
                    mv $img_path/$drive $img_path/$img_name

                    # Adds the drive to the restored_drives list:
                    restored_drives+=($drive)
                    echo "INFO: Image Drive '$drive' has been successfuly restored"

                    # TO DO: Remove all past checkpoints metadate from libvirt

                else
                    # Removes any incomplete image, if exists:
                    rm -f $img_path/$drive

                    # Adds the drive to the failed_drives list:
                    failed_drives+=($drive)
                    echo "WARNING: Stream of drive $drive has failed!"
                fi
            done

            echo '============================================================================================================'
            echo ""

            if [[ ${#restored_drives[@]} -eq ${#selected_drives[@]} ]]; then

                echo ""
                echo "INFO: Restoration of Virtual Machine '$vm_name' was fully completed!"
                status=0

            elif [[ ${#restored_drives[@]} -gt 1 ]]; then

                echo ""
                echo "WARNING: Restoration of Virtual Machine '$vm_name' was NOT complete! (Successed: '${restored_drives[@]}' / Failed: '${failed_drives[@]}')"
                echo "Check the logs above to determine the cause of the problem, solve it and run this script again (choosing the above failed drives for restoration only)"
                status=2

            else
                echo "ERROR: Restoration of Virtual Machine '$vm_name' failed!"
                echo "Check the logs above to determine the cause of the problem, solve it and run this script again (no changes has been made onto the Virtual Machine)"
            fi
        else
            echo "ERROR: Could not safely start the restoration process because the Virtual Machine '$vm_name' current state ($(domain_state $vm_name)) disallows it"
        fi
    else
        echo "ERROR: No persistent Virtual Machines detected! (is libvirt service running?)"
    fi
fi

exit $status
